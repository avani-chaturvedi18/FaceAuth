<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crypto++: ByteQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crypto++
   &#160;<span id="projectnumber">8.8</span>
   </div>
   <div id="projectbrief">Free&nbsp;C&#43;&#43;&nbsp;class&nbsp;library&nbsp;of&nbsp;cryptographic&nbsp;schemes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_byte_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ByteQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data structure used to store byte strings.  
 <a href="class_byte_queue.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ByteQueue:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_byte_queue.png" usemap="#ByteQueue_map" alt=""/>
  <map id="ByteQueue_map" name="ByteQueue_map">
<area href="class_bufferless.html" alt="Bufferless&lt; BufferedTransformation &gt;" shape="rect" coords="118,168,344,192"/>
<area href="class_buffered_transformation.html" title="Interface for buffered transformations." alt="BufferedTransformation" shape="rect" coords="118,112,344,136"/>
<area href="class_algorithm.html" title="Interface for all crypto algorithms." alt="Algorithm" shape="rect" coords="0,56,226,80"/>
<area href="class_waitable.html" title="Interface for objects that can be waited on." alt="Waitable" shape="rect" coords="236,56,462,80"/>
<area href="class_clonable.html" title="Interface for cloning objects." alt="Clonable" shape="rect" coords="0,0,226,24"/>
<area href="class_d_e_r_general_encoder.html" title="DER General Encoder." alt="DERGeneralEncoder" shape="rect" coords="118,280,344,304"/>
<area href="class_d_e_r_sequence_encoder.html" title="DER Sequence Encoder." alt="DERSequenceEncoder" shape="rect" coords="0,336,226,360"/>
<area href="class_d_e_r_set_encoder.html" title="DER Set Encoder." alt="DERSetEncoder" shape="rect" coords="236,336,462,360"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue_1_1_walker.html">Walker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> iterator.  <a href="class_byte_queue_1_1_walker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c8239764938f1bb776280695e62fa0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a7c8239764938f1bb776280695e62fa0d">ByteQueue</a> (size_t nodeSize=0)</td></tr>
<tr class="memdesc:a7c8239764938f1bb776280695e62fa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>.  <a href="class_byte_queue.html#a7c8239764938f1bb776280695e62fa0d">More...</a><br /></td></tr>
<tr class="separator:a7c8239764938f1bb776280695e62fa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3ec54d26a5be3b5689ca53a906622f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a0e3ec54d26a5be3b5689ca53a906622f">ByteQueue</a> (const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;copy)</td></tr>
<tr class="memdesc:a0e3ec54d26a5be3b5689ca53a906622f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct a <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>.  <a href="class_byte_queue.html#a0e3ec54d26a5be3b5689ca53a906622f">More...</a><br /></td></tr>
<tr class="separator:a0e3ec54d26a5be3b5689ca53a906622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7436088ce8a852e9e95d291590a9f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#aad7436088ce8a852e9e95d291590a9f9">MaxRetrievable</a> () const</td></tr>
<tr class="memdesc:aad7436088ce8a852e9e95d291590a9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of bytes ready for retrieval.  <a href="class_byte_queue.html#aad7436088ce8a852e9e95d291590a9f9">More...</a><br /></td></tr>
<tr class="separator:aad7436088ce8a852e9e95d291590a9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d701bf528a1131917b77c0bb3fb369"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#ae0d701bf528a1131917b77c0bb3fb369">AnyRetrievable</a> () const</td></tr>
<tr class="memdesc:ae0d701bf528a1131917b77c0bb3fb369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether bytes are ready for retrieval.  <a href="class_byte_queue.html#ae0d701bf528a1131917b77c0bb3fb369">More...</a><br /></td></tr>
<tr class="separator:ae0d701bf528a1131917b77c0bb3fb369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e576bc7629bd0947eb098ad23b0d675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a7e576bc7629bd0947eb098ad23b0d675">IsolatedInitialize</a> (const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;parameters)</td></tr>
<tr class="memdesc:a7e576bc7629bd0947eb098ad23b0d675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize this object, without signal propagation.  <a href="class_byte_queue.html#a7e576bc7629bd0947eb098ad23b0d675">More...</a><br /></td></tr>
<tr class="separator:a7e576bc7629bd0947eb098ad23b0d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c8bb417fc6c9631ae979ce7b7d52a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a144c8bb417fc6c9631ae979ce7b7d52a">CreatePutSpace</a> (size_t &amp;size)</td></tr>
<tr class="memdesc:a144c8bb417fc6c9631ae979ce7b7d52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request space which can be written into by the caller.  <a href="class_byte_queue.html#a144c8bb417fc6c9631ae979ce7b7d52a">More...</a><br /></td></tr>
<tr class="separator:a144c8bb417fc6c9631ae979ce7b7d52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684942d5641278a78e7c237a5bd4c69d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a684942d5641278a78e7c237a5bd4c69d">Put2</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, int messageEnd, bool blocking)</td></tr>
<tr class="memdesc:a684942d5641278a78e7c237a5bd4c69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing.  <a href="class_byte_queue.html#a684942d5641278a78e7c237a5bd4c69d">More...</a><br /></td></tr>
<tr class="separator:a684942d5641278a78e7c237a5bd4c69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19413e3aa72b749e3771d617e8eca632"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a19413e3aa72b749e3771d617e8eca632">Get</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> &amp;outByte)</td></tr>
<tr class="memdesc:a19413e3aa72b749e3771d617e8eca632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 8-bit byte.  <a href="class_byte_queue.html#a19413e3aa72b749e3771d617e8eca632">More...</a><br /></td></tr>
<tr class="separator:a19413e3aa72b749e3771d617e8eca632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933457ad0a5a34fb5e7dc71b2a92c3a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a933457ad0a5a34fb5e7dc71b2a92c3a7">Get</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *outString, size_t getMax)</td></tr>
<tr class="memdesc:a933457ad0a5a34fb5e7dc71b2a92c3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a block of bytes.  <a href="class_byte_queue.html#a933457ad0a5a34fb5e7dc71b2a92c3a7">More...</a><br /></td></tr>
<tr class="separator:a933457ad0a5a34fb5e7dc71b2a92c3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41550f99083f9eff6a30ac2ad604f3ce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a41550f99083f9eff6a30ac2ad604f3ce">Peek</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> &amp;outByte) const</td></tr>
<tr class="memdesc:a41550f99083f9eff6a30ac2ad604f3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a 8-bit byte.  <a href="class_byte_queue.html#a41550f99083f9eff6a30ac2ad604f3ce">More...</a><br /></td></tr>
<tr class="separator:a41550f99083f9eff6a30ac2ad604f3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15989ef3b2f97963df4d3b471bfdc6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a6e15989ef3b2f97963df4d3b471bfdc6">Peek</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *outString, size_t peekMax) const</td></tr>
<tr class="memdesc:a6e15989ef3b2f97963df4d3b471bfdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a block of bytes.  <a href="class_byte_queue.html#a6e15989ef3b2f97963df4d3b471bfdc6">More...</a><br /></td></tr>
<tr class="separator:a6e15989ef3b2f97963df4d3b471bfdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9863db3b56bf42fb424f426afb7531cd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a9863db3b56bf42fb424f426afb7531cd">TransferTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> &amp;transferBytes, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a9863db3b56bf42fb424f426afb7531cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_byte_queue.html#a9863db3b56bf42fb424f426afb7531cd">More...</a><br /></td></tr>
<tr class="separator:a9863db3b56bf42fb424f426afb7531cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb91427c87efe486fcacb5aa726ef6ed"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#aeb91427c87efe486fcacb5aa726ef6ed">CopyRangeTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> &amp;begin, <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> end=<a class="el" href="config__int_8h.html#a2e8f5e8729bf2ba8a903917e639ec16a">LWORD_MAX</a>, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>, bool blocking=true) const</td></tr>
<tr class="memdesc:aeb91427c87efe486fcacb5aa726ef6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_byte_queue.html#aeb91427c87efe486fcacb5aa726ef6ed">More...</a><br /></td></tr>
<tr class="separator:aeb91427c87efe486fcacb5aa726ef6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4f3d3759cf2ce54cbd1a193b1cefb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a2e4f3d3759cf2ce54cbd1a193b1cefb6">SetNodeSize</a> (size_t nodeSize)</td></tr>
<tr class="memdesc:a2e4f3d3759cf2ce54cbd1a193b1cefb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set node size.  <a href="class_byte_queue.html#a2e4f3d3759cf2ce54cbd1a193b1cefb6">More...</a><br /></td></tr>
<tr class="separator:a2e4f3d3759cf2ce54cbd1a193b1cefb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003ce4b0f9525589327800d0a14b455f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a003ce4b0f9525589327800d0a14b455f">CurrentSize</a> () const</td></tr>
<tr class="memdesc:a003ce4b0f9525589327800d0a14b455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine data size.  <a href="class_byte_queue.html#a003ce4b0f9525589327800d0a14b455f">More...</a><br /></td></tr>
<tr class="separator:a003ce4b0f9525589327800d0a14b455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac218d4b07fe058306a00475222869aaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#ac218d4b07fe058306a00475222869aaa">IsEmpty</a> () const</td></tr>
<tr class="memdesc:ac218d4b07fe058306a00475222869aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine data availability.  <a href="class_byte_queue.html#ac218d4b07fe058306a00475222869aaa">More...</a><br /></td></tr>
<tr class="separator:ac218d4b07fe058306a00475222869aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c305604a71571438aeb4c4e5e567c45"><td class="memItemLeft" align="right" valign="top"><a id="a2c305604a71571438aeb4c4e5e567c45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a2c305604a71571438aeb4c4e5e567c45">Clear</a> ()</td></tr>
<tr class="memdesc:a2c305604a71571438aeb4c4e5e567c45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_empty.html" title="An Empty class.">Empty</a> the queue. <br /></td></tr>
<tr class="separator:a2c305604a71571438aeb4c4e5e567c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc94324169d07db16a246259c5ef86b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#abdc94324169d07db16a246259c5ef86b">Unget</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> inByte)</td></tr>
<tr class="memdesc:abdc94324169d07db16a246259c5ef86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data in the queue.  <a href="class_byte_queue.html#abdc94324169d07db16a246259c5ef86b">More...</a><br /></td></tr>
<tr class="separator:abdc94324169d07db16a246259c5ef86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d72210af03aea4ca132ed46d91b67e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a2d72210af03aea4ca132ed46d91b67e1">Unget</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length)</td></tr>
<tr class="memdesc:a2d72210af03aea4ca132ed46d91b67e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data in the queue.  <a href="class_byte_queue.html#a2d72210af03aea4ca132ed46d91b67e1">More...</a><br /></td></tr>
<tr class="separator:a2d72210af03aea4ca132ed46d91b67e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eef1f19b2faca146ac45333778d2eac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a0eef1f19b2faca146ac45333778d2eac">Spy</a> (size_t &amp;contiguousSize) const</td></tr>
<tr class="memdesc:a0eef1f19b2faca146ac45333778d2eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek data in the queue.  <a href="class_byte_queue.html#a0eef1f19b2faca146ac45333778d2eac">More...</a><br /></td></tr>
<tr class="separator:a0eef1f19b2faca146ac45333778d2eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127af9acc2ad34922953abd30447afa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1">LazyPut</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t size)</td></tr>
<tr class="memdesc:a127af9acc2ad34922953abd30447afa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data in the queue.  <a href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1">More...</a><br /></td></tr>
<tr class="separator:a127af9acc2ad34922953abd30447afa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90c40206fc9e8ae2c4fc984347a360a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#ac90c40206fc9e8ae2c4fc984347a360a">LazyPutModifiable</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t size)</td></tr>
<tr class="memdesc:ac90c40206fc9e8ae2c4fc984347a360a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data in the queue.  <a href="class_byte_queue.html#ac90c40206fc9e8ae2c4fc984347a360a">More...</a><br /></td></tr>
<tr class="separator:ac90c40206fc9e8ae2c4fc984347a360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7e4d3fa01a23314b7809885b770d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a9c7e4d3fa01a23314b7809885b770d23">UndoLazyPut</a> (size_t size)</td></tr>
<tr class="memdesc:a9c7e4d3fa01a23314b7809885b770d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove data from the queue.  <a href="class_byte_queue.html#a9c7e4d3fa01a23314b7809885b770d23">More...</a><br /></td></tr>
<tr class="separator:a9c7e4d3fa01a23314b7809885b770d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d004338c41f8e04a723c7adab5d0895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a6d004338c41f8e04a723c7adab5d0895">FinalizeLazyPut</a> ()</td></tr>
<tr class="memdesc:a6d004338c41f8e04a723c7adab5d0895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data in the queue.  <a href="class_byte_queue.html#a6d004338c41f8e04a723c7adab5d0895">More...</a><br /></td></tr>
<tr class="separator:a6d004338c41f8e04a723c7adab5d0895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c97a037982729f799bf7a186a5837d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a38c97a037982729f799bf7a186a5837d">operator=</a> (const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;rhs)</td></tr>
<tr class="memdesc:a38c97a037982729f799bf7a186a5837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign contents from another <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>.  <a href="class_byte_queue.html#a38c97a037982729f799bf7a186a5837d">More...</a><br /></td></tr>
<tr class="separator:a38c97a037982729f799bf7a186a5837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c7d25ea94348e3d2d2f0abe572b23e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a44c7d25ea94348e3d2d2f0abe572b23e">operator==</a> (const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a44c7d25ea94348e3d2d2f0abe572b23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise compare two <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>.  <a href="class_byte_queue.html#a44c7d25ea94348e3d2d2f0abe572b23e">More...</a><br /></td></tr>
<tr class="separator:a44c7d25ea94348e3d2d2f0abe572b23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04e8294ef9f912b902aecb2948589d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#ad04e8294ef9f912b902aecb2948589d0">operator!=</a> (const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ad04e8294ef9f912b902aecb2948589d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise compare two <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>.  <a href="class_byte_queue.html#ad04e8294ef9f912b902aecb2948589d0">More...</a><br /></td></tr>
<tr class="separator:ad04e8294ef9f912b902aecb2948589d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297d3b8e5e6e35b90a92fff23c01ea19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#a297d3b8e5e6e35b90a92fff23c01ea19">operator[]</a> (<a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> index) const</td></tr>
<tr class="memdesc:a297d3b8e5e6e35b90a92fff23c01ea19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve data from the queue.  <a href="class_byte_queue.html#a297d3b8e5e6e35b90a92fff23c01ea19">More...</a><br /></td></tr>
<tr class="separator:a297d3b8e5e6e35b90a92fff23c01ea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf03598210a516afc86abfb51ce5eb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_byte_queue.html#adcf03598210a516afc86abfb51ce5eb8">swap</a> (<a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;rhs)</td></tr>
<tr class="memdesc:adcf03598210a516afc86abfb51ce5eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents with another <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>.  <a href="class_byte_queue.html#adcf03598210a516afc86abfb51ce5eb8">More...</a><br /></td></tr>
<tr class="separator:adcf03598210a516afc86abfb51ce5eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_bufferless"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_bufferless')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_bufferless.html">Bufferless&lt; BufferedTransformation &gt;</a></td></tr>
<tr class="memitem:a872a67af13d0291373a381f41cd6ad2f inherit pub_methods_class_bufferless"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bufferless.html#a872a67af13d0291373a381f41cd6ad2f">IsolatedFlush</a> (bool hardFlush, bool blocking)</td></tr>
<tr class="memdesc:a872a67af13d0291373a381f41cd6ad2f inherit pub_methods_class_bufferless"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes data buffered by this object, without signal propagation.  <a href="class_bufferless.html#a872a67af13d0291373a381f41cd6ad2f">More...</a><br /></td></tr>
<tr class="separator:a872a67af13d0291373a381f41cd6ad2f inherit pub_methods_class_bufferless"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_buffered_transformation"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_buffered_transformation')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_buffered_transformation.html">BufferedTransformation</a></td></tr>
<tr class="memitem:a61bf430b7aa268991e3da82b74db1634 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top"><a id="a61bf430b7aa268991e3da82b74db1634"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a61bf430b7aa268991e3da82b74db1634">BufferedTransformation</a> ()</td></tr>
<tr class="memdesc:a61bf430b7aa268991e3da82b74db1634 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>. <br /></td></tr>
<tr class="separator:a61bf430b7aa268991e3da82b74db1634 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25686ebe4c3ba26e7eeaae1dcd4d4215 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a25686ebe4c3ba26e7eeaae1dcd4d4215">Ref</a> ()</td></tr>
<tr class="memdesc:a25686ebe4c3ba26e7eeaae1dcd4d4215 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference to this object.  <a href="class_buffered_transformation.html#a25686ebe4c3ba26e7eeaae1dcd4d4215">More...</a><br /></td></tr>
<tr class="separator:a25686ebe4c3ba26e7eeaae1dcd4d4215 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20112606fc006c56f1561653cabd9542 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a20112606fc006c56f1561653cabd9542">Attachable</a> ()</td></tr>
<tr class="memdesc:a20112606fc006c56f1561653cabd9542 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object allows attachment.  <a href="class_buffered_transformation.html#a20112606fc006c56f1561653cabd9542">More...</a><br /></td></tr>
<tr class="separator:a20112606fc006c56f1561653cabd9542 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6bbc169e26ed77a6bb5d50f91abda0 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0">AttachedTransformation</a> ()</td></tr>
<tr class="memdesc:aba6bbc169e26ed77a6bb5d50f91abda0 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object immediately attached to this object.  <a href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0">More...</a><br /></td></tr>
<tr class="separator:aba6bbc169e26ed77a6bb5d50f91abda0 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14186840b67e8ebc9c05d1eb581598d inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ab14186840b67e8ebc9c05d1eb581598d">AttachedTransformation</a> () const</td></tr>
<tr class="memdesc:ab14186840b67e8ebc9c05d1eb581598d inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object immediately attached to this object.  <a href="class_buffered_transformation.html#ab14186840b67e8ebc9c05d1eb581598d">More...</a><br /></td></tr>
<tr class="separator:ab14186840b67e8ebc9c05d1eb581598d inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b13b5279c66c59816df370df321f7 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ac90b13b5279c66c59816df370df321f7">Detach</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *newAttachment=NULL)</td></tr>
<tr class="memdesc:ac90b13b5279c66c59816df370df321f7 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the current attachment chain and attach a new one.  <a href="class_buffered_transformation.html#ac90b13b5279c66c59816df370df321f7">More...</a><br /></td></tr>
<tr class="separator:ac90b13b5279c66c59816df370df321f7 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583f6716aae8e4b6c83f43415a48befe inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a583f6716aae8e4b6c83f43415a48befe">Attach</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *newAttachment)</td></tr>
<tr class="memdesc:a583f6716aae8e4b6c83f43415a48befe inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add newAttachment to the end of attachment chain.  <a href="class_buffered_transformation.html#a583f6716aae8e4b6c83f43415a48befe">More...</a><br /></td></tr>
<tr class="separator:a583f6716aae8e4b6c83f43415a48befe inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70658b0d271f8e114ac6c3cc9774ede inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede">Put</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> inByte, bool blocking=true)</td></tr>
<tr class="memdesc:ae70658b0d271f8e114ac6c3cc9774ede inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte for processing.  <a href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede">More...</a><br /></td></tr>
<tr class="separator:ae70658b0d271f8e114ac6c3cc9774ede inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e935e60d3877975a7c82c6353d65c9 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a44e935e60d3877975a7c82c6353d65c9">Put</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:a44e935e60d3877975a7c82c6353d65c9 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte buffer for processing.  <a href="class_buffered_transformation.html#a44e935e60d3877975a7c82c6353d65c9">More...</a><br /></td></tr>
<tr class="separator:a44e935e60d3877975a7c82c6353d65c9 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c60616792d7bce5cd41eaffbd1c3cc inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a92c60616792d7bce5cd41eaffbd1c3cc">PutWord16</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a92c60616792d7bce5cd41eaffbd1c3cc inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 16-bit word for processing.  <a href="class_buffered_transformation.html#a92c60616792d7bce5cd41eaffbd1c3cc">More...</a><br /></td></tr>
<tr class="separator:a92c60616792d7bce5cd41eaffbd1c3cc inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcc574867d51528afe3c96721ded075 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#affcc574867d51528afe3c96721ded075">PutWord32</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:affcc574867d51528afe3c96721ded075 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 32-bit word for processing.  <a href="class_buffered_transformation.html#affcc574867d51528afe3c96721ded075">More...</a><br /></td></tr>
<tr class="separator:affcc574867d51528afe3c96721ded075 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6474c18e393d0d8d39aae44afd769eb7 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a6474c18e393d0d8d39aae44afd769eb7">PutWord64</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a6474c18e393d0d8d39aae44afd769eb7 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 64-bit word for processing.  <a href="class_buffered_transformation.html#a6474c18e393d0d8d39aae44afd769eb7">More...</a><br /></td></tr>
<tr class="separator:a6474c18e393d0d8d39aae44afd769eb7 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5e36148728c1db63d9d3a6f5b49d7f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aff5e36148728c1db63d9d3a6f5b49d7f">CanModifyInput</a> () const</td></tr>
<tr class="memdesc:aff5e36148728c1db63d9d3a6f5b49d7f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether input can be modified by the callee.  <a href="class_buffered_transformation.html#aff5e36148728c1db63d9d3a6f5b49d7f">More...</a><br /></td></tr>
<tr class="separator:aff5e36148728c1db63d9d3a6f5b49d7f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15df84a7b67c25dfe2ce0ef5a74123c inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae15df84a7b67c25dfe2ce0ef5a74123c">PutModifiable</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:ae15df84a7b67c25dfe2ce0ef5a74123c inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee.  <a href="class_buffered_transformation.html#ae15df84a7b67c25dfe2ce0ef5a74123c">More...</a><br /></td></tr>
<tr class="separator:ae15df84a7b67c25dfe2ce0ef5a74123c inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ae0ef2e4ff338b43849e541e9b940f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f">MessageEnd</a> (int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:a20ae0ef2e4ff338b43849e541e9b940f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the end of messages to the object.  <a href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f">More...</a><br /></td></tr>
<tr class="separator:a20ae0ef2e4ff338b43849e541e9b940f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10b7e626f5af900a4d12f6e5d125891 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aa10b7e626f5af900a4d12f6e5d125891">PutMessageEnd</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:aa10b7e626f5af900a4d12f6e5d125891 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing and signal the end of a message.  <a href="class_buffered_transformation.html#aa10b7e626f5af900a4d12f6e5d125891">More...</a><br /></td></tr>
<tr class="separator:aa10b7e626f5af900a4d12f6e5d125891 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770bf11f26d4dec66423a7dc2d36843d inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a770bf11f26d4dec66423a7dc2d36843d">PutModifiable2</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, int messageEnd, bool blocking)</td></tr>
<tr class="memdesc:a770bf11f26d4dec66423a7dc2d36843d inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee.  <a href="class_buffered_transformation.html#a770bf11f26d4dec66423a7dc2d36843d">More...</a><br /></td></tr>
<tr class="separator:a770bf11f26d4dec66423a7dc2d36843d inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a0b5e3e4cc81aca43a9c6cb02e0f9 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top"><a id="a051a0b5e3e4cc81aca43a9c6cb02e0f9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a051a0b5e3e4cc81aca43a9c6cb02e0f9">GetMaxWaitObjectCount</a> () const</td></tr>
<tr class="memdesc:a051a0b5e3e4cc81aca43a9c6cb02e0f9 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum number of waitable objects. <br /></td></tr>
<tr class="separator:a051a0b5e3e4cc81aca43a9c6cb02e0f9 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127ccd1793fdda6548cd1295f848d0f7 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a127ccd1793fdda6548cd1295f848d0f7">GetWaitObjects</a> (WaitObjectContainer &amp;container, CallStack const &amp;callStack)</td></tr>
<tr class="memdesc:a127ccd1793fdda6548cd1295f848d0f7 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves waitable objects.  <a href="class_buffered_transformation.html#a127ccd1793fdda6548cd1295f848d0f7">More...</a><br /></td></tr>
<tr class="separator:a127ccd1793fdda6548cd1295f848d0f7 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf09f0cd6dbd022539a9ac5c316d4984 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aaf09f0cd6dbd022539a9ac5c316d4984">IsolatedMessageSeriesEnd</a> (bool blocking)</td></tr>
<tr class="memdesc:aaf09f0cd6dbd022539a9ac5c316d4984 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the end of a series of messages, without signal propagation.  <a href="class_buffered_transformation.html#aaf09f0cd6dbd022539a9ac5c316d4984">More...</a><br /></td></tr>
<tr class="separator:aaf09f0cd6dbd022539a9ac5c316d4984 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102734fc6fd234382ef601f4b5221aff inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a102734fc6fd234382ef601f4b5221aff">Initialize</a> (const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;parameters=<a class="el" href="cryptlib_8h.html#aa9048ef24353685fd0dcc4180c6884c2">g_nullNameValuePairs</a>, int propagation=-1)</td></tr>
<tr class="memdesc:a102734fc6fd234382ef601f4b5221aff inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize this object, with signal propagation.  <a href="class_buffered_transformation.html#a102734fc6fd234382ef601f4b5221aff">More...</a><br /></td></tr>
<tr class="separator:a102734fc6fd234382ef601f4b5221aff inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c7f9508d50155d9e75c295b8bc5743 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ac6c7f9508d50155d9e75c295b8bc5743">Flush</a> (bool hardFlush, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:ac6c7f9508d50155d9e75c295b8bc5743 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush buffered input and/or output, with signal propagation.  <a href="class_buffered_transformation.html#ac6c7f9508d50155d9e75c295b8bc5743">More...</a><br /></td></tr>
<tr class="separator:ac6c7f9508d50155d9e75c295b8bc5743 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9abc61e1cc6c8541a5657e68df1f36 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a9c9abc61e1cc6c8541a5657e68df1f36">MessageSeriesEnd</a> (int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:a9c9abc61e1cc6c8541a5657e68df1f36 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the end of a series of messages, with signal propagation.  <a href="class_buffered_transformation.html#a9c9abc61e1cc6c8541a5657e68df1f36">More...</a><br /></td></tr>
<tr class="separator:a9c9abc61e1cc6c8541a5657e68df1f36 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77dc2fddb3ff142effb00eff3217581 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae77dc2fddb3ff142effb00eff3217581">SetAutoSignalPropagation</a> (int propagation)</td></tr>
<tr class="memdesc:ae77dc2fddb3ff142effb00eff3217581 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set propagation of automatically generated and transferred signals.  <a href="class_buffered_transformation.html#ae77dc2fddb3ff142effb00eff3217581">More...</a><br /></td></tr>
<tr class="separator:ae77dc2fddb3ff142effb00eff3217581 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a32fc46e74c3c509934a11b8f5fec7 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a76a32fc46e74c3c509934a11b8f5fec7">GetAutoSignalPropagation</a> () const</td></tr>
<tr class="memdesc:a76a32fc46e74c3c509934a11b8f5fec7 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve automatic signal propagation value.  <a href="class_buffered_transformation.html#a76a32fc46e74c3c509934a11b8f5fec7">More...</a><br /></td></tr>
<tr class="separator:a76a32fc46e74c3c509934a11b8f5fec7 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac50bcb2d279c3c6aef6858dab3eeb7 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7">GetWord16</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a1ac50bcb2d279c3c6aef6858dab3eeb7 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 16-bit word.  <a href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7">More...</a><br /></td></tr>
<tr class="separator:a1ac50bcb2d279c3c6aef6858dab3eeb7 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c064d931db3a8631c1138827d67e2f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a69c064d931db3a8631c1138827d67e2f">GetWord32</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a69c064d931db3a8631c1138827d67e2f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 32-bit word.  <a href="class_buffered_transformation.html#a69c064d931db3a8631c1138827d67e2f">More...</a><br /></td></tr>
<tr class="separator:a69c064d931db3a8631c1138827d67e2f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6cdaa6febff9aebbfa2511781ed63c inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#adb6cdaa6febff9aebbfa2511781ed63c">GetWord64</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:adb6cdaa6febff9aebbfa2511781ed63c inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 64-bit word.  <a href="class_buffered_transformation.html#adb6cdaa6febff9aebbfa2511781ed63c">More...</a><br /></td></tr>
<tr class="separator:adb6cdaa6febff9aebbfa2511781ed63c inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6cc9f7a38884cde234f3367df62b6 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a57f6cc9f7a38884cde234f3367df62b6">PeekWord16</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>) const</td></tr>
<tr class="memdesc:a57f6cc9f7a38884cde234f3367df62b6 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a 16-bit word.  <a href="class_buffered_transformation.html#a57f6cc9f7a38884cde234f3367df62b6">More...</a><br /></td></tr>
<tr class="separator:a57f6cc9f7a38884cde234f3367df62b6 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bfe64be6bc1b65d84e3408e510b25a inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a62bfe64be6bc1b65d84e3408e510b25a">PeekWord32</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>) const</td></tr>
<tr class="memdesc:a62bfe64be6bc1b65d84e3408e510b25a inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a 32-bit word.  <a href="class_buffered_transformation.html#a62bfe64be6bc1b65d84e3408e510b25a">More...</a><br /></td></tr>
<tr class="separator:a62bfe64be6bc1b65d84e3408e510b25a inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b21ba2bf5fd3574d756223bd8ed1e4 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae6b21ba2bf5fd3574d756223bd8ed1e4">PeekWord64</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>) const</td></tr>
<tr class="memdesc:ae6b21ba2bf5fd3574d756223bd8ed1e4 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a 64-bit word.  <a href="class_buffered_transformation.html#ae6b21ba2bf5fd3574d756223bd8ed1e4">More...</a><br /></td></tr>
<tr class="separator:ae6b21ba2bf5fd3574d756223bd8ed1e4 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31ac5d2da7897fb097086496b85e6f5 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ac31ac5d2da7897fb097086496b85e6f5">TransferTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> transferMax=<a class="el" href="config__int_8h.html#a2e8f5e8729bf2ba8a903917e639ec16a">LWORD_MAX</a>, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>)</td></tr>
<tr class="memdesc:ac31ac5d2da7897fb097086496b85e6f5 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">move transferMax bytes of the buffered output to target as input  <a href="class_buffered_transformation.html#ac31ac5d2da7897fb097086496b85e6f5">More...</a><br /></td></tr>
<tr class="separator:ac31ac5d2da7897fb097086496b85e6f5 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb0dc3afe27a96e3320c1d65a2007d3 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aeeb0dc3afe27a96e3320c1d65a2007d3">Skip</a> (<a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> skipMax=<a class="el" href="config__int_8h.html#a2e8f5e8729bf2ba8a903917e639ec16a">LWORD_MAX</a>)</td></tr>
<tr class="memdesc:aeeb0dc3afe27a96e3320c1d65a2007d3 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard skipMax bytes from the output buffer.  <a href="class_buffered_transformation.html#aeeb0dc3afe27a96e3320c1d65a2007d3">More...</a><br /></td></tr>
<tr class="separator:aeeb0dc3afe27a96e3320c1d65a2007d3 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7693f056b01bc4feadd8a794fba2d30a inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a7693f056b01bc4feadd8a794fba2d30a">CopyTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> copyMax=<a class="el" href="config__int_8h.html#a2e8f5e8729bf2ba8a903917e639ec16a">LWORD_MAX</a>, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a7693f056b01bc4feadd8a794fba2d30a inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a7693f056b01bc4feadd8a794fba2d30a">More...</a><br /></td></tr>
<tr class="separator:a7693f056b01bc4feadd8a794fba2d30a inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac245e7a90e75e51482ce4421969616 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a7ac245e7a90e75e51482ce4421969616">CopyRangeTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> position, <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> copyMax=<a class="el" href="config__int_8h.html#a2e8f5e8729bf2ba8a903917e639ec16a">LWORD_MAX</a>, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a7ac245e7a90e75e51482ce4421969616 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes from this object using an index to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a7ac245e7a90e75e51482ce4421969616">More...</a><br /></td></tr>
<tr class="separator:a7ac245e7a90e75e51482ce4421969616 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadeaadba10b41b815b7638569deed57 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#acadeaadba10b41b815b7638569deed57">TotalBytesRetrievable</a> () const</td></tr>
<tr class="memdesc:acadeaadba10b41b815b7638569deed57 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of bytes ready for retrieval.  <a href="class_buffered_transformation.html#acadeaadba10b41b815b7638569deed57">More...</a><br /></td></tr>
<tr class="separator:acadeaadba10b41b815b7638569deed57 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206be3970d7a488c2872e7e68147f36f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a206be3970d7a488c2872e7e68147f36f">NumberOfMessages</a> () const</td></tr>
<tr class="memdesc:a206be3970d7a488c2872e7e68147f36f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of meesages processed by this object.  <a href="class_buffered_transformation.html#a206be3970d7a488c2872e7e68147f36f">More...</a><br /></td></tr>
<tr class="separator:a206be3970d7a488c2872e7e68147f36f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04270a653e30177b7118040cf11c965c inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a04270a653e30177b7118040cf11c965c">AnyMessages</a> () const</td></tr>
<tr class="memdesc:a04270a653e30177b7118040cf11c965c inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if any messages are available for retrieval.  <a href="class_buffered_transformation.html#a04270a653e30177b7118040cf11c965c">More...</a><br /></td></tr>
<tr class="separator:a04270a653e30177b7118040cf11c965c inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7adffcae350fe528520a2427b21c0a9 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aa7adffcae350fe528520a2427b21c0a9">GetNextMessage</a> ()</td></tr>
<tr class="memdesc:aa7adffcae350fe528520a2427b21c0a9 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start retrieving the next message.  <a href="class_buffered_transformation.html#aa7adffcae350fe528520a2427b21c0a9">More...</a><br /></td></tr>
<tr class="separator:aa7adffcae350fe528520a2427b21c0a9 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129710fdfddb97b7ddb51010d0c7c535 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a129710fdfddb97b7ddb51010d0c7c535">SkipMessages</a> (unsigned int count=UINT_MAX)</td></tr>
<tr class="memdesc:a129710fdfddb97b7ddb51010d0c7c535 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip a number of meessages.  <a href="class_buffered_transformation.html#a129710fdfddb97b7ddb51010d0c7c535">More...</a><br /></td></tr>
<tr class="separator:a129710fdfddb97b7ddb51010d0c7c535 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0446d21781676a6f9c64d0b7a727d314 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a0446d21781676a6f9c64d0b7a727d314">TransferMessagesTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, unsigned int count=UINT_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>)</td></tr>
<tr class="memdesc:a0446d21781676a6f9c64d0b7a727d314 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a0446d21781676a6f9c64d0b7a727d314">More...</a><br /></td></tr>
<tr class="separator:a0446d21781676a6f9c64d0b7a727d314 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b2099b75141367e96ce60c6eb939f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a2d4b2099b75141367e96ce60c6eb939f">CopyMessagesTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, unsigned int count=UINT_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a2d4b2099b75141367e96ce60c6eb939f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a2d4b2099b75141367e96ce60c6eb939f">More...</a><br /></td></tr>
<tr class="separator:a2d4b2099b75141367e96ce60c6eb939f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb3f0946a407461ce0c9fc08d13ca00 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top"><a id="a8cb3f0946a407461ce0c9fc08d13ca00"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a8cb3f0946a407461ce0c9fc08d13ca00">SkipAll</a> ()</td></tr>
<tr class="memdesc:a8cb3f0946a407461ce0c9fc08d13ca00 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip all messages in the series. <br /></td></tr>
<tr class="separator:a8cb3f0946a407461ce0c9fc08d13ca00 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c3629cdd9be90695c9701c1b8e24a2 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a84c3629cdd9be90695c9701c1b8e24a2">TransferAllTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>)</td></tr>
<tr class="memdesc:a84c3629cdd9be90695c9701c1b8e24a2 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer all bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a84c3629cdd9be90695c9701c1b8e24a2">More...</a><br /></td></tr>
<tr class="separator:a84c3629cdd9be90695c9701c1b8e24a2 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18893c1bd5eee9263022f72d4ac992ad inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a18893c1bd5eee9263022f72d4ac992ad">CopyAllTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a18893c1bd5eee9263022f72d4ac992ad inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a18893c1bd5eee9263022f72d4ac992ad">More...</a><br /></td></tr>
<tr class="separator:a18893c1bd5eee9263022f72d4ac992ad inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36a158b63cfd54acbada1a3699598c inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aeb36a158b63cfd54acbada1a3699598c">GetNextMessageSeries</a> ()</td></tr>
<tr class="memdesc:aeb36a158b63cfd54acbada1a3699598c inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next message in a series.  <a href="class_buffered_transformation.html#aeb36a158b63cfd54acbada1a3699598c">More...</a><br /></td></tr>
<tr class="separator:aeb36a158b63cfd54acbada1a3699598c inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced989ed6c34a7e91c725df5daffcf57 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aced989ed6c34a7e91c725df5daffcf57">NumberOfMessagesInThisSeries</a> () const</td></tr>
<tr class="memdesc:aced989ed6c34a7e91c725df5daffcf57 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of messages in a series.  <a href="class_buffered_transformation.html#aced989ed6c34a7e91c725df5daffcf57">More...</a><br /></td></tr>
<tr class="separator:aced989ed6c34a7e91c725df5daffcf57 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b83d07c4e05a86e054fbaa32e50468 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ad1b83d07c4e05a86e054fbaa32e50468">NumberOfMessageSeries</a> () const</td></tr>
<tr class="memdesc:ad1b83d07c4e05a86e054fbaa32e50468 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of messages in a series.  <a href="class_buffered_transformation.html#ad1b83d07c4e05a86e054fbaa32e50468">More...</a><br /></td></tr>
<tr class="separator:ad1b83d07c4e05a86e054fbaa32e50468 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70058989762156c376d7ffa5cb303e inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e">TransferMessagesTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, unsigned int &amp;messageCount, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a1a70058989762156c376d7ffa5cb303e inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e">More...</a><br /></td></tr>
<tr class="separator:a1a70058989762156c376d7ffa5cb303e inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e47718aa65674256e1b069ec8e706b7 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a3e47718aa65674256e1b069ec8e706b7">TransferAllTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a3e47718aa65674256e1b069ec8e706b7 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer all bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>.  <a href="class_buffered_transformation.html#a3e47718aa65674256e1b069ec8e706b7">More...</a><br /></td></tr>
<tr class="separator:a3e47718aa65674256e1b069ec8e706b7 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a60b54fafdb3df59e1457ef629fc5f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a97a60b54fafdb3df59e1457ef629fc5f">ChannelPut</a> (const std::string &amp;channel, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> inByte, bool blocking=true)</td></tr>
<tr class="memdesc:a97a60b54fafdb3df59e1457ef629fc5f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte for processing on a channel.  <a href="class_buffered_transformation.html#a97a60b54fafdb3df59e1457ef629fc5f">More...</a><br /></td></tr>
<tr class="separator:a97a60b54fafdb3df59e1457ef629fc5f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7fcb31b4cb09d38242354fcbc4b45c inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a5b7fcb31b4cb09d38242354fcbc4b45c">ChannelPut</a> (const std::string &amp;channel, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:a5b7fcb31b4cb09d38242354fcbc4b45c inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte buffer for processing on a channel.  <a href="class_buffered_transformation.html#a5b7fcb31b4cb09d38242354fcbc4b45c">More...</a><br /></td></tr>
<tr class="separator:a5b7fcb31b4cb09d38242354fcbc4b45c inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc27692b14108ed057beb4db67fed2f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a3dc27692b14108ed057beb4db67fed2f">ChannelPutModifiable</a> (const std::string &amp;channel, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:a3dc27692b14108ed057beb4db67fed2f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee on a channel.  <a href="class_buffered_transformation.html#a3dc27692b14108ed057beb4db67fed2f">More...</a><br /></td></tr>
<tr class="separator:a3dc27692b14108ed057beb4db67fed2f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bca66c16e0e52793059b41353964bd inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aa1bca66c16e0e52793059b41353964bd">ChannelPutWord16</a> (const std::string &amp;channel, <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:aa1bca66c16e0e52793059b41353964bd inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 16-bit word for processing on a channel.  <a href="class_buffered_transformation.html#aa1bca66c16e0e52793059b41353964bd">More...</a><br /></td></tr>
<tr class="separator:aa1bca66c16e0e52793059b41353964bd inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06216012d6c40609db092952afcf3f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#acb06216012d6c40609db092952afcf3f">ChannelPutWord32</a> (const std::string &amp;channel, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:acb06216012d6c40609db092952afcf3f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 32-bit word for processing on a channel.  <a href="class_buffered_transformation.html#acb06216012d6c40609db092952afcf3f">More...</a><br /></td></tr>
<tr class="separator:acb06216012d6c40609db092952afcf3f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca29f6c0d151ca81f061509cb4394b inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a0cca29f6c0d151ca81f061509cb4394b">ChannelPutWord64</a> (const std::string &amp;channel, <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a0cca29f6c0d151ca81f061509cb4394b inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 64-bit word for processing on a channel.  <a href="class_buffered_transformation.html#a0cca29f6c0d151ca81f061509cb4394b">More...</a><br /></td></tr>
<tr class="separator:a0cca29f6c0d151ca81f061509cb4394b inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b37b299c5835083e58b205f9cc25cc inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae0b37b299c5835083e58b205f9cc25cc">ChannelMessageEnd</a> (const std::string &amp;channel, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:ae0b37b299c5835083e58b205f9cc25cc inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal the end of a message.  <a href="class_buffered_transformation.html#ae0b37b299c5835083e58b205f9cc25cc">More...</a><br /></td></tr>
<tr class="separator:ae0b37b299c5835083e58b205f9cc25cc inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e9efe4c59093c330d287140fcfbdd9 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ad3e9efe4c59093c330d287140fcfbdd9">ChannelPutMessageEnd</a> (const std::string &amp;channel, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:ad3e9efe4c59093c330d287140fcfbdd9 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing and signal the end of a message.  <a href="class_buffered_transformation.html#ad3e9efe4c59093c330d287140fcfbdd9">More...</a><br /></td></tr>
<tr class="separator:ad3e9efe4c59093c330d287140fcfbdd9 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834053258b6a6e0e5c0a597dc259f42d inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a834053258b6a6e0e5c0a597dc259f42d">ChannelCreatePutSpace</a> (const std::string &amp;channel, size_t &amp;size)</td></tr>
<tr class="memdesc:a834053258b6a6e0e5c0a597dc259f42d inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request space which can be written into by the caller.  <a href="class_buffered_transformation.html#a834053258b6a6e0e5c0a597dc259f42d">More...</a><br /></td></tr>
<tr class="separator:a834053258b6a6e0e5c0a597dc259f42d inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae8b3fb47faf29be63294bd92959328 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a8ae8b3fb47faf29be63294bd92959328">ChannelPut2</a> (const std::string &amp;channel, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, int messageEnd, bool blocking)</td></tr>
<tr class="memdesc:a8ae8b3fb47faf29be63294bd92959328 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing on a channel.  <a href="class_buffered_transformation.html#a8ae8b3fb47faf29be63294bd92959328">More...</a><br /></td></tr>
<tr class="separator:a8ae8b3fb47faf29be63294bd92959328 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672e05b16036666e1fa40d5fb00e6651 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a672e05b16036666e1fa40d5fb00e6651">ChannelPutModifiable2</a> (const std::string &amp;channel, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inString, size_t length, int messageEnd, bool blocking)</td></tr>
<tr class="memdesc:a672e05b16036666e1fa40d5fb00e6651 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee on a channel.  <a href="class_buffered_transformation.html#a672e05b16036666e1fa40d5fb00e6651">More...</a><br /></td></tr>
<tr class="separator:a672e05b16036666e1fa40d5fb00e6651 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e324c1d04716307b5dd0a6ead58f0f inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a29e324c1d04716307b5dd0a6ead58f0f">ChannelFlush</a> (const std::string &amp;channel, bool hardFlush, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:a29e324c1d04716307b5dd0a6ead58f0f inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush buffered input and/or output on a channel.  <a href="class_buffered_transformation.html#a29e324c1d04716307b5dd0a6ead58f0f">More...</a><br /></td></tr>
<tr class="separator:a29e324c1d04716307b5dd0a6ead58f0f inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab2b9aa582c7e7974d15beb05df22af inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#acab2b9aa582c7e7974d15beb05df22af">ChannelMessageSeriesEnd</a> (const std::string &amp;channel, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:acab2b9aa582c7e7974d15beb05df22af inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the end of a series of messages on a channel.  <a href="class_buffered_transformation.html#acab2b9aa582c7e7974d15beb05df22af">More...</a><br /></td></tr>
<tr class="separator:acab2b9aa582c7e7974d15beb05df22af inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c0fc64ae71ed6e9915682b67c663f9 inherit pub_methods_class_buffered_transformation"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a28c0fc64ae71ed6e9915682b67c663f9">SetRetrievalChannel</a> (const std::string &amp;channel)</td></tr>
<tr class="memdesc:a28c0fc64ae71ed6e9915682b67c663f9 inherit pub_methods_class_buffered_transformation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default retrieval channel.  <a href="class_buffered_transformation.html#a28c0fc64ae71ed6e9915682b67c663f9">More...</a><br /></td></tr>
<tr class="separator:a28c0fc64ae71ed6e9915682b67c663f9 inherit pub_methods_class_buffered_transformation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_algorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_algorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_algorithm.html">Algorithm</a></td></tr>
<tr class="memitem:a1c77f5117ca2cd881baf26a364cfc606 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a1c77f5117ca2cd881baf26a364cfc606">Algorithm</a> (bool checkSelfTestStatus=true)</td></tr>
<tr class="memdesc:a1c77f5117ca2cd881baf26a364cfc606 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all crypto algorithms.  <a href="class_algorithm.html#a1c77f5117ca2cd881baf26a364cfc606">More...</a><br /></td></tr>
<tr class="separator:a1c77f5117ca2cd881baf26a364cfc606 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f31510a192d1121856efe8ad0a9b844 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a4f31510a192d1121856efe8ad0a9b844">AlgorithmName</a> () const</td></tr>
<tr class="memdesc:a4f31510a192d1121856efe8ad0a9b844 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the name of this algorithm.  <a href="class_algorithm.html#a4f31510a192d1121856efe8ad0a9b844">More...</a><br /></td></tr>
<tr class="separator:a4f31510a192d1121856efe8ad0a9b844 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae964330190fbeb13502f9dc1585a0fc0 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#ae964330190fbeb13502f9dc1585a0fc0">AlgorithmProvider</a> () const</td></tr>
<tr class="memdesc:ae964330190fbeb13502f9dc1585a0fc0 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the provider of this algorithm.  <a href="class_algorithm.html#ae964330190fbeb13502f9dc1585a0fc0">More...</a><br /></td></tr>
<tr class="separator:ae964330190fbeb13502f9dc1585a0fc0 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_clonable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_clonable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_clonable.html">Clonable</a></td></tr>
<tr class="memitem:ad0016ba2d505c23aa85aad49e6c19bb7 inherit pub_methods_class_clonable"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_clonable.html">Clonable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_clonable.html#ad0016ba2d505c23aa85aad49e6c19bb7">Clone</a> () const</td></tr>
<tr class="memdesc:ad0016ba2d505c23aa85aad49e6c19bb7 inherit pub_methods_class_clonable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this object.  <a href="class_clonable.html#ad0016ba2d505c23aa85aad49e6c19bb7">More...</a><br /></td></tr>
<tr class="separator:ad0016ba2d505c23aa85aad49e6c19bb7 inherit pub_methods_class_clonable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_waitable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_waitable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_waitable.html">Waitable</a></td></tr>
<tr class="memitem:aded81bbe562f61932306a64e6122a6ca inherit pub_methods_class_waitable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_waitable.html#aded81bbe562f61932306a64e6122a6ca">Wait</a> (unsigned long milliseconds, CallStack const &amp;callStack)</td></tr>
<tr class="memdesc:aded81bbe562f61932306a64e6122a6ca inherit pub_methods_class_waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on this object.  <a href="class_waitable.html#aded81bbe562f61932306a64e6122a6ca">More...</a><br /></td></tr>
<tr class="separator:aded81bbe562f61932306a64e6122a6ca inherit pub_methods_class_waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a561951adc2bae72717df4b975c66f02f"><td class="memItemLeft" align="right" valign="top"><a id="a561951adc2bae72717df4b975c66f02f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Walker</b></td></tr>
<tr class="separator:a561951adc2bae72717df4b975c66f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data structure used to store byte strings. </p>
<p>The queue is implemented as a linked list of byte arrays. Each byte array is stored in a ByteQueueNode. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.cryptopp.com/wiki/ByteQueue">ByteQueue</a> on the Crypto++ wiki. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8h_source.html#l00022">22</a> of file <a class="el" href="queue_8h_source.html">queue.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c8239764938f1bb776280695e62fa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8239764938f1bb776280695e62fa0d">&#9670;&nbsp;</a></span>ByteQueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ByteQueue::ByteQueue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeSize</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSize</td><td>the initial node size</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> uses a ByteQueueNode to store bytes, and <code>nodeSize</code> determines the size of the ByteQueueNode. A value of 0 indicates the ByteQueueNode should be automatically sized, which means a value of 256 is used. </p>

</div>
</div>
<a id="a0e3ec54d26a5be3b5689ca53a906622f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3ec54d26a5be3b5689ca53a906622f">&#9670;&nbsp;</a></span>ByteQueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ByteQueue::ByteQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy construct a <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the other <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad7436088ce8a852e9e95d291590a9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7436088ce8a852e9e95d291590a9f9">&#9670;&nbsp;</a></span>MaxRetrievable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> ByteQueue::MaxRetrievable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the number of bytes ready for retrieval. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes ready for retrieval</dd></dl>
<p>The number of bytes available are dependent on the source. If an exact value is available, then the exact value is returned. The exact value can include 0 if the source is exhausted.</p>
<p>Some stream-based sources do not allow seeking() on the underlying stream, such as some <a class="el" href="class_file_source.html" title="Implementation of Store interface.">FileSource()</a>. If the stream does not allow seeking() then <a class="el" href="class_byte_queue.html#aad7436088ce8a852e9e95d291590a9f9" title="Provides the number of bytes ready for retrieval.">MaxRetrievable()</a> returns LWORD_MAX to indicate there are still bytes to be retrieved. </p>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#affbfd0682960d7b402c6e3598e597ce9">BufferedTransformation</a>.</p>

<p class="definition">Definition at line <a class="el" href="queue_8h_source.html#l00040">40</a> of file <a class="el" href="queue_8h_source.html">queue.h</a>.</p>

</div>
</div>
<a id="ae0d701bf528a1131917b77c0bb3fb369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d701bf528a1131917b77c0bb3fb369">&#9670;&nbsp;</a></span>AnyRetrievable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ByteQueue::AnyRetrievable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether bytes are ready for retrieval. </p>
<dl class="section return"><dt>Returns</dt><dd>true if bytes are available for retrieval, false otherwise </dd></dl>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#a00a39d5d6edff35e6b935c7fa148ed7a">BufferedTransformation</a>.</p>

<p class="definition">Definition at line <a class="el" href="queue_8h_source.html#l00042">42</a> of file <a class="el" href="queue_8h_source.html">queue.h</a>.</p>

</div>
</div>
<a id="a7e576bc7629bd0947eb098ad23b0d675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e576bc7629bd0947eb098ad23b0d675">&#9670;&nbsp;</a></span>IsolatedInitialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::IsolatedInitialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize this object, without signal propagation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>a set of <a class="el" href="class_name_value_pairs.html" title="Interface for retrieving values given their names.">NameValuePairs</a> to initialize this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_not_implemented.html" title="A method was called which was not implemented.">NotImplemented</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_byte_queue.html#a7e576bc7629bd0947eb098ad23b0d675" title="Initialize or reinitialize this object, without signal propagation.">IsolatedInitialize()</a> is used to initialize or reinitialize an object using a variable number of arbitrarily typed arguments. The function avoids the need for multiple constructors providing all possible combintations of configurable parameters.</p>
<p><a class="el" href="class_byte_queue.html#a7e576bc7629bd0947eb098ad23b0d675" title="Initialize or reinitialize this object, without signal propagation.">IsolatedInitialize()</a> does not call <a class="el" href="class_buffered_transformation.html#a102734fc6fd234382ef601f4b5221aff" title="Initialize or reinitialize this object, with signal propagation.">Initialize()</a> on attached transformations. If initialization should be propagated, then use the <a class="el" href="class_buffered_transformation.html#a102734fc6fd234382ef601f4b5221aff" title="Initialize or reinitialize this object, with signal propagation.">Initialize()</a> function.</p>
<p>If a derived class does not override <a class="el" href="class_byte_queue.html#a7e576bc7629bd0947eb098ad23b0d675" title="Initialize or reinitialize this object, without signal propagation.">IsolatedInitialize()</a>, then the base class throws <a class="el" href="class_not_implemented.html" title="A method was called which was not implemented.">NotImplemented</a>. </p>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#a7bb05ac3b6302e2ab994586d526fa804">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a144c8bb417fc6c9631ae979ce7b7d52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c8bb417fc6c9631ae979ce7b7d52a">&#9670;&nbsp;</a></span>CreatePutSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* ByteQueue::CreatePutSpace </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request space which can be written into by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the requested size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte pointer to the space to input data</dd></dl>
<p>The purpose of this method is to help avoid extra memory allocations.</p>
<p>size is an <em>IN</em> and <em>OUT</em> parameter and used as a hint. When the call is made, size is the requested size of the buffer. When the call returns, size is the size of the array returned to the caller.</p>
<p>The base class implementation sets size to 0 and returns NULL. </p><dl class="section note"><dt>Note</dt><dd>Some objects, like <a class="el" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a>, cannot create a space because its fixed. In the case of an <a class="el" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a>, the pointer to the array is returned and the size is remaining size. </dd></dl>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#af390325c959c3d6a2c03a447d6cd469d">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a684942d5641278a78e7c237a5bd4c69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684942d5641278a78e7c237a5bd4c69d">&#9670;&nbsp;</a></span>Put2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteQueue::Put2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>messageEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">messageEnd</td><td>means how many filters to signal <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object.">MessageEnd()</a> to, including this one </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain to be processed (i.e., bytes not processed). 0 indicates all bytes were processed.</dd></dl>
<p>Derived classes must implement <a class="el" href="class_byte_queue.html#a684942d5641278a78e7c237a5bd4c69d" title="Input multiple bytes for processing.">Put2()</a>. </p>

<p>Implements <a class="el" href="class_buffered_transformation.html#ad396dcb42260f23125a35ec0e5d17d55">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a19413e3aa72b749e3771d617e8eca632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19413e3aa72b749e3771d617e8eca632">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteQueue::Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> &amp;&#160;</td>
          <td class="paramname"><em>outByte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a 8-bit byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outByte</td><td>the 8-bit value to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Use the return value of Get to detect short reads. </p>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#a198583ededc5f4316e1a8617a5d2a51b">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a933457ad0a5a34fb5e7dc71b2a92c3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933457ad0a5a34fb5e7dc71b2a92c3a7">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteQueue::Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>outString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>getMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outString</td><td>a block of bytes </td></tr>
    <tr><td class="paramname">getMax</td><td>the number of bytes to Get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Use the return value of Get to detect short reads. </p>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#af1fa12ea7fa17445e2d367f3fc2b2152">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a41550f99083f9eff6a30ac2ad604f3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41550f99083f9eff6a30ac2ad604f3ce">&#9670;&nbsp;</a></span>Peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteQueue::Peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> &amp;&#160;</td>
          <td class="paramname"><em>outByte</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek a 8-bit byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outByte</td><td>the 8-bit value to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read during the call.</dd></dl>
<p>Peek does not remove bytes from the object. Use the return value of <a class="el" href="class_byte_queue.html#a19413e3aa72b749e3771d617e8eca632" title="Retrieve a 8-bit byte.">Get()</a> to detect short reads. </p>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#a3c841755f1b9304fbc8f7d56471fd288">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a6e15989ef3b2f97963df4d3b471bfdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15989ef3b2f97963df4d3b471bfdc6">&#9670;&nbsp;</a></span>Peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteQueue::Peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>outString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>peekMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outString</td><td>a block of bytes </td></tr>
    <tr><td class="paramname">peekMax</td><td>the number of bytes to Peek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read during the call.</dd></dl>
<p>Peek does not remove bytes from the object. Use the return value of <a class="el" href="class_byte_queue.html#a41550f99083f9eff6a30ac2ad604f3ce" title="Peek a 8-bit byte.">Peek()</a> to detect short reads. </p>

<p>Reimplemented from <a class="el" href="class_buffered_transformation.html#a0687a11b2d558b8046800a40e99169fa">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a9863db3b56bf42fb424f426afb7531cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9863db3b56bf42fb424f426afb7531cd">&#9670;&nbsp;</a></span>TransferTo2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteQueue::TransferTo2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> &amp;&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">byteCount</td><td>the number of bytes to transfer </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the transfer block (i.e., bytes not transferred)</dd></dl>
<p><a class="el" href="class_byte_queue.html#a9863db3b56bf42fb424f426afb7531cd" title="Transfer bytes from this object to another BufferedTransformation.">TransferTo2()</a> removes bytes from this object and moves them to the destination. Transfer begins at the index position in the current stream, and not from an absolute position in the stream.</p>
<p>byteCount is an <em>IN</em> and <em>OUT</em> parameter. When the call is made, byteCount is the requested size of the transfer. When the call returns, byteCount is the number of bytes that were transferred. </p>

<p>Implements <a class="el" href="class_buffered_transformation.html#a27ac15af3ef43c5ad1e9db5812025fcd">BufferedTransformation</a>.</p>

</div>
</div>
<a id="aeb91427c87efe486fcacb5aa726ef6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb91427c87efe486fcacb5aa726ef6ed">&#9670;&nbsp;</a></span>CopyRangeTo2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteQueue::CopyRangeTo2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td>
          <td class="paramname"><em>end</em> = <code><a class="el" href="config__int_8h.html#a2e8f5e8729bf2ba8a903917e639ec16a">LWORD_MAX</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">DEFAULT_CHANNEL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations.">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">begin</td><td>the 0-based index of the first byte to copy in the stream </td></tr>
    <tr><td class="paramname">end</td><td>the 0-based index of the last byte to copy in the stream </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the copy block (i.e., bytes not copied)</dd></dl>
<p>CopyRangeTo2 copies bytes from this object to the destination. The bytes are not removed from this object. Copying begins at the index position in the current stream, and not from an absolute position in the stream.</p>
<p>begin is an <em>IN</em> and <em>OUT</em> parameter. When the call is made, begin is the starting position of the copy. When the call returns, begin is the position of the first byte that was <em>not</em> copied (which may be different than end). begin can be used for subsequent calls to <a class="el" href="class_byte_queue.html#aeb91427c87efe486fcacb5aa726ef6ed" title="Copy bytes from this object to another BufferedTransformation.">CopyRangeTo2()</a>. </p>

<p>Implements <a class="el" href="class_buffered_transformation.html#a7f90ef36f633c97c1ae519b800527d8e">BufferedTransformation</a>.</p>

</div>
</div>
<a id="a2e4f3d3759cf2ce54cbd1a193b1cefb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4f3d3759cf2ce54cbd1a193b1cefb6">&#9670;&nbsp;</a></span>SetNodeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::SetNodeSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set node size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSize</td><td>the new node size, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The default node size is 256. </p>

</div>
</div>
<a id="a003ce4b0f9525589327800d0a14b455f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003ce4b0f9525589327800d0a14b455f">&#9670;&nbsp;</a></span>CurrentSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a> ByteQueue::CurrentSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine data size. </p>
<dl class="section return"><dt>Returns</dt><dd>the data size, in bytes </dd></dl>

</div>
</div>
<a id="ac218d4b07fe058306a00475222869aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac218d4b07fe058306a00475222869aaa">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ByteQueue::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine data availability. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> has data, false otherwise </dd></dl>

</div>
</div>
<a id="abdc94324169d07db16a246259c5ef86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc94324169d07db16a246259c5ef86b">&#9670;&nbsp;</a></span>Unget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::Unget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>inByte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inByte</td><td>a byte to insert</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_byte_queue.html#abdc94324169d07db16a246259c5ef86b" title="Insert data in the queue.">Unget()</a> inserts a byte at the head of the queue </p>

</div>
</div>
<a id="a2d72210af03aea4ca132ed46d91b67e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d72210af03aea4ca132ed46d91b67e1">&#9670;&nbsp;</a></span>Unget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::Unget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>a byte array to insert </td></tr>
    <tr><td class="paramname">length</td><td>the size of the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_byte_queue.html#abdc94324169d07db16a246259c5ef86b" title="Insert data in the queue.">Unget()</a> inserts a byte array at the head of the queue </p>

</div>
</div>
<a id="a0eef1f19b2faca146ac45333778d2eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eef1f19b2faca146ac45333778d2eac">&#9670;&nbsp;</a></span>Spy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* ByteQueue::Spy </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>contiguousSize</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek data in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contiguousSize</td><td>the size of the data</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_byte_queue.html#a0eef1f19b2faca146ac45333778d2eac" title="Peek data in the queue.">Spy()</a> peeks at data at the head of the queue. <a class="el" href="class_byte_queue.html#a0eef1f19b2faca146ac45333778d2eac" title="Peek data in the queue.">Spy()</a> does not remove data from the queue.</p>
<p>The data's size is returned in <code>contiguousSize</code>. <a class="el" href="class_byte_queue.html#a0eef1f19b2faca146ac45333778d2eac" title="Peek data in the queue.">Spy()</a> returns the size of the first byte array in the list. The entire data may be larger since the queue is a linked list of byte arrays. </p>

</div>
</div>
<a id="a127af9acc2ad34922953abd30447afa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127af9acc2ad34922953abd30447afa1">&#9670;&nbsp;</a></span>LazyPut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::LazyPut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>a byte array to insert </td></tr>
    <tr><td class="paramname">size</td><td>the length of the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1" title="Insert data in the queue.">LazyPut()</a> inserts a byte array at the tail of the queue. The data may not be copied at this point. Rather, the pointer and size to external data are recorded.</p>
<p>Another call to <a class="el" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede" title="Input a byte for processing.">Put()</a> or <a class="el" href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1" title="Insert data in the queue.">LazyPut()</a> will force the data to be copied. When lazy puts are used, the data is copied when <a class="el" href="class_byte_queue.html#a6d004338c41f8e04a723c7adab5d0895" title="Insert data in the queue.">FinalizeLazyPut()</a> is called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lazy_putter.html" title="Helper class to finalize Puts on ByteQueue.">LazyPutter</a> </dd></dl>

</div>
</div>
<a id="ac90c40206fc9e8ae2c4fc984347a360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90c40206fc9e8ae2c4fc984347a360a">&#9670;&nbsp;</a></span>LazyPutModifiable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::LazyPutModifiable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>a byte array to insert </td></tr>
    <tr><td class="paramname">size</td><td>the length of the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1" title="Insert data in the queue.">LazyPut()</a> inserts a byte array at the tail of the queue. The data may not be copied at this point. Rather, the pointer and size to external data are recorded.</p>
<p>Another call to <a class="el" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede" title="Input a byte for processing.">Put()</a> or <a class="el" href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1" title="Insert data in the queue.">LazyPut()</a> will force the data to be copied. When lazy puts are used, the data is copied when <a class="el" href="class_byte_queue.html#a6d004338c41f8e04a723c7adab5d0895" title="Insert data in the queue.">FinalizeLazyPut()</a> is called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lazy_putter.html" title="Helper class to finalize Puts on ByteQueue.">LazyPutter</a> </dd></dl>

</div>
</div>
<a id="a9c7e4d3fa01a23314b7809885b770d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7e4d3fa01a23314b7809885b770d23">&#9670;&nbsp;</a></span>UndoLazyPut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::UndoLazyPut </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove data from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the length of the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td>if there is no lazy data in the queue or if size is larger than the lazy string</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_byte_queue.html#a9c7e4d3fa01a23314b7809885b770d23" title="Remove data from the queue.">UndoLazyPut()</a> truncates data inserted using <a class="el" href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1" title="Insert data in the queue.">LazyPut()</a> by modifying size. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lazy_putter.html" title="Helper class to finalize Puts on ByteQueue.">LazyPutter</a> </dd></dl>

</div>
</div>
<a id="a6d004338c41f8e04a723c7adab5d0895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d004338c41f8e04a723c7adab5d0895">&#9670;&nbsp;</a></span>FinalizeLazyPut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::FinalizeLazyPut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data in the queue. </p>
<p><a class="el" href="class_byte_queue.html#a6d004338c41f8e04a723c7adab5d0895" title="Insert data in the queue.">FinalizeLazyPut()</a> copies external data inserted using <a class="el" href="class_byte_queue.html#a127af9acc2ad34922953abd30447afa1" title="Insert data in the queue.">LazyPut()</a> or <a class="el" href="class_byte_queue.html#ac90c40206fc9e8ae2c4fc984347a360a" title="Insert data in the queue.">LazyPutModifiable()</a> into the tail of the queue. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lazy_putter.html" title="Helper class to finalize Puts on ByteQueue.">LazyPutter</a> </dd></dl>

</div>
</div>
<a id="a38c97a037982729f799bf7a186a5837d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c97a037982729f799bf7a186a5837d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_byte_queue.html">ByteQueue</a>&amp; ByteQueue::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign contents from another <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the other <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </dd></dl>

</div>
</div>
<a id="a44c7d25ea94348e3d2d2f0abe572b23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c7d25ea94348e3d2d2f0abe572b23e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ByteQueue::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise compare two <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the other <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size and bits are equal, false otherwise</dd></dl>
<p><a class="el" href="class_byte_queue.html#a44c7d25ea94348e3d2d2f0abe572b23e" title="Bitwise compare two ByteQueue.">operator==()</a> walks each <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> comparing bytes in each queue. <a class="el" href="class_byte_queue.html#a44c7d25ea94348e3d2d2f0abe572b23e" title="Bitwise compare two ByteQueue.">operator==()</a> is not constant time. </p>

</div>
</div>
<a id="ad04e8294ef9f912b902aecb2948589d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04e8294ef9f912b902aecb2948589d0">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ByteQueue::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise compare two <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the other <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size and bits are not equal, false otherwise</dd></dl>
<p><a class="el" href="class_byte_queue.html#ad04e8294ef9f912b902aecb2948589d0" title="Bitwise compare two ByteQueue.">operator!=()</a> is implemented in terms of <a class="el" href="class_byte_queue.html#a44c7d25ea94348e3d2d2f0abe572b23e" title="Bitwise compare two ByteQueue.">operator==()</a>. <a class="el" href="class_byte_queue.html#a44c7d25ea94348e3d2d2f0abe572b23e" title="Bitwise compare two ByteQueue.">operator==()</a> is not constant time. </p>

<p class="definition">Definition at line <a class="el" href="queue_8h_source.html#l00151">151</a> of file <a class="el" href="queue_8h_source.html">queue.h</a>.</p>

</div>
</div>
<a id="a297d3b8e5e6e35b90a92fff23c01ea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297d3b8e5e6e35b90a92fff23c01ea19">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> ByteQueue::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#af483e021877846e97888686e55db93c1">lword</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve data from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>of byte to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte at the specified index</dd></dl>
<p><a class="el" href="class_byte_queue.html#a297d3b8e5e6e35b90a92fff23c01ea19" title="Retrieve data from the queue.">operator[]()</a> does not perform bounds checking. </p>

</div>
</div>
<a id="adcf03598210a516afc86abfb51ce5eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf03598210a516afc86abfb51ce5eb8">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteQueue::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_byte_queue.html">ByteQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap contents with another <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the other <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="queue_8h_source.html">queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 26 2023 03:35:21 for Crypto++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
