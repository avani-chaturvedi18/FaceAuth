<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crypto++: AllocatorWithCleanup&lt; T, T_Align16 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crypto++
   &#160;<span id="projectnumber">8.8</span>
   </div>
   <div id="projectbrief">Free&nbsp;C&#43;&#43;&nbsp;class&nbsp;library&nbsp;of&nbsp;cryptographic&nbsp;schemes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_allocator_with_cleanup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AllocatorWithCleanup&lt; T, T_Align16 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allocates a block of memory with cleanup.  
 <a href="class_allocator_with_cleanup.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for AllocatorWithCleanup&lt; T, T_Align16 &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_allocator_with_cleanup.png" usemap="#AllocatorWithCleanup_3C_20T_2C_20T_5FAlign16_20_3E_map" alt=""/>
  <map id="AllocatorWithCleanup_3C_20T_2C_20T_5FAlign16_20_3E_map" name="AllocatorWithCleanup_3C_20T_2C_20T_5FAlign16_20_3E_map">
<area href="class_allocator_base.html" title="Base class for all allocators used by SecBlock." alt="AllocatorBase&lt; T &gt;" shape="rect" coords="0,0,231,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_allocator_with_cleanup_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class member Rebind.  <a href="struct_allocator_with_cleanup_1_1rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af4df737c2f873bde968cc357d755092d"><td class="memItemLeft" align="right" valign="top"><a id="af4df737c2f873bde968cc357d755092d"></a>
typedef <a class="el" href="class_allocator_base.html">AllocatorBase</a>&lt; T &gt;::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:af4df737c2f873bde968cc357d755092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf718c1be3a6a60c81b14630a9c8484f"><td class="memItemLeft" align="right" valign="top"><a id="adf718c1be3a6a60c81b14630a9c8484f"></a>
typedef <a class="el" href="class_allocator_base.html">AllocatorBase</a>&lt; T &gt;::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:adf718c1be3a6a60c81b14630a9c8484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6560ac33efd6c3b32c3493f670974f41"><td class="memItemLeft" align="right" valign="top"><a id="a6560ac33efd6c3b32c3493f670974f41"></a>
typedef <a class="el" href="class_allocator_base.html">AllocatorBase</a>&lt; T &gt;::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a6560ac33efd6c3b32c3493f670974f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816366df6afec816d7b72280b627340c"><td class="memItemLeft" align="right" valign="top"><a id="a816366df6afec816d7b72280b627340c"></a>
typedef <a class="el" href="class_allocator_base.html">AllocatorBase</a>&lt; T &gt;::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a816366df6afec816d7b72280b627340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a5b111dedb44ef64270c9719d1320c"><td class="memItemLeft" align="right" valign="top"><a id="a60a5b111dedb44ef64270c9719d1320c"></a>
typedef <a class="el" href="class_allocator_base.html">AllocatorBase</a>&lt; T &gt;::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a60a5b111dedb44ef64270c9719d1320c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934fee099c20730c29fce24f66a71b2c"><td class="memItemLeft" align="right" valign="top"><a id="a934fee099c20730c29fce24f66a71b2c"></a>
typedef <a class="el" href="class_allocator_base.html">AllocatorBase</a>&lt; T &gt;::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a934fee099c20730c29fce24f66a71b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0950b72602520147cac2b332ff20e07"><td class="memItemLeft" align="right" valign="top"><a id="ab0950b72602520147cac2b332ff20e07"></a>
typedef <a class="el" href="class_allocator_base.html">AllocatorBase</a>&lt; T &gt;::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:ab0950b72602520147cac2b332ff20e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_allocator_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_allocator_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_allocator_base.html">AllocatorBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a461f6d214f73761bb656a76db8f608c0 inherit pub_types_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a461f6d214f73761bb656a76db8f608c0"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a461f6d214f73761bb656a76db8f608c0 inherit pub_types_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda200f657efdba2d08e80ee9a7f244d inherit pub_types_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="adda200f657efdba2d08e80ee9a7f244d"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:adda200f657efdba2d08e80ee9a7f244d inherit pub_types_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c1b15630e208c28183b72debcff98c inherit pub_types_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a10c1b15630e208c28183b72debcff98c"></a>
typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a10c1b15630e208c28183b72debcff98c inherit pub_types_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719f87a9b5da234dbc8c8c1c88be253c inherit pub_types_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a719f87a9b5da234dbc8c8c1c88be253c"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a719f87a9b5da234dbc8c8c1c88be253c inherit pub_types_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac778a475e77ea22ff8e7bea2aa983e inherit pub_types_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a3ac778a475e77ea22ff8e7bea2aa983e"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a3ac778a475e77ea22ff8e7bea2aa983e inherit pub_types_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151889fd23094bf841959ab226708f83 inherit pub_types_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a151889fd23094bf841959ab226708f83"></a>
typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a151889fd23094bf841959ab226708f83 inherit pub_types_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad08c82939fd8b18621a1d870a0d10e inherit pub_types_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a3ad08c82939fd8b18621a1d870a0d10e"></a>
typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a3ad08c82939fd8b18621a1d870a0d10e inherit pub_types_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a213d3399b5e89e61f2bf4fc512da289f"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_allocator_with_cleanup.html#a213d3399b5e89e61f2bf4fc512da289f">allocate</a> (size_type size, const void *ptr=NULL)</td></tr>
<tr class="memdesc:a213d3399b5e89e61f2bf4fc512da289f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a block of memory.  <a href="class_allocator_with_cleanup.html#a213d3399b5e89e61f2bf4fc512da289f">More...</a><br /></td></tr>
<tr class="separator:a213d3399b5e89e61f2bf4fc512da289f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ccfc3c9d795472dcc124db72d869de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_allocator_with_cleanup.html#ad6ccfc3c9d795472dcc124db72d869de">deallocate</a> (void *ptr, size_type size)</td></tr>
<tr class="memdesc:ad6ccfc3c9d795472dcc124db72d869de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a block of memory.  <a href="class_allocator_with_cleanup.html#ad6ccfc3c9d795472dcc124db72d869de">More...</a><br /></td></tr>
<tr class="separator:ad6ccfc3c9d795472dcc124db72d869de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9741e2fbdf763739af65bd7c3fb825a"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_allocator_with_cleanup.html#ac9741e2fbdf763739af65bd7c3fb825a">reallocate</a> (T *oldPtr, size_type oldSize, size_type newSize, bool preserve)</td></tr>
<tr class="memdesc:ac9741e2fbdf763739af65bd7c3fb825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates a block of memory.  <a href="class_allocator_with_cleanup.html#ac9741e2fbdf763739af65bd7c3fb825a">More...</a><br /></td></tr>
<tr class="separator:ac9741e2fbdf763739af65bd7c3fb825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_allocator_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_allocator_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_allocator_base.html">AllocatorBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a9d7ddf797b14ff38e335357759cf0b8b inherit pub_methods_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a9d7ddf797b14ff38e335357759cf0b8b"></a>
pointer&#160;</td><td class="memItemRight" valign="bottom"><b>address</b> (reference r) const</td></tr>
<tr class="separator:a9d7ddf797b14ff38e335357759cf0b8b inherit pub_methods_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731d970fd5b1adb9f87b4cfe81121d74 inherit pub_methods_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a731d970fd5b1adb9f87b4cfe81121d74"></a>
const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>address</b> (const_reference r) const</td></tr>
<tr class="separator:a731d970fd5b1adb9f87b4cfe81121d74 inherit pub_methods_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4816881defdf38aa120c70a03b7da903 inherit pub_methods_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a4816881defdf38aa120c70a03b7da903"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>construct</b> (pointer p, const T &amp;val)</td></tr>
<tr class="separator:a4816881defdf38aa120c70a03b7da903 inherit pub_methods_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740cc02314cba092678ab0545fa6967b inherit pub_methods_class_allocator_base"><td class="memItemLeft" align="right" valign="top"><a id="a740cc02314cba092678ab0545fa6967b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> (pointer p)</td></tr>
<tr class="separator:a740cc02314cba092678ab0545fa6967b inherit pub_methods_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2148e4d9df51a5b294eaf538e3f0074 inherit pub_methods_class_allocator_base"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_allocator_base.html#ac2148e4d9df51a5b294eaf538e3f0074">max_size</a> () const</td></tr>
<tr class="memdesc:ac2148e4d9df51a5b294eaf538e3f0074 inherit pub_methods_class_allocator_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the allocator can provide.  <a href="class_allocator_base.html#ac2148e4d9df51a5b294eaf538e3f0074">More...</a><br /></td></tr>
<tr class="separator:ac2148e4d9df51a5b294eaf538e3f0074 inherit pub_methods_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c3e8ddd039b328cb9db2e7f325519a inherit pub_methods_class_allocator_base"><td class="memTemplParams" colspan="2">template&lt;typename V , typename... Args&gt; </td></tr>
<tr class="memitem:a67c3e8ddd039b328cb9db2e7f325519a inherit pub_methods_class_allocator_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_allocator_base.html#a67c3e8ddd039b328cb9db2e7f325519a">construct</a> (V *ptr, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a67c3e8ddd039b328cb9db2e7f325519a inherit pub_methods_class_allocator_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new V using variadic arguments.  <a href="class_allocator_base.html#a67c3e8ddd039b328cb9db2e7f325519a">More...</a><br /></td></tr>
<tr class="separator:a67c3e8ddd039b328cb9db2e7f325519a inherit pub_methods_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c6ff2132938f6afe935980a34f1b2d inherit pub_methods_class_allocator_base"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ae9c6ff2132938f6afe935980a34f1b2d inherit pub_methods_class_allocator_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_allocator_base.html#ae9c6ff2132938f6afe935980a34f1b2d">destroy</a> (V *ptr)</td></tr>
<tr class="memdesc:ae9c6ff2132938f6afe935980a34f1b2d inherit pub_methods_class_allocator_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an V constructed with variadic arguments.  <a href="class_allocator_base.html#ae9c6ff2132938f6afe935980a34f1b2d">More...</a><br /></td></tr>
<tr class="separator:ae9c6ff2132938f6afe935980a34f1b2d inherit pub_methods_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_allocator_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_allocator_base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_allocator_base.html">AllocatorBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a88e45c0e5510a893595ed0073c99c3fb inherit pub_static_attribs_class_allocator_base"><td class="memItemLeft" align="right" valign="top">static const size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_allocator_base.html#a88e45c0e5510a893595ed0073c99c3fb">ELEMS_MAX</a> = ...</td></tr>
<tr class="memdesc:a88e45c0e5510a893595ed0073c99c3fb inherit pub_static_attribs_class_allocator_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the allocator can provide.  <a href="class_allocator_base.html#a88e45c0e5510a893595ed0073c99c3fb">More...</a><br /></td></tr>
<tr class="separator:a88e45c0e5510a893595ed0073c99c3fb inherit pub_static_attribs_class_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, bool T_Align16 = false&gt;<br />
class AllocatorWithCleanup&lt; T, T_Align16 &gt;</h3>

<p>Allocates a block of memory with cleanup. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
    <tr><td class="paramname">T_Align16</td><td>boolean that determines whether allocations should be aligned on a 16-byte boundary</td></tr>
  </table>
  </dd>
</dl>
<p>If T_Align16 is true, then <a class="el" href="class_allocator_with_cleanup.html" title="Allocates a block of memory with cleanup.">AllocatorWithCleanup</a> calls <a class="el" href="allocate_8h.html#ae1a893782609787a8a174a47e6587477" title="Allocates a buffer on 16-byte boundary.">AlignedAllocate()</a> for memory allocations. If T_Align16 is false, then <a class="el" href="class_allocator_with_cleanup.html" title="Allocates a block of memory with cleanup.">AllocatorWithCleanup()</a> calls <a class="el" href="allocate_8h.html#a5ab2916a1b907af73d207015ce15d15a" title="Allocates a buffer.">UnalignedAllocate()</a> for memory allocations.</p>
<p>Template parameter T_Align16 is effectively controlled by <a class="el" href="cryptlib_8h.html" title="Abstract base classes that provide a uniform interface to this library.">cryptlib.h</a> and mirrors CRYPTOPP_BOOL_ALIGN16. CRYPTOPP_BOOL_ALIGN16 is often used as the template parameter. </p>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00187">187</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a213d3399b5e89e61f2bf4fc512da289f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213d3399b5e89e61f2bf4fc512da289f">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool T_Align16 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="class_allocator_with_cleanup.html">AllocatorWithCleanup</a>&lt; T, T_Align16 &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the size of the allocation </td></tr>
    <tr><td class="paramname">size</td><td>the size of the allocation, in elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a memory block </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_allocator_with_cleanup.html#a213d3399b5e89e61f2bf4fc512da289f" title="Allocates a block of memory.">allocate()</a> first checks the size of the request. If it is non-0 and less than <a class="el" href="class_allocator_base.html#ac2148e4d9df51a5b294eaf538e3f0074" title="Returns the maximum number of elements the allocator can provide.">max_size()</a>, then an attempt is made to fulfill the request using either <a class="el" href="allocate_8h.html#ae1a893782609787a8a174a47e6587477" title="Allocates a buffer on 16-byte boundary.">AlignedAllocate()</a> or <a class="el" href="allocate_8h.html#a5ab2916a1b907af73d207015ce15d15a" title="Allocates a buffer.">UnalignedAllocate()</a>. <a class="el" href="allocate_8h.html#ae1a893782609787a8a174a47e6587477" title="Allocates a buffer on 16-byte boundary.">AlignedAllocate()</a> is used if T_Align16 is true. <a class="el" href="allocate_8h.html#a5ab2916a1b907af73d207015ce15d15a" title="Allocates a buffer.">UnalignedAllocate()</a> used if T_Align16 is false.</p>
<p>This is the C++ *Placement New* operator. ptr is not used, and the function asserts in Debug builds if ptr is non-NULL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="allocate_8h.html#a4efe98b1ab4ba32d36fb2487fd5a2eb1" title="Attempts to reclaim unused memory.">CallNewHandler()</a> for the methods used to recover from a failed allocation attempt. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>size is the count of elements, and not the number of bytes </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00206">206</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="ad6ccfc3c9d795472dcc124db72d869de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ccfc3c9d795472dcc124db72d869de">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool T_Align16 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_allocator_with_cleanup.html">AllocatorWithCleanup</a>&lt; T, T_Align16 &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer for the allocation </td></tr>
    <tr><td class="paramname">size</td><td>the size of the allocation, in elements</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, <a class="el" href="misc_8h.html#a4994f3480634e5f1435fd71f9b652c38" title="Sets each element of an array to 0.">SecureWipeArray()</a> is called before deallocating the memory. Once the memory block is wiped or zeroized, <a class="el" href="allocate_8h.html#a15a489c16a515417f1f63a8554a0c4d2" title="Frees a buffer allocated with AlignedAllocate.">AlignedDeallocate()</a> or <a class="el" href="allocate_8h.html#a7ec1f8cd926f97e667d438cede364003" title="Frees a buffer allocated with UnalignedAllocate.">UnalignedDeallocate()</a> is called.</p>
<p><a class="el" href="allocate_8h.html#a15a489c16a515417f1f63a8554a0c4d2" title="Frees a buffer allocated with AlignedAllocate.">AlignedDeallocate()</a> is used if T_Align16 is true. <a class="el" href="allocate_8h.html#a7ec1f8cd926f97e667d438cede364003" title="Frees a buffer allocated with UnalignedAllocate.">UnalignedDeallocate()</a> used if T_Align16 is false. </p>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00229">229</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="ac9741e2fbdf763739af65bd7c3fb825a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9741e2fbdf763739af65bd7c3fb825a">&#9670;&nbsp;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool T_Align16 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="class_allocator_with_cleanup.html">AllocatorWithCleanup</a>&lt; T, T_Align16 &gt;::reallocate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>oldPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>oldSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocates a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldPtr</td><td>the previous allocation </td></tr>
    <tr><td class="paramname">oldSize</td><td>the size of the previous allocation </td></tr>
    <tr><td class="paramname">newSize</td><td>the new, requested size </td></tr>
    <tr><td class="paramname">preserve</td><td>flag that indicates if the old allocation should be preserved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new memory block</dd></dl>
<p>Internally, <a class="el" href="class_allocator_with_cleanup.html#ac9741e2fbdf763739af65bd7c3fb825a" title="Reallocates a block of memory.">reallocate()</a> calls <a class="el" href="secblock_8h.html#a2fc63f3c7dfc5657fe8a12d16acdfb17" title="Reallocation function.">StandardReallocate()</a>.</p>
<p>If preserve is true, then index 0 is used to begin copying the old memory block to the new one. If the block grows, then the old array is copied in its entirety. If the block shrinks, then only newSize elements are copied from the old block to the new one. </p><dl class="section note"><dt>Note</dt><dd>oldSize and newSize are the count of elements, and not the number of bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00259">259</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="secblock_8h_source.html">secblock.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 26 2023 03:35:20 for Crypto++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
