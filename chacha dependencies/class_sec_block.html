<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crypto++: SecBlock&lt; T, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crypto++
   &#160;<span id="projectnumber">8.8</span>
   </div>
   <div id="projectbrief">Free&nbsp;C&#43;&#43;&nbsp;class&nbsp;library&nbsp;of&nbsp;cryptographic&nbsp;schemes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_sec_block-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SecBlock&lt; T, A &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Secure memory block with allocator and cleanup.  
 <a href="class_sec_block.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SecBlock&lt; T, A &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_sec_block.png" usemap="#SecBlock_3C_20T_2C_20A_20_3E_map" alt=""/>
  <map id="SecBlock_3C_20T_2C_20A_20_3E_map" name="SecBlock_3C_20T_2C_20A_20_3E_map">
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, MDC_Info&lt; H &gt;::KEYLENGTH, AllocatorWithCleanup&lt; byte &gt; &gt;" shape="rect" coords="556,56,1102,80"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, MDC_Info&lt; H &gt;::BLOCKSIZE, AllocatorWithCleanup&lt; byte &gt; &gt;" shape="rect" coords="556,112,1102,136"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 40 &gt;" shape="rect" coords="556,168,1102,192"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 25 *4 &gt;" shape="rect" coords="556,224,1102,248"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word64, 2 &gt;" shape="rect" coords="556,280,1102,304"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, N+1 &gt;" shape="rect" coords="556,336,1102,360"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 80+2 &gt;" shape="rect" coords="556,392,1102,416"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 3 &gt;" shape="rect" coords="556,448,1102,472"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, PUBLIC_KEYLENGTH &gt;" shape="rect" coords="556,504,1102,528"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 512 &gt;" shape="rect" coords="556,560,1102,584"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; unsigned int, 286 &gt;" shape="rect" coords="556,616,1102,640"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, BLOCKSIZE &gt;" shape="rect" coords="556,672,1102,696"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 4 &gt;" shape="rect" coords="556,728,1102,752"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 10 &gt;" shape="rect" coords="556,784,1102,808"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 4 *(ROUNDS+1)&gt;" shape="rect" coords="556,840,1102,864"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word64, 4 &gt;" shape="rect" coords="556,896,1102,920"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 5 &gt;" shape="rect" coords="556,952,1102,976"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; unsigned int, 30 &gt;" shape="rect" coords="556,1008,1102,1032"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 33 *4 &gt;" shape="rect" coords="556,1064,1102,1088"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word64, 25 &gt;" shape="rect" coords="556,1120,1102,1144"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 8 *12 &gt;" shape="rect" coords="556,1176,1102,1200"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word16, ROUNDS &gt;" shape="rect" coords="556,1232,1102,1256"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word16, 64 &gt;" shape="rect" coords="556,1288,1102,1312"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 8 &gt;" shape="rect" coords="556,1344,1102,1368"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, 10 *256 &gt;" shape="rect" coords="556,1400,1102,1424"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 256 &gt;" shape="rect" coords="556,1456,1102,1480"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; T, S, FixedSizeAllocatorWithCleanup&lt; T, S, NullAllocator&lt; T &gt;, true &gt; &gt;" shape="rect" coords="556,1512,1102,1536"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, 256 &gt;" shape="rect" coords="556,1568,1102,1592"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 16 &gt;" shape="rect" coords="556,1624,1102,1648"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word16, 4 &gt;" shape="rect" coords="556,1680,1102,1704"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, 8 &gt;" shape="rect" coords="556,1736,1102,1760"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word16, 5 &gt;" shape="rect" coords="556,1792,1102,1816"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, 136 &gt;" shape="rect" coords="556,1848,1102,1872"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 4 *256 &gt;" shape="rect" coords="556,1904,1102,1928"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; T_HashWordType, Blocks &gt;" shape="rect" coords="556,1960,1102,1984"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; Word, 6 *ROUNDS+4 &gt;" shape="rect" coords="556,2016,1102,2040"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 32 &gt;" shape="rect" coords="556,2072,1102,2096"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, ROUNDS+2 &gt;" shape="rect" coords="556,2128,1102,2152"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; byte, SECRET_KEYLENGTH &gt;" shape="rect" coords="556,2184,1102,2208"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, ROUNDS &gt;" shape="rect" coords="556,2240,1102,2264"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word64, 80+2 &gt;" shape="rect" coords="556,2296,1102,2320"/>
<area href="class_fixed_size_sec_block.html" alt="FixedSizeSecBlock&lt; word32, 12 &gt;" shape="rect" coords="556,2352,1102,2376"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7bc2d547feea24c569da76ada0f3786"><td class="memItemLeft" align="right" valign="top"><a id="ac7bc2d547feea24c569da76ada0f3786"></a>
typedef A::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ac7bc2d547feea24c569da76ada0f3786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839702c5cf360db92e8e89a18f4d1705"><td class="memItemLeft" align="right" valign="top"><a id="a839702c5cf360db92e8e89a18f4d1705"></a>
typedef A::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a839702c5cf360db92e8e89a18f4d1705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be6a18e0ae7680c5071d43c3bf6348"><td class="memItemLeft" align="right" valign="top"><a id="a00be6a18e0ae7680c5071d43c3bf6348"></a>
typedef A::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a00be6a18e0ae7680c5071d43c3bf6348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37f179bc9420b7af601df75eaed3c90"><td class="memItemLeft" align="right" valign="top"><a id="ac37f179bc9420b7af601df75eaed3c90"></a>
typedef A::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:ac37f179bc9420b7af601df75eaed3c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f12a6f68483596916fd1893b4043816"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a3f12a6f68483596916fd1893b4043816">SecBlock</a> (size_type <a class="el" href="class_sec_block.html#af5999bffe3193e62719cc0792b0282a7">size</a>=0)</td></tr>
<tr class="memdesc:a3f12a6f68483596916fd1893b4043816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> with space for size elements.  <a href="class_sec_block.html#a3f12a6f68483596916fd1893b4043816">More...</a><br /></td></tr>
<tr class="separator:a3f12a6f68483596916fd1893b4043816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c09b064510dead98bc0da7cd52c28e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a2c09b064510dead98bc0da7cd52c28e4">SecBlock</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t)</td></tr>
<tr class="memdesc:a2c09b064510dead98bc0da7cd52c28e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#a2c09b064510dead98bc0da7cd52c28e4">More...</a><br /></td></tr>
<tr class="separator:a2c09b064510dead98bc0da7cd52c28e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71728825c06014d946da7bd46a7da6af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a71728825c06014d946da7bd46a7da6af">SecBlock</a> (const T *ptr, size_type len)</td></tr>
<tr class="memdesc:a71728825c06014d946da7bd46a7da6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> from an array of elements.  <a href="class_sec_block.html#a71728825c06014d946da7bd46a7da6af">More...</a><br /></td></tr>
<tr class="separator:a71728825c06014d946da7bd46a7da6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeedb31c4a57af2dc59a1e23cf62ba6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#afeedb31c4a57af2dc59a1e23cf62ba6c">operator const void *</a> () const</td></tr>
<tr class="memdesc:afeedb31c4a57af2dc59a1e23cf62ba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast operator.  <a href="class_sec_block.html#afeedb31c4a57af2dc59a1e23cf62ba6c">More...</a><br /></td></tr>
<tr class="separator:afeedb31c4a57af2dc59a1e23cf62ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6453a5b2b481544f7f77bbe3fea0a78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#ac6453a5b2b481544f7f77bbe3fea0a78">operator void *</a> ()</td></tr>
<tr class="memdesc:ac6453a5b2b481544f7f77bbe3fea0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast operator.  <a href="class_sec_block.html#ac6453a5b2b481544f7f77bbe3fea0a78">More...</a><br /></td></tr>
<tr class="separator:ac6453a5b2b481544f7f77bbe3fea0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b250c34d61acb745ba2eca9c6a61bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#ab3b250c34d61acb745ba2eca9c6a61bf">operator const T *</a> () const</td></tr>
<tr class="memdesc:ab3b250c34d61acb745ba2eca9c6a61bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast operator.  <a href="class_sec_block.html#ab3b250c34d61acb745ba2eca9c6a61bf">More...</a><br /></td></tr>
<tr class="separator:ab3b250c34d61acb745ba2eca9c6a61bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b3f34a0d3670f8f1358bbd72c74716"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#ab7b3f34a0d3670f8f1358bbd72c74716">operator T*</a> ()</td></tr>
<tr class="memdesc:ab7b3f34a0d3670f8f1358bbd72c74716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast operator.  <a href="class_sec_block.html#ab7b3f34a0d3670f8f1358bbd72c74716">More...</a><br /></td></tr>
<tr class="separator:ab7b3f34a0d3670f8f1358bbd72c74716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a05906688172579cd3520816799446"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a11a05906688172579cd3520816799446">begin</a> ()</td></tr>
<tr class="memdesc:a11a05906688172579cd3520816799446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an iterator pointing to the first element in the memory block.  <a href="class_sec_block.html#a11a05906688172579cd3520816799446">More...</a><br /></td></tr>
<tr class="separator:a11a05906688172579cd3520816799446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18351db729daac209ce017661a0cf6e8"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a18351db729daac209ce017661a0cf6e8">begin</a> () const</td></tr>
<tr class="memdesc:a18351db729daac209ce017661a0cf6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a constant iterator pointing to the first element in the memory block.  <a href="class_sec_block.html#a18351db729daac209ce017661a0cf6e8">More...</a><br /></td></tr>
<tr class="separator:a18351db729daac209ce017661a0cf6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d88ba73b5da0f5dd4ab87ce6345d8f"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a26d88ba73b5da0f5dd4ab87ce6345d8f">end</a> ()</td></tr>
<tr class="memdesc:a26d88ba73b5da0f5dd4ab87ce6345d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an iterator pointing beyond the last element in the memory block.  <a href="class_sec_block.html#a26d88ba73b5da0f5dd4ab87ce6345d8f">More...</a><br /></td></tr>
<tr class="separator:a26d88ba73b5da0f5dd4ab87ce6345d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47c5182bac200930228ef5666b35336"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#ac47c5182bac200930228ef5666b35336">end</a> () const</td></tr>
<tr class="memdesc:ac47c5182bac200930228ef5666b35336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a constant iterator pointing beyond the last element in the memory block.  <a href="class_sec_block.html#ac47c5182bac200930228ef5666b35336">More...</a><br /></td></tr>
<tr class="separator:ac47c5182bac200930228ef5666b35336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ad7c28810297ca50b2411284876845"><td class="memItemLeft" align="right" valign="top">A::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a42ad7c28810297ca50b2411284876845">data</a> ()</td></tr>
<tr class="memdesc:a42ad7c28810297ca50b2411284876845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a pointer to the first element in the memory block.  <a href="class_sec_block.html#a42ad7c28810297ca50b2411284876845">More...</a><br /></td></tr>
<tr class="separator:a42ad7c28810297ca50b2411284876845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc465230b3c6849565a19d1c7d7f5c1f"><td class="memItemLeft" align="right" valign="top">A::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#acc465230b3c6849565a19d1c7d7f5c1f">data</a> () const</td></tr>
<tr class="memdesc:acc465230b3c6849565a19d1c7d7f5c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a pointer to the first element in the memory block.  <a href="class_sec_block.html#acc465230b3c6849565a19d1c7d7f5c1f">More...</a><br /></td></tr>
<tr class="separator:acc465230b3c6849565a19d1c7d7f5c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5999bffe3193e62719cc0792b0282a7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#af5999bffe3193e62719cc0792b0282a7">size</a> () const</td></tr>
<tr class="memdesc:af5999bffe3193e62719cc0792b0282a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the count of elements in the <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#af5999bffe3193e62719cc0792b0282a7">More...</a><br /></td></tr>
<tr class="separator:af5999bffe3193e62719cc0792b0282a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf162565508e31bfe5a2eb3946411829"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#acf162565508e31bfe5a2eb3946411829">empty</a> () const</td></tr>
<tr class="memdesc:acf162565508e31bfe5a2eb3946411829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> is empty.  <a href="class_sec_block.html#acf162565508e31bfe5a2eb3946411829">More...</a><br /></td></tr>
<tr class="separator:acf162565508e31bfe5a2eb3946411829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5565f51350846fb7224720c403674216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a5565f51350846fb7224720c403674216">BytePtr</a> ()</td></tr>
<tr class="memdesc:a5565f51350846fb7224720c403674216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a byte pointer to the first element in the memory block.  <a href="class_sec_block.html#a5565f51350846fb7224720c403674216">More...</a><br /></td></tr>
<tr class="separator:a5565f51350846fb7224720c403674216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565f381f0b133268b77d770bfcfc9a09"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a565f381f0b133268b77d770bfcfc9a09">BytePtr</a> () const</td></tr>
<tr class="memdesc:a565f381f0b133268b77d770bfcfc9a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a byte pointer to the first element in the memory block.  <a href="class_sec_block.html#a565f381f0b133268b77d770bfcfc9a09">More...</a><br /></td></tr>
<tr class="separator:a565f381f0b133268b77d770bfcfc9a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e1256d8021ba4ab9007ea4e19ae8c2"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a93e1256d8021ba4ab9007ea4e19ae8c2">SizeInBytes</a> () const</td></tr>
<tr class="memdesc:a93e1256d8021ba4ab9007ea4e19ae8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of bytes in the <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#a93e1256d8021ba4ab9007ea4e19ae8c2">More...</a><br /></td></tr>
<tr class="separator:a93e1256d8021ba4ab9007ea4e19ae8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf38f976508a632e2f74aa4f2622da86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86">Assign</a> (const T *ptr, size_type len)</td></tr>
<tr class="memdesc:aaf38f976508a632e2f74aa4f2622da86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set contents and size from an array.  <a href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86">More...</a><br /></td></tr>
<tr class="separator:aaf38f976508a632e2f74aa4f2622da86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10754ccddd6b2466f647ba23c76d719b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a10754ccddd6b2466f647ba23c76d719b">Assign</a> (size_type count, T value)</td></tr>
<tr class="memdesc:a10754ccddd6b2466f647ba23c76d719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set contents from a value.  <a href="class_sec_block.html#a10754ccddd6b2466f647ba23c76d719b">More...</a><br /></td></tr>
<tr class="separator:a10754ccddd6b2466f647ba23c76d719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309d571ffb1b7d58185a8309ca58e6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a309d571ffb1b7d58185a8309ca58e6b2">Assign</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t)</td></tr>
<tr class="memdesc:a309d571ffb1b7d58185a8309ca58e6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#a309d571ffb1b7d58185a8309ca58e6b2">More...</a><br /></td></tr>
<tr class="separator:a309d571ffb1b7d58185a8309ca58e6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed5302fd608c7eaa8284c9b07e41f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82">Append</a> (const T *ptr, size_type len)</td></tr>
<tr class="memdesc:a1ed5302fd608c7eaa8284c9b07e41f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append contents from an array.  <a href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82">More...</a><br /></td></tr>
<tr class="separator:a1ed5302fd608c7eaa8284c9b07e41f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c1913495aa3d8c0404bbd674a0ec3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a94c1913495aa3d8c0404bbd674a0ec3f">Append</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t)</td></tr>
<tr class="memdesc:a94c1913495aa3d8c0404bbd674a0ec3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#a94c1913495aa3d8c0404bbd674a0ec3f">More...</a><br /></td></tr>
<tr class="separator:a94c1913495aa3d8c0404bbd674a0ec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7560e98627dc400699adf9c428f5b514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a7560e98627dc400699adf9c428f5b514">Append</a> (size_type count, T value)</td></tr>
<tr class="memdesc:a7560e98627dc400699adf9c428f5b514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append contents from a value.  <a href="class_sec_block.html#a7560e98627dc400699adf9c428f5b514">More...</a><br /></td></tr>
<tr class="separator:a7560e98627dc400699adf9c428f5b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae276714a804a016747d0e17f0ac76f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#aae276714a804a016747d0e17f0ac76f2">SetMark</a> (size_t count)</td></tr>
<tr class="memdesc:aae276714a804a016747d0e17f0ac76f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of elements to zeroize.  <a href="class_sec_block.html#aae276714a804a016747d0e17f0ac76f2">More...</a><br /></td></tr>
<tr class="separator:aae276714a804a016747d0e17f0ac76f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8cdaa95af4f2c8597d01930f90fac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#adb8cdaa95af4f2c8597d01930f90fac2">operator=</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t)</td></tr>
<tr class="memdesc:adb8cdaa95af4f2c8597d01930f90fac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#adb8cdaa95af4f2c8597d01930f90fac2">More...</a><br /></td></tr>
<tr class="separator:adb8cdaa95af4f2c8597d01930f90fac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49f5fe6f6c2e1ae8e8c13e9eec38fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#acf49f5fe6f6c2e1ae8e8c13e9eec38fc">operator+=</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t)</td></tr>
<tr class="memdesc:acf49f5fe6f6c2e1ae8e8c13e9eec38fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#acf49f5fe6f6c2e1ae8e8c13e9eec38fc">More...</a><br /></td></tr>
<tr class="separator:acf49f5fe6f6c2e1ae8e8c13e9eec38fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c641a244b1d12301db043b066968ffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a4c641a244b1d12301db043b066968ffc">operator+</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t)</td></tr>
<tr class="memdesc:a4c641a244b1d12301db043b066968ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> from this and another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#a4c641a244b1d12301db043b066968ffc">More...</a><br /></td></tr>
<tr class="separator:a4c641a244b1d12301db043b066968ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc30b9a5602c8f8583749de427e355d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a7cc30b9a5602c8f8583749de427e355d">operator==</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t) const</td></tr>
<tr class="memdesc:a7cc30b9a5602c8f8583749de427e355d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise compare two SecBlocks.  <a href="class_sec_block.html#a7cc30b9a5602c8f8583749de427e355d">More...</a><br /></td></tr>
<tr class="separator:a7cc30b9a5602c8f8583749de427e355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6123ec21ad948ffbd947da8064ccec60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a6123ec21ad948ffbd947da8064ccec60">operator!=</a> (const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;t) const</td></tr>
<tr class="memdesc:a6123ec21ad948ffbd947da8064ccec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise compare two SecBlocks.  <a href="class_sec_block.html#a6123ec21ad948ffbd947da8064ccec60">More...</a><br /></td></tr>
<tr class="separator:a6123ec21ad948ffbd947da8064ccec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d46e577c951d81a2d25a4742a3e979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979">New</a> (size_type newSize)</td></tr>
<tr class="memdesc:a90d46e577c951d81a2d25a4742a3e979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size without preserving contents.  <a href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979">More...</a><br /></td></tr>
<tr class="separator:a90d46e577c951d81a2d25a4742a3e979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d78e75002fd02e5b89bd72a9e65e769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769">CleanNew</a> (size_type newSize)</td></tr>
<tr class="memdesc:a2d78e75002fd02e5b89bd72a9e65e769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size without preserving contents.  <a href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769">More...</a><br /></td></tr>
<tr class="separator:a2d78e75002fd02e5b89bd72a9e65e769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dea287fba8236b0979b52beece0ec1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b">Grow</a> (size_type newSize)</td></tr>
<tr class="memdesc:a8dea287fba8236b0979b52beece0ec1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size and preserve contents.  <a href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b">More...</a><br /></td></tr>
<tr class="separator:a8dea287fba8236b0979b52beece0ec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef9516e973051e6afa38bba526da3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9">CleanGrow</a> (size_type newSize)</td></tr>
<tr class="memdesc:a4ef9516e973051e6afa38bba526da3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size and preserve contents.  <a href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9">More...</a><br /></td></tr>
<tr class="separator:a4ef9516e973051e6afa38bba526da3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e98d3f4a7af1156fcf3e6e68f4ae5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a">resize</a> (size_type newSize)</td></tr>
<tr class="memdesc:af9e98d3f4a7af1156fcf3e6e68f4ae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size and preserve contents.  <a href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a">More...</a><br /></td></tr>
<tr class="separator:af9e98d3f4a7af1156fcf3e6e68f4ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3872f50f03372fa859803971961f02cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#a3872f50f03372fa859803971961f02cd">swap</a> (<a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;b)</td></tr>
<tr class="memdesc:a3872f50f03372fa859803971961f02cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents with another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>.  <a href="class_sec_block.html#a3872f50f03372fa859803971961f02cd">More...</a><br /></td></tr>
<tr class="separator:a3872f50f03372fa859803971961f02cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac637b6a87a1bfd9c7959a225af1efe93"><td class="memItemLeft" align="right" valign="top">static const size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sec_block.html#ac637b6a87a1bfd9c7959a225af1efe93">ELEMS_MAX</a> = ...</td></tr>
<tr class="memdesc:ac637b6a87a1bfd9c7959a225af1efe93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the block can hold.  <a href="class_sec_block.html#ac637b6a87a1bfd9c7959a225af1efe93">More...</a><br /></td></tr>
<tr class="separator:ac637b6a87a1bfd9c7959a225af1efe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class A = AllocatorWithCleanup&lt;T&gt;&gt;<br />
class SecBlock&lt; T, A &gt;</h3>

<p>Secure memory block with allocator and cleanup. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a class or type </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="class_allocator_with_cleanup.html" title="Allocates a block of memory with cleanup.">AllocatorWithCleanup</a> derived class for allocation and cleanup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.cryptopp.com/wiki/SecBlock">SecBlock</a> on the Crypto++ wiki. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00730">730</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f12a6f68483596916fd1893b4043816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f12a6f68483596916fd1893b4043816">&#9670;&nbsp;</a></span>SecBlock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::<a class="el" href="class_sec_block.html">SecBlock</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> with space for size elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of the allocation, in elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>The elements are not initialized. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>size is the count of elements, and not the number of bytes </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00766">766</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a2c09b064510dead98bc0da7cd52c28e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c09b064510dead98bc0da7cd52c28e4">&#9670;&nbsp;</a></span>SecBlock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::<a class="el" href="class_sec_block.html">SecBlock</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00773">773</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a71728825c06014d946da7bd46a7da6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71728825c06014d946da7bd46a7da6af">&#9670;&nbsp;</a></span>SecBlock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::<a class="el" href="class_sec_block.html">SecBlock</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> from an array of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to an array of T </td></tr>
    <tr><td class="paramname">len</td><td>the number of elements in the memory block </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>If <code>ptr!=NULL</code> and <code>len!=0</code>, then the block is initialized from the pointer <code>ptr</code>. If <code>ptr==NULL</code> and <code>len!=0</code>, then the block is initialized to 0. Otherwise, the block is empty and not initialized. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>size is the count of elements, and not the number of bytes </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00789">789</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afeedb31c4a57af2dc59a1e23cf62ba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeedb31c4a57af2dc59a1e23cf62ba6c">&#9670;&nbsp;</a></span>operator const void *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast operator. </p>
<dl class="section return"><dt>Returns</dt><dd>block pointer cast to <code>const void *</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00811">811</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="ac6453a5b2b481544f7f77bbe3fea0a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6453a5b2b481544f7f77bbe3fea0a78">&#9670;&nbsp;</a></span>operator void *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator void * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast operator. </p>
<dl class="section return"><dt>Returns</dt><dd>block pointer cast to non-const <code>void *</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00817">817</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="ab3b250c34d61acb745ba2eca9c6a61bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b250c34d61acb745ba2eca9c6a61bf">&#9670;&nbsp;</a></span>operator const T *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator const T * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast operator. </p>
<dl class="section return"><dt>Returns</dt><dd>block pointer cast to <code>const T *</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00823">823</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="ab7b3f34a0d3670f8f1358bbd72c74716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b3f34a0d3670f8f1358bbd72c74716">&#9670;&nbsp;</a></span>operator T*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator T* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast operator. </p>
<dl class="section return"><dt>Returns</dt><dd>block pointer cast to non-const <code>T *</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00829">829</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a11a05906688172579cd3520816799446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a05906688172579cd3520816799446">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an iterator pointing to the first element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00836">836</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a18351db729daac209ce017661a0cf6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18351db729daac209ce017661a0cf6e8">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a constant iterator pointing to the first element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>constant iterator pointing to the first element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00841">841</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a26d88ba73b5da0f5dd4ab87ce6345d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d88ba73b5da0f5dd4ab87ce6345d8f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an iterator pointing beyond the last element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing beyond the last element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00846">846</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="ac47c5182bac200930228ef5666b35336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47c5182bac200930228ef5666b35336">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a constant iterator pointing beyond the last element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>constant iterator pointing beyond the last element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00851">851</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a42ad7c28810297ca50b2411284876845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ad7c28810297ca50b2411284876845">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A::pointer <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a pointer to the first element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00857">857</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="acc465230b3c6849565a19d1c7d7f5c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc465230b3c6849565a19d1c7d7f5c1f">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A::const_pointer <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a pointer to the first element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>constant pointer to the first element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00861">861</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="af5999bffe3193e62719cc0792b0282a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5999bffe3193e62719cc0792b0282a7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the count of elements in the <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the memory block </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the return value is the count of elements, and not the number of bytes </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00867">867</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="acf162565508e31bfe5a2eb3946411829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf162565508e31bfe5a2eb3946411829">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if number of elements in the memory block is 0, false otherwise </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00871">871</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a5565f51350846fb7224720c403674216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5565f51350846fb7224720c403674216">&#9670;&nbsp;</a></span>BytePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::BytePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a byte pointer to the first element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>byte pointer to the first element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00876">876</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a565f381f0b133268b77d770bfcfc9a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565f381f0b133268b77d770bfcfc9a09">&#9670;&nbsp;</a></span>BytePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::BytePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a byte pointer to the first element in the memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>constant byte pointer to the first element in the memory block </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00880">880</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a93e1256d8021ba4ab9007ea4e19ae8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e1256d8021ba4ab9007ea4e19ae8c2">&#9670;&nbsp;</a></span>SizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::SizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the number of bytes in the <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in the memory block </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the return value is the number of bytes, and not count of elements. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00885">885</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="aaf38f976508a632e2f74aa4f2622da86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf38f976508a632e2f74aa4f2622da86">&#9670;&nbsp;</a></span>Assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set contents and size from an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to an array of T </td></tr>
    <tr><td class="paramname">len</td><td>the number of elements in the memory block</td></tr>
  </table>
  </dd>
</dl>
<p>The array pointed to by <code>ptr</code> must be distinct from this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> because <a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86" title="Set contents and size from an array.">Assign()</a> calls <a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a> and then std::memcpy(). The call to <a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a> will invalidate all pointers and iterators, like the pointer returned from <a class="el" href="class_sec_block.html#a42ad7c28810297ca50b2411284876845" title="Provides a pointer to the first element in the memory block.">data()</a>.</p>
<p>If the memory block is reduced in size, then the reclaimed memory is set to 0. If an assignment occurs, then <a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86" title="Set contents and size from an array.">Assign()</a> resets the element count after the previous block is zeroized. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00898">898</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a10754ccddd6b2466f647ba23c76d719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10754ccddd6b2466f647ba23c76d719b">&#9670;&nbsp;</a></span>Assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set contents from a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of values to copy </td></tr>
    <tr><td class="paramname">value</td><td>the value, repeated count times</td></tr>
  </table>
  </dd>
</dl>
<p>If the memory block is reduced in size, then the reclaimed memory is set to 0. If an assignment occurs, then <a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86" title="Set contents and size from an array.">Assign()</a> resets the element count after the previous block is zeroized. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00913">913</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a309d571ffb1b7d58185a8309ca58e6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309d571ffb1b7d58185a8309ca58e6b2">&#9670;&nbsp;</a></span>Assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a></td></tr>
  </table>
  </dd>
</dl>
<p>Assign checks for self assignment.</p>
<p>If the memory block is reduced in size, then the reclaimed memory is set to 0. If an assignment occurs, then <a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86" title="Set contents and size from an array.">Assign()</a> resets the element count after the previous block is zeroized. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00928">928</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a1ed5302fd608c7eaa8284c9b07e41f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed5302fd608c7eaa8284c9b07e41f82">&#9670;&nbsp;</a></span>Append() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append contents from an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to an array of T </td></tr>
    <tr><td class="paramname">len</td><td>the number of elements in the memory block </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td>if resulting size would overflow</td></tr>
  </table>
  </dd>
</dl>
<p>The array pointed to by <code>ptr</code> must be distinct from this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> because <a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a> calls <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a> and then std::memcpy(). The call to <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a> will invalidate all pointers and iterators, like the pointer returned from <a class="el" href="class_sec_block.html#a42ad7c28810297ca50b2411284876845" title="Provides a pointer to the first element in the memory block.">data()</a>.</p>
<p><a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a> may be less efficient than a <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> because <a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a> must <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a> the internal array and then copy elements. The <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> can copy elements without growing. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00952">952</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a94c1913495aa3d8c0404bbd674a0ec3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c1913495aa3d8c0404bbd674a0ec3f">&#9670;&nbsp;</a></span>Append() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td>if resulting size would overflow</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> calls <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a> and then appends t.</p>
<p><a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a> may be less efficient than a <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> because <a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a> must <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a> the internal array and then copy elements. The <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> can copy elements without growing. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00973">973</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a7560e98627dc400699adf9c428f5b514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7560e98627dc400699adf9c428f5b514">&#9670;&nbsp;</a></span>Append() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append contents from a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of values to copy </td></tr>
    <tr><td class="paramname">value</td><td>the value, repeated count times </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td>if resulting size would overflow</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> calls <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a> and then appends value.</p>
<p><a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a> may be less efficient than a <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> because <a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a> must <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a> the internal array and then copy elements. The <a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> can copy elements without growing. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_byte_queue.html" title="Data structure used to store byte strings.">ByteQueue</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01004">1004</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="aae276714a804a016747d0e17f0ac76f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae276714a804a016747d0e17f0ac76f2">&#9670;&nbsp;</a></span>SetMark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::SetMark </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of elements to zeroize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of elements</td></tr>
  </table>
  </dd>
</dl>
<p>SetMark is a remediation for Issue 346/CVE-2016-9939 while preserving the streaming interface. The <code>count</code> controls the number of elements zeroized, which can be less than <code>size</code> or 0.</p>
<p>An internal variable, <code>m_mark</code>, is initialized to the maximum number of elements. The maximum number of elements is <code>ELEMS_MAX</code>. Deallocation triggers a zeroization, and the number of elements zeroized is <code>STDMIN(m_size, m_mark)</code>. After zeroization, the memory is returned to the system.</p>
<p>The ASN.1 decoder uses <a class="el" href="class_sec_block.html#aae276714a804a016747d0e17f0ac76f2" title="Sets the number of elements to zeroize.">SetMark()</a> to set the element count to 0 before throwing an exception. In this case, the attacker provides a large BER encoded length (say 64MB) but only a small number of content octets (say 16). If the allocator zeroized all 64MB, then a transient DoS could occur as CPU cycles are spent zeroizing uninitialized memory.</p>
<p>Generally speaking, any operation which changes the size of the <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> results in the mark being reset to <code>ELEMS_MAX</code>. In particular, if <a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86" title="Set contents and size from an array.">Assign()</a>, <a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>, <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a>, <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a>, <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a> are called, then the count is reset to <code>ELEMS_MAX</code>. The list is not exhaustive. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://github.com/weidai11/cryptopp/issues/346">Issue 346/CVE-2016-9939</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01037">1037</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="adb8cdaa95af4f2c8597d01930f90fac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8cdaa95af4f2c8597d01930f90fac2">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt;T, A&gt;&amp; <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a></dd></dl>
<p>Internally, <a class="el" href="class_sec_block.html#adb8cdaa95af4f2c8597d01930f90fac2" title="Assign contents from another SecBlock.">operator=()</a> calls <a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86" title="Set contents and size from an array.">Assign()</a>.</p>
<p>If the memory block is reduced in size, then the reclaimed memory is set to 0. If an assignment occurs, then <a class="el" href="class_sec_block.html#aaf38f976508a632e2f74aa4f2622da86" title="Set contents and size from an array.">Assign()</a> resets the element count after the previous block is zeroized. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01047">1047</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="acf49f5fe6f6c2e1ae8e8c13e9eec38fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49f5fe6f6c2e1ae8e8c13e9eec38fc">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt;T, A&gt;&amp; <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append contents from another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a></dd></dl>
<p>Internally, <a class="el" href="class_sec_block.html#acf49f5fe6f6c2e1ae8e8c13e9eec38fc" title="Append contents from another SecBlock.">operator+=()</a> calls <a class="el" href="class_sec_block.html#a1ed5302fd608c7eaa8284c9b07e41f82" title="Append contents from an array.">Append()</a>. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01059">1059</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a4c641a244b1d12301db043b066968ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c641a244b1d12301db043b066968ffc">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sec_block.html">SecBlock</a>&lt;T, A&gt; <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> from this and another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> that is a concatenation of this and t.</dd></dl>
<p>Internally, a new <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> is created from this and a concatenation of t. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01073">1073</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a7cc30b9a5602c8f8583749de427e355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc30b9a5602c8f8583749de427e355d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise compare two SecBlocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size and bits are equal, false otherwise</dd></dl>
<p>Uses a constant time compare if the arrays are equal size. The constant time compare is <a class="el" href="misc_8h.html#afa9a2f81aa1ca6560a910f31cab02ac9" title="Performs a near constant-time comparison of two equally sized buffers.">VerifyBufsEqual()</a> found in <code><a class="el" href="misc_8h.html" title="Utility functions for the Crypto++ library.">misc.h</a></code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sec_block.html#a6123ec21ad948ffbd947da8064ccec60" title="Bitwise compare two SecBlocks.">operator!=()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01095">1095</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a6123ec21ad948ffbd947da8064ccec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6123ec21ad948ffbd947da8064ccec60">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise compare two SecBlocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the size and bits are equal, false otherwise</dd></dl>
<p>Uses a constant time compare if the arrays are equal size. The constant time compare is <a class="el" href="misc_8h.html#afa9a2f81aa1ca6560a910f31cab02ac9" title="Performs a near constant-time comparison of two equally sized buffers.">VerifyBufsEqual()</a> found in <code><a class="el" href="misc_8h.html" title="Utility functions for the Crypto++ library.">misc.h</a></code>.</p>
<p>Internally, <a class="el" href="class_sec_block.html#a6123ec21ad948ffbd947da8064ccec60" title="Bitwise compare two SecBlocks.">operator!=()</a> returns the inverse of <a class="el" href="class_sec_block.html#a7cc30b9a5602c8f8583749de427e355d" title="Bitwise compare two SecBlocks.">operator==()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sec_block.html#a7cc30b9a5602c8f8583749de427e355d" title="Bitwise compare two SecBlocks.">operator==()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01111">1111</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a90d46e577c951d81a2d25a4742a3e979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d46e577c951d81a2d25a4742a3e979">&#9670;&nbsp;</a></span>New()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::New </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size without preserving contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<p>Old content is not preserved. If the memory block is reduced in size, then the reclaimed content is set to 0. If the memory block grows in size, then the new memory is initialized to 0. <a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a> resets the element count after the previous block is zeroized.</p>
<p>Internally, this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> calls reallocate(). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>, <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a>, <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a>, <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a>, <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01126">1126</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a2d78e75002fd02e5b89bd72a9e65e769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d78e75002fd02e5b89bd72a9e65e769">&#9670;&nbsp;</a></span>CleanNew()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::CleanNew </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size without preserving contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<p>Old content is not preserved. If the memory block is reduced in size, then the reclaimed content is set to 0. If the memory block grows in size, then the new memory is initialized to 0. <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a> resets the element count after the previous block is zeroized.</p>
<p>Internally, this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> calls <a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>, <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a>, <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a>, <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a>, <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01143">1143</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a8dea287fba8236b0979b52beece0ec1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dea287fba8236b0979b52beece0ec1b">&#9670;&nbsp;</a></span>Grow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::Grow </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size and preserve contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<p>Old content is preserved. New content is not initialized.</p>
<p>Internally, this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> calls reallocate() when size must increase. If the size does not increase, then <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a> does not take action. If the size must change, then use <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a>. <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a> resets the element count after the previous block is zeroized. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>, <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a>, <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a>, <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a>, <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a> </dd>
<dd>
<a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>, <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a>, <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a>, <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a>, <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01160">1160</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a4ef9516e973051e6afa38bba526da3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef9516e973051e6afa38bba526da3e9">&#9670;&nbsp;</a></span>CleanGrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::CleanGrow </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size and preserve contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<p>Old content is preserved. New content is initialized to 0.</p>
<p>Internally, this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> calls reallocate() when size must increase. If the size does not increase, then <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a> does not take action. If the size must change, then use <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a>. <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a> resets the element count after the previous block is zeroized. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>, <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a>, <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a>, <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a>, <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01179">1179</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="af9e98d3f4a7af1156fcf3e6e68f4ae5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e98d3f4a7af1156fcf3e6e68f4ae5a">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size and preserve contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<p>Old content is preserved. If the memory block grows in size, then new memory is not initialized. <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a> resets the element count after the previous block is zeroized.</p>
<p>Internally, this <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a> calls reallocate(). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sec_block.html#a90d46e577c951d81a2d25a4742a3e979" title="Change size without preserving contents.">New()</a>, <a class="el" href="class_sec_block.html#a2d78e75002fd02e5b89bd72a9e65e769" title="Change size without preserving contents.">CleanNew()</a>, <a class="el" href="class_sec_block.html#a8dea287fba8236b0979b52beece0ec1b" title="Change size and preserve contents.">Grow()</a>, <a class="el" href="class_sec_block.html#a4ef9516e973051e6afa38bba526da3e9" title="Change size and preserve contents.">CleanGrow()</a>, <a class="el" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="Change size and preserve contents.">resize()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01198">1198</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<a id="a3872f50f03372fa859803971961f02cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3872f50f03372fa859803971961f02cd">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap contents with another <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the other <a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a></td></tr>
  </table>
  </dd>
</dl>
<p>Internally, std::swap() is called on m_alloc, m_size and m_ptr. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l01209">1209</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac637b6a87a1bfd9c7959a225af1efe93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac637b6a87a1bfd9c7959a225af1efe93">&#9670;&nbsp;</a></span>ELEMS_MAX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = AllocatorWithCleanup&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_type <a class="el" href="class_sec_block.html">SecBlock</a>&lt; T, A &gt;::ELEMS_MAX = ...</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the block can hold. </p>
<p><code>ELEMS_MAX</code> is the maximum number of elements the <code><a class="el" href="class_sec_block.html" title="Secure memory block with allocator and cleanup.">SecBlock</a></code> can hold. The value of <code>ELEMS_MAX</code> is <code>SIZE_MAX/sizeof(T)</code>. <code>std::numeric_limits</code> was avoided due to lack of <code>constexpr</code>-ness in C++03 and below. </p><dl class="section note"><dt>Note</dt><dd>In C++03 and below <code>ELEMS_MAX</code> is a static data member of type <code>size_type</code>. In C++11 and above <code>ELEMS_MAX</code> is an <code>enum</code> inheriting from <code>size_type</code>. In both cases <code>ELEMS_MAX</code> can be used before objects are fully constructed, and it does not suffer the limitations of class methods like <code>max_size</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://github.com/weidai11/cryptopp/issues/346">Issue 346/CVE-2016-9939</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="secblock_8h_source.html#l00751">751</a> of file <a class="el" href="secblock_8h_source.html">secblock.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="secblock_8h_source.html">secblock.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 26 2023 03:35:23 for Crypto++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
