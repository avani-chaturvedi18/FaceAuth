<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crypto++: misc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crypto++
   &#160;<span id="projectnumber">8.8</span>
   </div>
   <div id="projectbrief">Free&nbsp;C&#43;&#43;&nbsp;class&nbsp;library&nbsp;of&nbsp;cryptographic&nbsp;schemes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">misc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions for the Crypto++ library.  
<a href="#details">More...</a></p>

<p><a href="misc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_empty.html">Empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_empty.html" title="An Empty class.">Empty</a> class.  <a href="class_empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_holder.html">ObjectHolder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses encapsulation to hide an object in derived classes.  <a href="class_object_holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_not_copyable.html">NotCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures an object is not copyable.  <a href="class_not_copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_new_object.html">NewObject&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object factory function.  <a href="struct_new_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_singleton.html">Singleton&lt; T, F, instance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts the instantiation of a class to one static object without locks.  <a href="class_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_get_block.html">GetBlock&lt; T, B, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="class_get_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_put_block.html">PutBlock&lt; T, B, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="class_put_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_block_get_and_put.html">BlockGetAndPut&lt; T, B, GA, PA &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="struct_block_get_and_put.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_safe_shifter_3_01true_01_4.html">SafeShifter&lt; true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a value in the presence of overflow.  <a href="struct_safe_shifter_3_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_safe_shifter_3_01false_01_4.html">SafeShifter&lt; false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a value in the absence of overflow.  <a href="struct_safe_shifter_3_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3c75bb398badb69c7577b21486f9963f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a3c75bb398badb69c7577b21486f9963f">SIZE_MAX</a>&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:a3c75bb398badb69c7577b21486f9963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum value of a machine word.  <a href="misc_8h.html#a3c75bb398badb69c7577b21486f9963f">More...</a><br /></td></tr>
<tr class="separator:a3c75bb398badb69c7577b21486f9963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b378b1b9b2d4654cc852c088742ba70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a6b378b1b9b2d4654cc852c088742ba70">CRYPTOPP_COMPILE_ASSERT</a>(expr)&#160;&#160;&#160;{ ... }</td></tr>
<tr class="memdesc:a6b378b1b9b2d4654cc852c088742ba70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time assertion.  <a href="misc_8h.html#a6b378b1b9b2d4654cc852c088742ba70">More...</a><br /></td></tr>
<tr class="separator:a6b378b1b9b2d4654cc852c088742ba70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7e4464ea73d6393ebe78f952253426"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a2d7e4464ea73d6393ebe78f952253426">COUNTOF</a>(arr)</td></tr>
<tr class="memdesc:a2d7e4464ea73d6393ebe78f952253426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements in an array.  <a href="misc_8h.html#a2d7e4464ea73d6393ebe78f952253426">More...</a><br /></td></tr>
<tr class="separator:a2d7e4464ea73d6393ebe78f952253426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80492499834e30e0109e1e4a69efee29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a80492499834e30e0109e1e4a69efee29">MEMORY_BARRIER</a>&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:a80492499834e30e0109e1e4a69efee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory barrier.  <a href="misc_8h.html#a80492499834e30e0109e1e4a69efee29">More...</a><br /></td></tr>
<tr class="separator:a80492499834e30e0109e1e4a69efee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1938a2627b812913ac3d50c93fd5f11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ad1938a2627b812913ac3d50c93fd5f11">EnumToInt</a>(v)&#160;&#160;&#160;static_cast&lt;int&gt;(v)</td></tr>
<tr class="memdesc:ad1938a2627b812913ac3d50c93fd5f11"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> value.  <a href="misc_8h.html#ad1938a2627b812913ac3d50c93fd5f11">More...</a><br /></td></tr>
<tr class="separator:ad1938a2627b812913ac3d50c93fd5f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff336cfe214604ffdd1075d94a11f8c5"><td class="memItemLeft" align="right" valign="top"><a id="aff336cfe214604ffdd1075d94a11f8c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RETURN_IF_NONZERO</b>(x)&#160;&#160;&#160;size_t returnedValue = x; if (returnedValue) return returnedValue</td></tr>
<tr class="separator:aff336cfe214604ffdd1075d94a11f8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5d495902796a542084124233281265"><td class="memItemLeft" align="right" valign="top"><a id="afb5d495902796a542084124233281265"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GETBYTE</b>(x,  y)&#160;&#160;&#160;(unsigned int)<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>((x)&gt;&gt;(8*(y)))</td></tr>
<tr class="separator:afb5d495902796a542084124233281265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb110e20bd83872104cf1b5a0d19ff1e"><td class="memItemLeft" align="right" valign="top"><a id="afb110e20bd83872104cf1b5a0d19ff1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_GET_BYTE_AS_BYTE</b>(x,  y)&#160;&#160;&#160;<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>((x)&gt;&gt;(8*(y)))</td></tr>
<tr class="separator:afb110e20bd83872104cf1b5a0d19ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44245f76e0fc08ab8ba76771ef3d9f5"><td class="memItemLeft" align="right" valign="top"><a id="ab44245f76e0fc08ab8ba76771ef3d9f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_1</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+0);}     size_t SS1() {return       sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:ab44245f76e0fc08ab8ba76771ef3d9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca956e0abd7368e25cebeb9513616eca"><td class="memItemLeft" align="right" valign="top"><a id="aca956e0abd7368e25cebeb9513616eca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_2</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS1());} size_t SS2() {return SS1()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:aca956e0abd7368e25cebeb9513616eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a4e24d34c37d65a379bd06a4bf12d2"><td class="memItemLeft" align="right" valign="top"><a id="a48a4e24d34c37d65a379bd06a4bf12d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_3</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS2());} size_t SS3() {return SS2()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a48a4e24d34c37d65a379bd06a4bf12d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8366a854dd78fbaba4da6ace69b3b4"><td class="memItemLeft" align="right" valign="top"><a id="a5e8366a854dd78fbaba4da6ace69b3b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_4</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS3());} size_t SS4() {return SS3()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a5e8366a854dd78fbaba4da6ace69b3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00455e80e440dde3572996227bf0f0"><td class="memItemLeft" align="right" valign="top"><a id="a3d00455e80e440dde3572996227bf0f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_5</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS4());} size_t SS5() {return SS4()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a3d00455e80e440dde3572996227bf0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11940604e7e44c16170ab0bc89e4e8f6"><td class="memItemLeft" align="right" valign="top"><a id="a11940604e7e44c16170ab0bc89e4e8f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_6</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS5());} size_t SS6() {return SS5()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a11940604e7e44c16170ab0bc89e4e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fee2fd43faebed6eac61f1f3d8bc423"><td class="memItemLeft" align="right" valign="top"><a id="a4fee2fd43faebed6eac61f1f3d8bc423"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_7</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS6());} size_t SS7() {return SS6()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a4fee2fd43faebed6eac61f1f3d8bc423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac56e108366ccfa9c5ecf923b52e936"><td class="memItemLeft" align="right" valign="top"><a id="a4ac56e108366ccfa9c5ecf923b52e936"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_8</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS7());} size_t SS8() {return SS7()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a4ac56e108366ccfa9c5ecf923b52e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade27627ae9dfbc2bee30153a513e229c"><td class="memItemLeft" align="right" valign="top"><a id="ade27627ae9dfbc2bee30153a513e229c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCKS_END</b>(i)&#160;&#160;&#160;size_t SST() {return SS##i();} void AllocateBlocks() {m_aggregate.New(SST());} <a class="el" href="class_aligned_sec_byte_block.html">AlignedSecByteBlock</a> m_aggregate;</td></tr>
<tr class="separator:ade27627ae9dfbc2bee30153a513e229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a108a15557c06bfa449e87879f283a268"><td class="memItemLeft" align="right" valign="top"><a id="a108a15557c06bfa449e87879f283a268"></a>
typedef <a class="el" href="cryptlib_8h.html#ad00625e1e5e96656feaf83fd53c1ab4e">LittleEndian</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NativeByteOrder</b></td></tr>
<tr class="separator:a108a15557c06bfa449e87879f283a268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abe16d69257b3c86de97e8b0a9e851771"><td class="memTemplParams" colspan="2">template&lt;typename PTR , typename OFF &gt; </td></tr>
<tr class="memitem:abe16d69257b3c86de97e8b0a9e851771"><td class="memTemplItemLeft" align="right" valign="top">PTR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abe16d69257b3c86de97e8b0a9e851771">PtrAdd</a> (PTR pointer, OFF offset)</td></tr>
<tr class="memdesc:abe16d69257b3c86de97e8b0a9e851771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer with an offset.  <a href="misc_8h.html#abe16d69257b3c86de97e8b0a9e851771">More...</a><br /></td></tr>
<tr class="separator:abe16d69257b3c86de97e8b0a9e851771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e456f139d55e27318ba09d6a06d7960"><td class="memTemplParams" colspan="2">template&lt;typename PTR , typename OFF &gt; </td></tr>
<tr class="memitem:a5e456f139d55e27318ba09d6a06d7960"><td class="memTemplItemLeft" align="right" valign="top">PTR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a5e456f139d55e27318ba09d6a06d7960">PtrSub</a> (PTR pointer, OFF offset)</td></tr>
<tr class="memdesc:a5e456f139d55e27318ba09d6a06d7960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer with an offset.  <a href="misc_8h.html#a5e456f139d55e27318ba09d6a06d7960">More...</a><br /></td></tr>
<tr class="separator:a5e456f139d55e27318ba09d6a06d7960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0afa8559681afcdbe5cd415cbde63e9"><td class="memTemplParams" colspan="2">template&lt;typename PTR &gt; </td></tr>
<tr class="memitem:aa0afa8559681afcdbe5cd415cbde63e9"><td class="memTemplItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aa0afa8559681afcdbe5cd415cbde63e9">PtrDiff</a> (const PTR pointer1, const PTR pointer2)</td></tr>
<tr class="memdesc:aa0afa8559681afcdbe5cd415cbde63e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine pointer difference.  <a href="misc_8h.html#aa0afa8559681afcdbe5cd415cbde63e9">More...</a><br /></td></tr>
<tr class="separator:aa0afa8559681afcdbe5cd415cbde63e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacdab7254aa8a8bd6b56e2abb7b9083"><td class="memTemplParams" colspan="2">template&lt;typename PTR &gt; </td></tr>
<tr class="memitem:acacdab7254aa8a8bd6b56e2abb7b9083"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#acacdab7254aa8a8bd6b56e2abb7b9083">PtrByteDiff</a> (const PTR pointer1, const PTR pointer2)</td></tr>
<tr class="memdesc:acacdab7254aa8a8bd6b56e2abb7b9083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine pointer difference.  <a href="misc_8h.html#acacdab7254aa8a8bd6b56e2abb7b9083">More...</a><br /></td></tr>
<tr class="separator:acacdab7254aa8a8bd6b56e2abb7b9083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb58c82c1e81dd837d38971021a85748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#acb58c82c1e81dd837d38971021a85748">BytePtr</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:acb58c82c1e81dd837d38971021a85748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of a string.  <a href="misc_8h.html#acb58c82c1e81dd837d38971021a85748">More...</a><br /></td></tr>
<tr class="separator:acb58c82c1e81dd837d38971021a85748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1c2b960daa3369caafa9fb86c600df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aeb1c2b960daa3369caafa9fb86c600df">BytePtr</a> (<a class="el" href="class_sec_byte_block.html">SecByteBlock</a> &amp;str)</td></tr>
<tr class="memdesc:aeb1c2b960daa3369caafa9fb86c600df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of a string.  <a href="misc_8h.html#aeb1c2b960daa3369caafa9fb86c600df">More...</a><br /></td></tr>
<tr class="separator:aeb1c2b960daa3369caafa9fb86c600df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7492941085053519baa0065dfd2c4aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#af7492941085053519baa0065dfd2c4aa">ConstBytePtr</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:af7492941085053519baa0065dfd2c4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer to the first element of a string.  <a href="misc_8h.html#af7492941085053519baa0065dfd2c4aa">More...</a><br /></td></tr>
<tr class="separator:af7492941085053519baa0065dfd2c4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3b3accc89a99034ceb3bf02b1800ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8a3b3accc89a99034ceb3bf02b1800ff">ConstBytePtr</a> (const <a class="el" href="class_sec_byte_block.html">SecByteBlock</a> &amp;str)</td></tr>
<tr class="memdesc:a8a3b3accc89a99034ceb3bf02b1800ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer to the first element of a string.  <a href="misc_8h.html#a8a3b3accc89a99034ceb3bf02b1800ff">More...</a><br /></td></tr>
<tr class="separator:a8a3b3accc89a99034ceb3bf02b1800ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eea25739f5000af6c684b8c225c6be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a24eea25739f5000af6c684b8c225c6be">BytePtrSize</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a24eea25739f5000af6c684b8c225c6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a string.  <a href="misc_8h.html#a24eea25739f5000af6c684b8c225c6be">More...</a><br /></td></tr>
<tr class="separator:a24eea25739f5000af6c684b8c225c6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935acdd6640d177065caca6ddbab2ef2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a935acdd6640d177065caca6ddbab2ef2">BytePtrSize</a> (const <a class="el" href="class_sec_byte_block.html">SecByteBlock</a> &amp;str)</td></tr>
<tr class="memdesc:a935acdd6640d177065caca6ddbab2ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a string.  <a href="misc_8h.html#a935acdd6640d177065caca6ddbab2ef2">More...</a><br /></td></tr>
<tr class="separator:a935acdd6640d177065caca6ddbab2ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0">memcpy_s</a> (void *dest, size_t sizeInBytes, const void *src, size_t count)</td></tr>
<tr class="memdesc:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds checking replacement for memcpy()  <a href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0">More...</a><br /></td></tr>
<tr class="separator:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb296eab4ca31ab5c0cf4a932488a8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de">memmove_s</a> (void *dest, size_t sizeInBytes, const void *src, size_t count)</td></tr>
<tr class="memdesc:adb296eab4ca31ab5c0cf4a932488a8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds checking replacement for memmove()  <a href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de">More...</a><br /></td></tr>
<tr class="separator:adb296eab4ca31ab5c0cf4a932488a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810542d642def73fd278c08092417e11"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a810542d642def73fd278c08092417e11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a810542d642def73fd278c08092417e11">vec_swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a810542d642def73fd278c08092417e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two variables which are arrays.  <a href="misc_8h.html#a810542d642def73fd278c08092417e11">More...</a><br /></td></tr>
<tr class="separator:a810542d642def73fd278c08092417e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a62d4efc301af9025df8c98fa8edebf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a0a62d4efc301af9025df8c98fa8edebf">memset_z</a> (void *ptr, int val, size_t num)</td></tr>
<tr class="memdesc:a0a62d4efc301af9025df8c98fa8edebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory block initializer.  <a href="misc_8h.html#a0a62d4efc301af9025df8c98fa8edebf">More...</a><br /></td></tr>
<tr class="separator:a0a62d4efc301af9025df8c98fa8edebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe412b0409249cb54899e97bc7d86424"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abe412b0409249cb54899e97bc7d86424"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abe412b0409249cb54899e97bc7d86424">STDMIN</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:abe412b0409249cb54899e97bc7d86424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement function for std::min.  <a href="misc_8h.html#abe412b0409249cb54899e97bc7d86424">More...</a><br /></td></tr>
<tr class="separator:abe412b0409249cb54899e97bc7d86424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1490597cb11989e78d5ba5b5f21266b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af1490597cb11989e78d5ba5b5f21266b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#af1490597cb11989e78d5ba5b5f21266b">STDMAX</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:af1490597cb11989e78d5ba5b5f21266b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement function for std::max.  <a href="misc_8h.html#af1490597cb11989e78d5ba5b5f21266b">More...</a><br /></td></tr>
<tr class="separator:af1490597cb11989e78d5ba5b5f21266b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memTemplItemLeft" align="right" valign="top">const T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ac8391e7d9d613a6c401787d2cdab1f51">UnsignedMin</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ac8391e7d9d613a6c401787d2cdab1f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe comparison of values that could be negative and incorrectly promoted.  <a href="misc_8h.html#ac8391e7d9d613a6c401787d2cdab1f51">More...</a><br /></td></tr>
<tr class="separator:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2ce94589bb74164d809f4675bd23dd"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a8a2ce94589bb74164d809f4675bd23dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8a2ce94589bb74164d809f4675bd23dd">SafeConvert</a> (T1 from, T2 &amp;to)</td></tr>
<tr class="memdesc:a8a2ce94589bb74164d809f4675bd23dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a8a2ce94589bb74164d809f4675bd23dd">More...</a><br /></td></tr>
<tr class="separator:a8a2ce94589bb74164d809f4675bd23dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9c6fb182e29b6f83218f0277b814ce"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aef9c6fb182e29b6f83218f0277b814ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aef9c6fb182e29b6f83218f0277b814ce">SafeConvert</a> (<a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> from, <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;to)</td></tr>
<tr class="memdesc:aef9c6fb182e29b6f83218f0277b814ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#aef9c6fb182e29b6f83218f0277b814ce">More...</a><br /></td></tr>
<tr class="separator:aef9c6fb182e29b6f83218f0277b814ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7808d89c7ac5c2c77360944dc7369678"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7808d89c7ac5c2c77360944dc7369678"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a7808d89c7ac5c2c77360944dc7369678">SafeConvert</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> from, <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;to)</td></tr>
<tr class="memdesc:a7808d89c7ac5c2c77360944dc7369678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a7808d89c7ac5c2c77360944dc7369678">More...</a><br /></td></tr>
<tr class="separator:a7808d89c7ac5c2c77360944dc7369678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0052b1609559f5e113905d54d429711a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0052b1609559f5e113905d54d429711a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a0052b1609559f5e113905d54d429711a">SafeConvert</a> (<a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> from, <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;to)</td></tr>
<tr class="memdesc:a0052b1609559f5e113905d54d429711a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a0052b1609559f5e113905d54d429711a">More...</a><br /></td></tr>
<tr class="separator:a0052b1609559f5e113905d54d429711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a9b7e594dd086ec2ae625cbcf7fe71b5f">SafeConvert</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> from, <a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> &amp;to)</td></tr>
<tr class="memdesc:a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a9b7e594dd086ec2ae625cbcf7fe71b5f">More...</a><br /></td></tr>
<tr class="separator:a9b7e594dd086ec2ae625cbcf7fe71b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d868daec4a6485ea8393ed87202db2e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3d868daec4a6485ea8393ed87202db2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a3d868daec4a6485ea8393ed87202db2e">SafeConvert</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> from, <a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> &amp;to)</td></tr>
<tr class="memdesc:a3d868daec4a6485ea8393ed87202db2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a3d868daec4a6485ea8393ed87202db2e">More...</a><br /></td></tr>
<tr class="separator:a3d868daec4a6485ea8393ed87202db2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a9752786a04193c6219f18b02050bb"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad0a9752786a04193c6219f18b02050bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ad0a9752786a04193c6219f18b02050bb">SafeConvert</a> (<a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> from, <a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> &amp;to)</td></tr>
<tr class="memdesc:ad0a9752786a04193c6219f18b02050bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#ad0a9752786a04193c6219f18b02050bb">More...</a><br /></td></tr>
<tr class="separator:ad0a9752786a04193c6219f18b02050bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c1d152be686ca1f2e017d226915468"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac7c1d152be686ca1f2e017d226915468"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ac7c1d152be686ca1f2e017d226915468">SafeConvert</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> from, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;to)</td></tr>
<tr class="memdesc:ac7c1d152be686ca1f2e017d226915468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#ac7c1d152be686ca1f2e017d226915468">More...</a><br /></td></tr>
<tr class="separator:ac7c1d152be686ca1f2e017d226915468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe71bd3d318f5b7be175b3f2997208"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9dbe71bd3d318f5b7be175b3f2997208"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a9dbe71bd3d318f5b7be175b3f2997208">SafeConvert</a> (<a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> from, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;to)</td></tr>
<tr class="memdesc:a9dbe71bd3d318f5b7be175b3f2997208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a9dbe71bd3d318f5b7be175b3f2997208">More...</a><br /></td></tr>
<tr class="separator:a9dbe71bd3d318f5b7be175b3f2997208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051380375fe085115451a06b84d68c3d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a051380375fe085115451a06b84d68c3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a051380375fe085115451a06b84d68c3d">SafeConvert</a> (<a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> from, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;to)</td></tr>
<tr class="memdesc:a051380375fe085115451a06b84d68c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a051380375fe085115451a06b84d68c3d">More...</a><br /></td></tr>
<tr class="separator:a051380375fe085115451a06b84d68c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7c3d4c147bee46750037a346059815"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:adb7c3d4c147bee46750037a346059815"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#adb7c3d4c147bee46750037a346059815">SafeConvert</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> from, <a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;to)</td></tr>
<tr class="memdesc:adb7c3d4c147bee46750037a346059815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#adb7c3d4c147bee46750037a346059815">More...</a><br /></td></tr>
<tr class="separator:adb7c3d4c147bee46750037a346059815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8abb585a36d6117ce1c29c54aeab2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a66c8abb585a36d6117ce1c29c54aeab2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a66c8abb585a36d6117ce1c29c54aeab2">SafeConvert</a> (<a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> from, <a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;to)</td></tr>
<tr class="memdesc:a66c8abb585a36d6117ce1c29c54aeab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a66c8abb585a36d6117ce1c29c54aeab2">More...</a><br /></td></tr>
<tr class="separator:a66c8abb585a36d6117ce1c29c54aeab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45edf61e9d5dae4e1062d29d9059297b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a45edf61e9d5dae4e1062d29d9059297b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a45edf61e9d5dae4e1062d29d9059297b">SafeConvert</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> from, <a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;to)</td></tr>
<tr class="memdesc:a45edf61e9d5dae4e1062d29d9059297b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a conversion from <code>from</code> to <code>to</code>.  <a href="misc_8h.html#a45edf61e9d5dae4e1062d29d9059297b">More...</a><br /></td></tr>
<tr class="separator:a45edf61e9d5dae4e1062d29d9059297b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd7decd035cc4e144cd3d395e834106"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6cd7decd035cc4e144cd3d395e834106"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a> (T value, unsigned int base=10)</td></tr>
<tr class="memdesc:a6cd7decd035cc4e144cd3d395e834106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value to a string.  <a href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">More...</a><br /></td></tr>
<tr class="separator:a6cd7decd035cc4e144cd3d395e834106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f4608b867f01a4cad90c5b222f89b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aad4f4608b867f01a4cad90c5b222f89b"><td class="memTemplItemLeft" align="right" valign="top">CRYPTOPP_DLL std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aad4f4608b867f01a4cad90c5b222f89b">IntToString&lt; word64 &gt;</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> value, unsigned int base)</td></tr>
<tr class="memdesc:aad4f4608b867f01a4cad90c5b222f89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned value to a string.  <a href="misc_8h.html#aad4f4608b867f01a4cad90c5b222f89b">More...</a><br /></td></tr>
<tr class="separator:aad4f4608b867f01a4cad90c5b222f89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memTemplItemLeft" align="right" valign="top">CRYPTOPP_DLL std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a1b67e971e2ab82125e3cf2a08a24a103">IntToString&lt; Integer &gt;</a> (<a class="el" href="class_integer.html">Integer</a> value, unsigned int base)</td></tr>
<tr class="memdesc:a1b67e971e2ab82125e3cf2a08a24a103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> to a string.  <a href="misc_8h.html#a1b67e971e2ab82125e3cf2a08a24a103">More...</a><br /></td></tr>
<tr class="separator:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c63a5683602db0ff8975746a414797f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c63a5683602db0ff8975746a414797f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a6c63a5683602db0ff8975746a414797f">Parity</a> (T value)</td></tr>
<tr class="memdesc:a6c63a5683602db0ff8975746a414797f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity of a value.  <a href="misc_8h.html#a6c63a5683602db0ff8975746a414797f">More...</a><br /></td></tr>
<tr class="separator:a6c63a5683602db0ff8975746a414797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a3e22fbd4b8f95aa01bde93ea32e44e82">BytePrecision</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 8-bit bytes or octets required for a value.  <a href="misc_8h.html#a3e22fbd4b8f95aa01bde93ea32e44e82">More...</a><br /></td></tr>
<tr class="separator:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5964768bc94670ad2bc3f218d9367f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c5964768bc94670ad2bc3f218d9367f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a3c5964768bc94670ad2bc3f218d9367f">BitPrecision</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3c5964768bc94670ad2bc3f218d9367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits required for a value.  <a href="misc_8h.html#a3c5964768bc94670ad2bc3f218d9367f">More...</a><br /></td></tr>
<tr class="separator:a3c5964768bc94670ad2bc3f218d9367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495acbd6f3cdabbb4dd863c09b378df4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a495acbd6f3cdabbb4dd863c09b378df4">TrailingZeros</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> v)</td></tr>
<tr class="memdesc:a495acbd6f3cdabbb4dd863c09b378df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of trailing 0-bits in a value.  <a href="misc_8h.html#a495acbd6f3cdabbb4dd863c09b378df4">More...</a><br /></td></tr>
<tr class="separator:a495acbd6f3cdabbb4dd863c09b378df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb4df9b2f1e119d89a1573338c4eda6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#addb4df9b2f1e119d89a1573338c4eda6">TrailingZeros</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> v)</td></tr>
<tr class="memdesc:addb4df9b2f1e119d89a1573338c4eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of trailing 0-bits in a value.  <a href="misc_8h.html#addb4df9b2f1e119d89a1573338c4eda6">More...</a><br /></td></tr>
<tr class="separator:addb4df9b2f1e119d89a1573338c4eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616a7f0365c4947b0c8a44606c525a62"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a616a7f0365c4947b0c8a44606c525a62"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a616a7f0365c4947b0c8a44606c525a62">Crop</a> (T value, size_t bits)</td></tr>
<tr class="memdesc:a616a7f0365c4947b0c8a44606c525a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the value to the specified number of bits.  <a href="misc_8h.html#a616a7f0365c4947b0c8a44606c525a62">More...</a><br /></td></tr>
<tr class="separator:a616a7f0365c4947b0c8a44606c525a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a7c5d30b17c9d4869fdc3458dd05c500d">BitsToBytes</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 8-bit bytes or octets required for the specified number of bits.  <a href="misc_8h.html#a7c5d30b17c9d4869fdc3458dd05c500d">More...</a><br /></td></tr>
<tr class="separator:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886cc7ce76578c6df939f564f676e71a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a886cc7ce76578c6df939f564f676e71a">BytesToWords</a> (size_t byteCount)</td></tr>
<tr class="memdesc:a886cc7ce76578c6df939f564f676e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words required for the specified number of bytes.  <a href="misc_8h.html#a886cc7ce76578c6df939f564f676e71a">More...</a><br /></td></tr>
<tr class="separator:a886cc7ce76578c6df939f564f676e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c56601a8c94b6a37a21657929fe928"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a45c56601a8c94b6a37a21657929fe928">BitsToWords</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a45c56601a8c94b6a37a21657929fe928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words required for the specified number of bits.  <a href="misc_8h.html#a45c56601a8c94b6a37a21657929fe928">More...</a><br /></td></tr>
<tr class="separator:a45c56601a8c94b6a37a21657929fe928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a778d13f3d45915e1bc5c0ab1801ea6ad">BitsToDwords</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of double words required for the specified number of bits.  <a href="misc_8h.html#a778d13f3d45915e1bc5c0ab1801ea6ad">More...</a><br /></td></tr>
<tr class="separator:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5daf6ca2cdd0e0dfdaac5662450db9"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#afe5daf6ca2cdd0e0dfdaac5662450db9">xorbuf</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mask, size_t count)</td></tr>
<tr class="memdesc:afe5daf6ca2cdd0e0dfdaac5662450db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an XOR of a buffer with a mask.  <a href="misc_8h.html#afe5daf6ca2cdd0e0dfdaac5662450db9">More...</a><br /></td></tr>
<tr class="separator:afe5daf6ca2cdd0e0dfdaac5662450db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa144ba0eaeff3caf15d1ed11732c5da0"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aa144ba0eaeff3caf15d1ed11732c5da0">xorbuf</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *output, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *input, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mask, size_t count)</td></tr>
<tr class="memdesc:aa144ba0eaeff3caf15d1ed11732c5da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an XOR of an input buffer with a mask and stores the result in an output buffer.  <a href="misc_8h.html#aa144ba0eaeff3caf15d1ed11732c5da0">More...</a><br /></td></tr>
<tr class="separator:aa144ba0eaeff3caf15d1ed11732c5da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9a2f81aa1ca6560a910f31cab02ac9"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#afa9a2f81aa1ca6560a910f31cab02ac9">VerifyBufsEqual</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf1, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf2, size_t count)</td></tr>
<tr class="memdesc:afa9a2f81aa1ca6560a910f31cab02ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a near constant-time comparison of two equally sized buffers.  <a href="misc_8h.html#afa9a2f81aa1ca6560a910f31cab02ac9">More...</a><br /></td></tr>
<tr class="separator:afa9a2f81aa1ca6560a910f31cab02ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65531618a7eca8803fa9e9287c43aafc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a65531618a7eca8803fa9e9287c43aafc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a65531618a7eca8803fa9e9287c43aafc">IsPowerOf2</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a65531618a7eca8803fa9e9287c43aafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a value is a power of 2.  <a href="misc_8h.html#a65531618a7eca8803fa9e9287c43aafc">More...</a><br /></td></tr>
<tr class="separator:a65531618a7eca8803fa9e9287c43aafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b8be26ba8900662fa86dcea6d831f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a67b8be26ba8900662fa86dcea6d831f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a67b8be26ba8900662fa86dcea6d831f9">NumericLimitsMin</a> ()</td></tr>
<tr class="memdesc:a67b8be26ba8900662fa86dcea6d831f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the minimum value for a type.  <a href="misc_8h.html#a67b8be26ba8900662fa86dcea6d831f9">More...</a><br /></td></tr>
<tr class="separator:a67b8be26ba8900662fa86dcea6d831f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#af39f468338a6ad6a22fa0e9c16819fa7">NumericLimitsMax</a> ()</td></tr>
<tr class="memdesc:af39f468338a6ad6a22fa0e9c16819fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the maximum value for a type.  <a href="misc_8h.html#af39f468338a6ad6a22fa0e9c16819fa7">More...</a><br /></td></tr>
<tr class="separator:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9252be0b76b4b9d9fdbc11a8e7040e44"><td class="memItemLeft" align="right" valign="top"><a id="a9252be0b76b4b9d9fdbc11a8e7040e44"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9252be0b76b4b9d9fdbc11a8e7040e44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NumericLimitsMin</b> ()</td></tr>
<tr class="separator:a9252be0b76b4b9d9fdbc11a8e7040e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9319c4bb8bd961f3cd684a4ea182f5f"><td class="memItemLeft" align="right" valign="top"><a id="ac9319c4bb8bd961f3cd684a4ea182f5f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac9319c4bb8bd961f3cd684a4ea182f5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NumericLimitsMax</b> ()</td></tr>
<tr class="separator:ac9319c4bb8bd961f3cd684a4ea182f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30712a90999ad9d9152975f2e92d46b8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a30712a90999ad9d9152975f2e92d46b8"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a30712a90999ad9d9152975f2e92d46b8">SaturatingSubtract</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a30712a90999ad9d9152975f2e92d46b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a saturating subtract clamped at 0.  <a href="misc_8h.html#a30712a90999ad9d9152975f2e92d46b8">More...</a><br /></td></tr>
<tr class="separator:a30712a90999ad9d9152975f2e92d46b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39d67faef904dbb474981762b7ebe1"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afd39d67faef904dbb474981762b7ebe1"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#afd39d67faef904dbb474981762b7ebe1">SaturatingSubtract1</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:afd39d67faef904dbb474981762b7ebe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a saturating subtract clamped at 1.  <a href="misc_8h.html#afd39d67faef904dbb474981762b7ebe1">More...</a><br /></td></tr>
<tr class="separator:afd39d67faef904dbb474981762b7ebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621695f6346d6a745e340513d917b31a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a621695f6346d6a745e340513d917b31a"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a621695f6346d6a745e340513d917b31a">ModPowerOf2</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a621695f6346d6a745e340513d917b31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a value to a power of 2.  <a href="misc_8h.html#a621695f6346d6a745e340513d917b31a">More...</a><br /></td></tr>
<tr class="separator:a621695f6346d6a745e340513d917b31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac57210cb6796eced074e6d2e294fb"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aa2ac57210cb6796eced074e6d2e294fb"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aa2ac57210cb6796eced074e6d2e294fb">RoundDownToMultipleOf</a> (const T1 &amp;n, const T2 &amp;m)</td></tr>
<tr class="memdesc:aa2ac57210cb6796eced074e6d2e294fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a value down to a multiple of a second value.  <a href="misc_8h.html#aa2ac57210cb6796eced074e6d2e294fb">More...</a><br /></td></tr>
<tr class="separator:aa2ac57210cb6796eced074e6d2e294fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a219d44f45272a1f3b3f17a656000a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a57a219d44f45272a1f3b3f17a656000a"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a57a219d44f45272a1f3b3f17a656000a">RoundUpToMultipleOf</a> (const T1 &amp;n, const T2 &amp;m)</td></tr>
<tr class="memdesc:a57a219d44f45272a1f3b3f17a656000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a value up to a multiple of a second value.  <a href="misc_8h.html#a57a219d44f45272a1f3b3f17a656000a">More...</a><br /></td></tr>
<tr class="separator:a57a219d44f45272a1f3b3f17a656000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e438054095c88f0c4d9eda7efc584d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4e438054095c88f0c4d9eda7efc584d"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab4e438054095c88f0c4d9eda7efc584d">GetAlignmentOf</a> ()</td></tr>
<tr class="memdesc:ab4e438054095c88f0c4d9eda7efc584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum alignment requirements of a type.  <a href="misc_8h.html#ab4e438054095c88f0c4d9eda7efc584d">More...</a><br /></td></tr>
<tr class="separator:ab4e438054095c88f0c4d9eda7efc584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726c3b76265182681f5d5fd173ab5676"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a726c3b76265182681f5d5fd173ab5676">IsAlignedOn</a> (const void *ptr, unsigned int alignment)</td></tr>
<tr class="memdesc:a726c3b76265182681f5d5fd173ab5676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether ptr is aligned to a minimum value.  <a href="misc_8h.html#a726c3b76265182681f5d5fd173ab5676">More...</a><br /></td></tr>
<tr class="separator:a726c3b76265182681f5d5fd173ab5676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2c95659d16a971941622625c9102ae"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8b2c95659d16a971941622625c9102ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8b2c95659d16a971941622625c9102ae">IsAligned</a> (const void *ptr)</td></tr>
<tr class="memdesc:a8b2c95659d16a971941622625c9102ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether ptr is minimally aligned.  <a href="misc_8h.html#a8b2c95659d16a971941622625c9102ae">More...</a><br /></td></tr>
<tr class="separator:a8b2c95659d16a971941622625c9102ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8336b0d98f2469441837be6cbbebf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aed8336b0d98f2469441837be6cbbebf9">GetNativeByteOrder</a> ()</td></tr>
<tr class="memdesc:aed8336b0d98f2469441837be6cbbebf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NativeByteOrder as an enumerated ByteOrder value.  <a href="misc_8h.html#aed8336b0d98f2469441837be6cbbebf9">More...</a><br /></td></tr>
<tr class="separator:aed8336b0d98f2469441837be6cbbebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2da0dd866619761e63c3b5da58c477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a6c2da0dd866619761e63c3b5da58c477">NativeByteOrderIs</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order)</td></tr>
<tr class="memdesc:a6c2da0dd866619761e63c3b5da58c477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether order follows native byte ordering.  <a href="misc_8h.html#a6c2da0dd866619761e63c3b5da58c477">More...</a><br /></td></tr>
<tr class="separator:a6c2da0dd866619761e63c3b5da58c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade22f7ed542b3db2912c917f8e3d6067"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ade22f7ed542b3db2912c917f8e3d6067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="cryptlib_8h.html#a353ccabf5ddc119a6a33e92f7b9961c7">CipherDir</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ade22f7ed542b3db2912c917f8e3d6067">GetCipherDir</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:ade22f7ed542b3db2912c917f8e3d6067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direction the cipher is being operated.  <a href="misc_8h.html#ade22f7ed542b3db2912c917f8e3d6067">More...</a><br /></td></tr>
<tr class="separator:ade22f7ed542b3db2912c917f8e3d6067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a44fad9d8c25e8aca3a7ee29345516f0a">IncrementCounterByOne</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *inout, unsigned int size)</td></tr>
<tr class="memdesc:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition with carry on a block of bytes.  <a href="misc_8h.html#a44fad9d8c25e8aca3a7ee29345516f0a">More...</a><br /></td></tr>
<tr class="separator:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f852960b51e106a849781341cb2055c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a2f852960b51e106a849781341cb2055c">IncrementCounterByOne</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *output, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *input, unsigned int size)</td></tr>
<tr class="memdesc:a2f852960b51e106a849781341cb2055c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition with carry on a block of bytes.  <a href="misc_8h.html#a2f852960b51e106a849781341cb2055c">More...</a><br /></td></tr>
<tr class="separator:a2f852960b51e106a849781341cb2055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e5659910553da22f9b1e877cddc07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae71e5659910553da22f9b1e877cddc07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ae71e5659910553da22f9b1e877cddc07">ConditionalSwap</a> (bool c, T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:ae71e5659910553da22f9b1e877cddc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a branch-less swap of values a and b if condition c is true.  <a href="misc_8h.html#ae71e5659910553da22f9b1e877cddc07">More...</a><br /></td></tr>
<tr class="separator:ae71e5659910553da22f9b1e877cddc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e4522b268f9ee2e188606c2101d5a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a513e4522b268f9ee2e188606c2101d5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a513e4522b268f9ee2e188606c2101d5a">ConditionalSwapPointers</a> (bool c, T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a513e4522b268f9ee2e188606c2101d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a branch-less swap of pointers a and b if condition c is true.  <a href="misc_8h.html#a513e4522b268f9ee2e188606c2101d5a">More...</a><br /></td></tr>
<tr class="separator:a513e4522b268f9ee2e188606c2101d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f38b8d0440981f5f013ada782018c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a656f38b8d0440981f5f013ada782018c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a656f38b8d0440981f5f013ada782018c">SecureWipeBuffer</a> (T *buf, size_t n)</td></tr>
<tr class="memdesc:a656f38b8d0440981f5f013ada782018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of an array to 0.  <a href="misc_8h.html#a656f38b8d0440981f5f013ada782018c">More...</a><br /></td></tr>
<tr class="separator:a656f38b8d0440981f5f013ada782018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300c13f20ed72b4562e491a5fb56091"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1300c13f20ed72b4562e491a5fb56091"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a1300c13f20ed72b4562e491a5fb56091">SecureWipeBuffer</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, size_t n)</td></tr>
<tr class="memdesc:a1300c13f20ed72b4562e491a5fb56091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each byte of an array to 0.  <a href="misc_8h.html#a1300c13f20ed72b4562e491a5fb56091">More...</a><br /></td></tr>
<tr class="separator:a1300c13f20ed72b4562e491a5fb56091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea79270fd6a206aee58511fb27dba855"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aea79270fd6a206aee58511fb27dba855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aea79270fd6a206aee58511fb27dba855">SecureWipeBuffer</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> *buf, size_t n)</td></tr>
<tr class="memdesc:aea79270fd6a206aee58511fb27dba855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each 16-bit element of an array to 0.  <a href="misc_8h.html#aea79270fd6a206aee58511fb27dba855">More...</a><br /></td></tr>
<tr class="separator:aea79270fd6a206aee58511fb27dba855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee79afe16b5c406876601977ced0d5e2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aee79afe16b5c406876601977ced0d5e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aee79afe16b5c406876601977ced0d5e2">SecureWipeBuffer</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> *buf, size_t n)</td></tr>
<tr class="memdesc:aee79afe16b5c406876601977ced0d5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each 32-bit element of an array to 0.  <a href="misc_8h.html#aee79afe16b5c406876601977ced0d5e2">More...</a><br /></td></tr>
<tr class="separator:aee79afe16b5c406876601977ced0d5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31349ed51eb9be430453214a3ba8422"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af31349ed51eb9be430453214a3ba8422"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#af31349ed51eb9be430453214a3ba8422">SecureWipeBuffer</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> *buf, size_t n)</td></tr>
<tr class="memdesc:af31349ed51eb9be430453214a3ba8422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each 64-bit element of an array to 0.  <a href="misc_8h.html#af31349ed51eb9be430453214a3ba8422">More...</a><br /></td></tr>
<tr class="separator:af31349ed51eb9be430453214a3ba8422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4994f3480634e5f1435fd71f9b652c38"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4994f3480634e5f1435fd71f9b652c38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a4994f3480634e5f1435fd71f9b652c38">SecureWipeArray</a> (T *buf, size_t n)</td></tr>
<tr class="memdesc:a4994f3480634e5f1435fd71f9b652c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of an array to 0.  <a href="misc_8h.html#a4994f3480634e5f1435fd71f9b652c38">More...</a><br /></td></tr>
<tr class="separator:a4994f3480634e5f1435fd71f9b652c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ed56f8a15d6dabbef74390eda4352"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aba2ed56f8a15d6dabbef74390eda4352">StringNarrow</a> (const wchar_t *str, bool throwOnError=true)</td></tr>
<tr class="memdesc:aba2ed56f8a15d6dabbef74390eda4352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a wide character C-string to a multibyte string.  <a href="misc_8h.html#aba2ed56f8a15d6dabbef74390eda4352">More...</a><br /></td></tr>
<tr class="separator:aba2ed56f8a15d6dabbef74390eda4352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95ff706a83782e3d18a3d14817db932"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ac95ff706a83782e3d18a3d14817db932">StringWiden</a> (const char *str, bool throwOnError=true)</td></tr>
<tr class="memdesc:ac95ff706a83782e3d18a3d14817db932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a multibyte C-string to a wide character string.  <a href="misc_8h.html#ac95ff706a83782e3d18a3d14817db932">More...</a><br /></td></tr>
<tr class="separator:ac95ff706a83782e3d18a3d14817db932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab6928faa40f6e56e7f4817d5d65a38"><td class="memTemplParams" colspan="2">template&lt;unsigned int R, class T &gt; </td></tr>
<tr class="memitem:a0ab6928faa40f6e56e7f4817d5d65a38"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38">rotlConstant</a> (T x)</td></tr>
<tr class="memdesc:a0ab6928faa40f6e56e7f4817d5d65a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <a href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38">More...</a><br /></td></tr>
<tr class="separator:a0ab6928faa40f6e56e7f4817d5d65a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d777068849add4c7ab87f7b0683ef65"><td class="memTemplParams" colspan="2">template&lt;unsigned int R, class T &gt; </td></tr>
<tr class="memitem:a7d777068849add4c7ab87f7b0683ef65"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65">rotrConstant</a> (T x)</td></tr>
<tr class="memdesc:a7d777068849add4c7ab87f7b0683ef65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <a href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65">More...</a><br /></td></tr>
<tr class="separator:a7d777068849add4c7ab87f7b0683ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98">rotlFixed</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <a href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98">More...</a><br /></td></tr>
<tr class="separator:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88e95400925b89c94641916535b6da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abf88e95400925b89c94641916535b6da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da">rotrFixed</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:abf88e95400925b89c94641916535b6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <a href="misc_8h.html#abf88e95400925b89c94641916535b6da">More...</a><br /></td></tr>
<tr class="separator:abf88e95400925b89c94641916535b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de05253683b27a221e6465b3a7453b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0de05253683b27a221e6465b3a7453b2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2">rotlVariable</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:a0de05253683b27a221e6465b3a7453b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <a href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2">More...</a><br /></td></tr>
<tr class="separator:a0de05253683b27a221e6465b3a7453b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd053d245fe902fe55bfd8a335634110"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abd053d245fe902fe55bfd8a335634110"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110">rotrVariable</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:abd053d245fe902fe55bfd8a335634110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <a href="misc_8h.html#abd053d245fe902fe55bfd8a335634110">More...</a><br /></td></tr>
<tr class="separator:abd053d245fe902fe55bfd8a335634110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31fe5d559d014085c6a49594b817196"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad31fe5d559d014085c6a49594b817196"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ad31fe5d559d014085c6a49594b817196">rotlMod</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:ad31fe5d559d014085c6a49594b817196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <a href="misc_8h.html#ad31fe5d559d014085c6a49594b817196">More...</a><br /></td></tr>
<tr class="separator:ad31fe5d559d014085c6a49594b817196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc34eb834dd2424407d5e4d729594e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8fc34eb834dd2424407d5e4d729594e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ae8fc34eb834dd2424407d5e4d729594e">rotrMod</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:ae8fc34eb834dd2424407d5e4d729594e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <a href="misc_8h.html#ae8fc34eb834dd2424407d5e4d729594e">More...</a><br /></td></tr>
<tr class="separator:ae8fc34eb834dd2424407d5e4d729594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ceb73851e757cb436cdbaa0242219"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a2ceb73851e757cb436cdbaa0242219"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a9a2ceb73851e757cb436cdbaa0242219">GetByte</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T value, unsigned int index)</td></tr>
<tr class="memdesc:a9a2ceb73851e757cb436cdbaa0242219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a byte from a value.  <a href="misc_8h.html#a9a2ceb73851e757cb436cdbaa0242219">More...</a><br /></td></tr>
<tr class="separator:a9a2ceb73851e757cb436cdbaa0242219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8d5adca8384ebedc699760ce217b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a1d8d5adca8384ebedc699760ce217b08">ByteReverse</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> value)</td></tr>
<tr class="memdesc:a1d8d5adca8384ebedc699760ce217b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 8-bit value.  <a href="misc_8h.html#a1d8d5adca8384ebedc699760ce217b08">More...</a><br /></td></tr>
<tr class="separator:a1d8d5adca8384ebedc699760ce217b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa179e009cf5c74bb431b3c112d7ee444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aa179e009cf5c74bb431b3c112d7ee444">ByteReverse</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value)</td></tr>
<tr class="memdesc:aa179e009cf5c74bb431b3c112d7ee444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 16-bit value.  <a href="misc_8h.html#aa179e009cf5c74bb431b3c112d7ee444">More...</a><br /></td></tr>
<tr class="separator:aa179e009cf5c74bb431b3c112d7ee444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf65f4a9edb6224d01e900aa7205a4f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#acf65f4a9edb6224d01e900aa7205a4f4">ByteReverse</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value)</td></tr>
<tr class="memdesc:acf65f4a9edb6224d01e900aa7205a4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 32-bit value.  <a href="misc_8h.html#acf65f4a9edb6224d01e900aa7205a4f4">More...</a><br /></td></tr>
<tr class="separator:acf65f4a9edb6224d01e900aa7205a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47686f3b4957541a58a3b280d1a89d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a47686f3b4957541a58a3b280d1a89d4c">ByteReverse</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> value)</td></tr>
<tr class="memdesc:a47686f3b4957541a58a3b280d1a89d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 64-bit value.  <a href="misc_8h.html#a47686f3b4957541a58a3b280d1a89d4c">More...</a><br /></td></tr>
<tr class="separator:a47686f3b4957541a58a3b280d1a89d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5688cbe51450ce2090636cdd9090ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#afd5688cbe51450ce2090636cdd9090ca">ByteReverse</a> (<a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a> value)</td></tr>
<tr class="memdesc:afd5688cbe51450ce2090636cdd9090ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 128-bit value.  <a href="misc_8h.html#afd5688cbe51450ce2090636cdd9090ca">More...</a><br /></td></tr>
<tr class="separator:afd5688cbe51450ce2090636cdd9090ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a1746e70bf831f0cbf8ad73d8c15bc921">BitReverse</a> (<a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> value)</td></tr>
<tr class="memdesc:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 8-bit value.  <a href="misc_8h.html#a1746e70bf831f0cbf8ad73d8c15bc921">More...</a><br /></td></tr>
<tr class="separator:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699c24d7013f20ee03076576984c875e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a699c24d7013f20ee03076576984c875e">BitReverse</a> (<a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value)</td></tr>
<tr class="memdesc:a699c24d7013f20ee03076576984c875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 16-bit value.  <a href="misc_8h.html#a699c24d7013f20ee03076576984c875e">More...</a><br /></td></tr>
<tr class="separator:a699c24d7013f20ee03076576984c875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aad87ebeafa7de2c11c19453f3b3cfea7">BitReverse</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value)</td></tr>
<tr class="memdesc:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 32-bit value.  <a href="misc_8h.html#aad87ebeafa7de2c11c19453f3b3cfea7">More...</a><br /></td></tr>
<tr class="separator:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336c0289dcd2670e6b4079fa98018d7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a336c0289dcd2670e6b4079fa98018d7a">BitReverse</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> value)</td></tr>
<tr class="memdesc:a336c0289dcd2670e6b4079fa98018d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 64-bit value.  <a href="misc_8h.html#a336c0289dcd2670e6b4079fa98018d7a">More...</a><br /></td></tr>
<tr class="separator:a336c0289dcd2670e6b4079fa98018d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a641ecc1d620ac8c04bc43661a2bbba71">BitReverse</a> (T value)</td></tr>
<tr class="memdesc:a641ecc1d620ac8c04bc43661a2bbba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a value.  <a href="misc_8h.html#a641ecc1d620ac8c04bc43661a2bbba71">More...</a><br /></td></tr>
<tr class="separator:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8e499ded4f2e7e7705c3cfd39cdf137f">ConditionalByteReverse</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T value)</td></tr>
<tr class="memdesc:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a value depending upon endianness.  <a href="misc_8h.html#a8e499ded4f2e7e7705c3cfd39cdf137f">More...</a><br /></td></tr>
<tr class="separator:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab95e030e0abd33ea360d75cd9c4c8bbe">ByteReverse</a> (T *out, const T *in, size_t byteCount)</td></tr>
<tr class="memdesc:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in an element from an array of elements.  <a href="misc_8h.html#ab95e030e0abd33ea360d75cd9c4c8bbe">More...</a><br /></td></tr>
<tr class="separator:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0de65c1758668440f71a8ff6534ad9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aae0de65c1758668440f71a8ff6534ad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aae0de65c1758668440f71a8ff6534ad9">ConditionalByteReverse</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T *out, const T *in, size_t byteCount)</td></tr>
<tr class="memdesc:aae0de65c1758668440f71a8ff6534ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally reverses bytes in an element from an array of elements.  <a href="misc_8h.html#aae0de65c1758668440f71a8ff6534ad9">More...</a><br /></td></tr>
<tr class="separator:aae0de65c1758668440f71a8ff6534ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e347e6efedee4099dac8b3956350e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a929e347e6efedee4099dac8b3956350e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a929e347e6efedee4099dac8b3956350e">GetUserKey</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T *out, size_t outlen, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *in, size_t inlen)</td></tr>
<tr class="memdesc:a929e347e6efedee4099dac8b3956350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes in a buffer to an array of elements in big-endian order.  <a href="misc_8h.html#a929e347e6efedee4099dac8b3956350e">More...</a><br /></td></tr>
<tr class="separator:a929e347e6efedee4099dac8b3956350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ded795b6a29f00d160d123480d279d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab4ded795b6a29f00d160d123480d279d">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *unused)</td></tr>
<tr class="memdesc:ab4ded795b6a29f00d160d123480d279d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a byte from an unaligned buffer.  <a href="misc_8h.html#ab4ded795b6a29f00d160d123480d279d">More...</a><br /></td></tr>
<tr class="separator:ab4ded795b6a29f00d160d123480d279d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30f251bbb592f2d1621d8c37dffcf8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aa30f251bbb592f2d1621d8c37dffcf8a">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> *unused)</td></tr>
<tr class="memdesc:aa30f251bbb592f2d1621d8c37dffcf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a word16 from an unaligned buffer.  <a href="misc_8h.html#aa30f251bbb592f2d1621d8c37dffcf8a">More...</a><br /></td></tr>
<tr class="separator:aa30f251bbb592f2d1621d8c37dffcf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c7e2905abe7b50b0c49f78ea7fcb71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ad7c7e2905abe7b50b0c49f78ea7fcb71">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> *unused)</td></tr>
<tr class="memdesc:ad7c7e2905abe7b50b0c49f78ea7fcb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a word32 from an unaligned buffer.  <a href="misc_8h.html#ad7c7e2905abe7b50b0c49f78ea7fcb71">More...</a><br /></td></tr>
<tr class="separator:ad7c7e2905abe7b50b0c49f78ea7fcb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6f65b550c7f363ba6d36ab1f5323c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8d6f65b550c7f363ba6d36ab1f5323c5">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> *unused)</td></tr>
<tr class="memdesc:a8d6f65b550c7f363ba6d36ab1f5323c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a word64 from an unaligned buffer.  <a href="misc_8h.html#a8d6f65b550c7f363ba6d36ab1f5323c5">More...</a><br /></td></tr>
<tr class="separator:a8d6f65b550c7f363ba6d36ab1f5323c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebca16db3f44f16bf6c21b12ad0b641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aeebca16db3f44f16bf6c21b12ad0b641">UnalignedGetWordNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, const <a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a> *unused)</td></tr>
<tr class="memdesc:aeebca16db3f44f16bf6c21b12ad0b641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a word128 from an unaligned buffer.  <a href="misc_8h.html#aeebca16db3f44f16bf6c21b12ad0b641">More...</a><br /></td></tr>
<tr class="separator:aeebca16db3f44f16bf6c21b12ad0b641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8184a77f9a4c8ffbda9622b1cee7a148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8184a77f9a4c8ffbda9622b1cee7a148">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:a8184a77f9a4c8ffbda9622b1cee7a148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an unaligned buffer.  <a href="misc_8h.html#a8184a77f9a4c8ffbda9622b1cee7a148">More...</a><br /></td></tr>
<tr class="separator:a8184a77f9a4c8ffbda9622b1cee7a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b43699857ac54a8f4624c89bb6ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ac26b43699857ac54a8f4624c89bb6ab9">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:ac26b43699857ac54a8f4624c89bb6ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a word16 to an unaligned buffer.  <a href="misc_8h.html#ac26b43699857ac54a8f4624c89bb6ab9">More...</a><br /></td></tr>
<tr class="separator:ac26b43699857ac54a8f4624c89bb6ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9d0bbf3f776108244b5c36ff5041d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aef9d0bbf3f776108244b5c36ff5041d5">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:aef9d0bbf3f776108244b5c36ff5041d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a word32 to an unaligned buffer.  <a href="misc_8h.html#aef9d0bbf3f776108244b5c36ff5041d5">More...</a><br /></td></tr>
<tr class="separator:aef9d0bbf3f776108244b5c36ff5041d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bf3fa1752839aa454537cd2d3ca935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a36bf3fa1752839aa454537cd2d3ca935">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:a36bf3fa1752839aa454537cd2d3ca935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a word64 to an unaligned buffer.  <a href="misc_8h.html#a36bf3fa1752839aa454537cd2d3ca935">More...</a><br /></td></tr>
<tr class="separator:a36bf3fa1752839aa454537cd2d3ca935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d99806846ea2985b58a80497d8bfb73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a4d99806846ea2985b58a80497d8bfb73">UnalignedbyteNonTemplate</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, <a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a> value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock)</td></tr>
<tr class="memdesc:a4d99806846ea2985b58a80497d8bfb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a word128 to an unaligned buffer.  <a href="misc_8h.html#a4d99806846ea2985b58a80497d8bfb73">More...</a><br /></td></tr>
<tr class="separator:a4d99806846ea2985b58a80497d8bfb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240e8e97f964626508362b59b78532d3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a240e8e97f964626508362b59b78532d3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a240e8e97f964626508362b59b78532d3">GetWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block)</td></tr>
<tr class="memdesc:a240e8e97f964626508362b59b78532d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="misc_8h.html#a240e8e97f964626508362b59b78532d3">More...</a><br /></td></tr>
<tr class="separator:a240e8e97f964626508362b59b78532d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a4546cdeeecddedd3a0f784ea6b80c8bd">GetWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T &amp;result, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block)</td></tr>
<tr class="memdesc:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="misc_8h.html#a4546cdeeecddedd3a0f784ea6b80c8bd">More...</a><br /></td></tr>
<tr class="separator:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6a8d35198f71ff68811bacd599c664"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aef6a8d35198f71ff68811bacd599c664"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aef6a8d35198f71ff68811bacd599c664">PutWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *block, T value, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *xorBlock=NULL)</td></tr>
<tr class="memdesc:aef6a8d35198f71ff68811bacd599c664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="misc_8h.html#aef6a8d35198f71ff68811bacd599c664">More...</a><br /></td></tr>
<tr class="separator:aef6a8d35198f71ff68811bacd599c664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a18a35b59a1f2e23b94ed2f74f0594613">WordToString</a> (T value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a18a35b59a1f2e23b94ed2f74f0594613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a word to a string.  <a href="misc_8h.html#a18a35b59a1f2e23b94ed2f74f0594613">More...</a><br /></td></tr>
<tr class="separator:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23234e96107b28512db9467c33f67590"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a23234e96107b28512db9467c33f67590"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a23234e96107b28512db9467c33f67590">StringToWord</a> (const std::string &amp;str, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a23234e96107b28512db9467c33f67590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a word.  <a href="misc_8h.html#a23234e96107b28512db9467c33f67590">More...</a><br /></td></tr>
<tr class="separator:a23234e96107b28512db9467c33f67590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda5071e4c754b612b6a4c42be421312"><td class="memTemplParams" colspan="2">template&lt;unsigned int bits, class T &gt; </td></tr>
<tr class="memitem:abda5071e4c754b612b6a4c42be421312"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abda5071e4c754b612b6a4c42be421312">SafeRightShift</a> (T value)</td></tr>
<tr class="memdesc:abda5071e4c754b612b6a4c42be421312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely right shift values when undefined behavior could occur.  <a href="misc_8h.html#abda5071e4c754b612b6a4c42be421312">More...</a><br /></td></tr>
<tr class="separator:abda5071e4c754b612b6a4c42be421312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e2662974095094e345b2bc2b30ee4c"><td class="memTemplParams" colspan="2">template&lt;unsigned int bits, class T &gt; </td></tr>
<tr class="memitem:a45e2662974095094e345b2bc2b30ee4c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a45e2662974095094e345b2bc2b30ee4c">SafeLeftShift</a> (T value)</td></tr>
<tr class="memdesc:a45e2662974095094e345b2bc2b30ee4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely left shift values when undefined behavior could occur.  <a href="misc_8h.html#a45e2662974095094e345b2bc2b30ee4c">More...</a><br /></td></tr>
<tr class="separator:a45e2662974095094e345b2bc2b30ee4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29e4cf4553b1ff9f884df223a2abd6a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename T &gt; </td></tr>
<tr class="memitem:ab29e4cf4553b1ff9f884df223a2abd6a"><td class="memTemplItemLeft" align="right" valign="top">InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab29e4cf4553b1ff9f884df223a2abd6a">FindIfNot</a> (InputIt first, InputIt last, const T &amp;value)</td></tr>
<tr class="memdesc:ab29e4cf4553b1ff9f884df223a2abd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds first element not in a range.  <a href="misc_8h.html#ab29e4cf4553b1ff9f884df223a2abd6a">More...</a><br /></td></tr>
<tr class="separator:ab29e4cf4553b1ff9f884df223a2abd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions for the Crypto++ library. </p>

<p class="definition">Definition in file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3c75bb398badb69c7577b21486f9963f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c75bb398badb69c7577b21486f9963f">&#9670;&nbsp;</a></span>SIZE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIZE_MAX&#160;&#160;&#160;...</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum value of a machine word. </p>
<p><code>SIZE_MAX</code> provides the maximum value of a machine word. The value is <code>0xffffffff</code> on 32-bit targets, and <code>0xffffffffffffffff</code> on 64-bit targets.</p>
<p>If <code>SIZE_MAX</code> is not defined, then <code>__SIZE_MAX__</code> is used if defined. If not defined, then <code>SIZE_T_MAX</code> is used if defined. If not defined, then the library uses <code>std::numeric_limits&lt;size_t&gt;::max()</code>.</p>
<p>The library prefers <code>__SIZE_MAX__</code> or <code>__SIZE_T_MAX__</code> because they are effectively <code>constexpr</code> that is optimized well by all compilers. <code>std::numeric_limits&lt;size_t&gt;::max()</code> is not always a <code>constexpr</code>, and it is not always optimized well. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00120">120</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a6b378b1b9b2d4654cc852c088742ba70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b378b1b9b2d4654cc852c088742ba70">&#9670;&nbsp;</a></span>CRYPTOPP_COMPILE_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_COMPILE_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;{ ... }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time assertion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to evaluate</td></tr>
  </table>
  </dd>
</dl>
<p>Asserts the expression <code>expr</code> during compile. If C++14 and N3928 are available, then C++14 <code>static_assert</code> is used. Otherwise, a <code>CompileAssert</code> structure is used. When the structure is used a negative-sized array triggers the assert at compile time. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00153">153</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a2d7e4464ea73d6393ebe78f952253426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7e4464ea73d6393ebe78f952253426">&#9670;&nbsp;</a></span>COUNTOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COUNTOF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>an array of elements</td></tr>
  </table>
  </dd>
</dl>
<p>COUNTOF counts elements in an array. On Windows <a class="el" href="misc_8h.html#a2d7e4464ea73d6393ebe78f952253426" title="Counts elements in an array.">COUNTOF(x)</a> is defined to <code>_countof(x)</code> to ensure correct results for pointers. </p><dl class="section note"><dt>Note</dt><dd>COUNTOF does not produce correct results with pointers, and an array must be used. <code>sizeof(x)/sizeof(x[0])</code> suffers the same problem. The risk is eliminated by using <code>_countof(x)</code> on Windows. Windows will provide the immunity for other platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00193">193</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a80492499834e30e0109e1e4a69efee29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80492499834e30e0109e1e4a69efee29">&#9670;&nbsp;</a></span>MEMORY_BARRIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMORY_BARRIER&#160;&#160;&#160;...</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A memory barrier. </p>
<p>MEMORY_BARRIER attempts to ensure reads and writes are completed in the absence of a language synchronization point. It is used by the <a class="el" href="class_singleton.html" title="Restricts the instantiation of a class to one static object without locks.">Singleton</a> class if the compiler supports it. The barrier is provided at the customary places in a double-checked initialization.</p>
<p>Internally, MEMORY_BARRIER uses <code>std::atomic_thread_fence</code> if C++11 atomics are available. Otherwise, <code>intrinsic(_ReadWriteBarrier)</code>, <code>_ReadWriteBarrier()</code> or <code>__asm__("" ::: "memory")</code> is used. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00272">272</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ad1938a2627b812913ac3d50c93fd5f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1938a2627b812913ac3d50c93fd5f11">&#9670;&nbsp;</a></span>EnumToInt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EnumToInt</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v</td><td>)</td>
          <td>&#160;&#160;&#160;static_cast&lt;int&gt;(v)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> value. </p>
<p>EnumToInt avoids C++20 enum-enum conversion warnings under GCC and Clang. C++11 and above use a constexpr function. C++03 and below use a macro due to [lack of] constexpr-ness in early versions of C++. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00504">504</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abe16d69257b3c86de97e8b0a9e851771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe16d69257b3c86de97e8b0a9e851771">&#9670;&nbsp;</a></span>PtrAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR , typename OFF &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PTR PtrAdd </td>
          <td>(</td>
          <td class="paramtype">PTR&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OFF&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pointer with an offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
    <tr><td class="paramname">OFF</td><td>a size type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>a pointer </td></tr>
    <tr><td class="paramname">offset</td><td>a offset into the pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrAdd can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00388">388</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a5e456f139d55e27318ba09d6a06d7960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e456f139d55e27318ba09d6a06d7960">&#9670;&nbsp;</a></span>PtrSub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR , typename OFF &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PTR PtrSub </td>
          <td>(</td>
          <td class="paramtype">PTR&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OFF&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pointer with an offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
    <tr><td class="paramname">OFF</td><td>a size type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>a pointer </td></tr>
    <tr><td class="paramname">offset</td><td>a offset into the pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrSub can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00401">401</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aa0afa8559681afcdbe5cd415cbde63e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0afa8559681afcdbe5cd415cbde63e9">&#9670;&nbsp;</a></span>PtrDiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t PtrDiff </td>
          <td>(</td>
          <td class="paramtype">const PTR&#160;</td>
          <td class="paramname"><em>pointer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PTR&#160;</td>
          <td class="paramname"><em>pointer2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine pointer difference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer1</td><td>the first pointer </td></tr>
    <tr><td class="paramname">pointer2</td><td>the second pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrDiff can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. pointer1 and pointer2 must point to the same object or array (or one past the end), and yields the number of elements (not bytes) difference. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00416">416</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="acacdab7254aa8a8bd6b56e2abb7b9083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacdab7254aa8a8bd6b56e2abb7b9083">&#9670;&nbsp;</a></span>PtrByteDiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PTR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PtrByteDiff </td>
          <td>(</td>
          <td class="paramtype">const PTR&#160;</td>
          <td class="paramname"><em>pointer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PTR&#160;</td>
          <td class="paramname"><em>pointer2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine pointer difference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PTR</td><td>a pointer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer1</td><td>the first pointer </td></tr>
    <tr><td class="paramname">pointer2</td><td>the second pointer</td></tr>
  </table>
  </dd>
</dl>
<p>PtrByteDiff can be used to squash Clang and GCC UBsan findings for pointer addition and subtraction. pointer1 and pointer2 must point to the same object or array (or one past the end), and yields the number of bytes (not elements) difference. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00431">431</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="acb58c82c1e81dd837d38971021a85748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb58c82c1e81dd837d38971021a85748">&#9670;&nbsp;</a></span>BytePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* BytePtr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string</td></tr>
  </table>
  </dd>
</dl>
<p>BytePtr returns NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00441">441</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aeb1c2b960daa3369caafa9fb86c600df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1c2b960daa3369caafa9fb86c600df">&#9670;&nbsp;</a></span>BytePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* BytePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sec_byte_block.html">SecByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="class_sec_byte_block.html" title="SecBlock&lt;byte&gt; typedef.">SecByteBlock</a></td></tr>
  </table>
  </dd>
</dl>
<p>BytePtr returns NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

</div>
</div>
<a id="af7492941085053519baa0065dfd2c4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7492941085053519baa0065dfd2c4aa">&#9670;&nbsp;</a></span>ConstBytePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* ConstBytePtr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string</td></tr>
  </table>
  </dd>
</dl>
<p>ConstBytePtr returns non-NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00463">463</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a8a3b3accc89a99034ceb3bf02b1800ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3b3accc89a99034ceb3bf02b1800ff">&#9670;&nbsp;</a></span>ConstBytePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* ConstBytePtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_byte_block.html">SecByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const pointer to the first element of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="class_sec_byte_block.html" title="SecBlock&lt;byte&gt; typedef.">SecByteBlock</a></td></tr>
  </table>
  </dd>
</dl>
<p>ConstBytePtr returns non-NULL pointer for an empty string. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

</div>
</div>
<a id="a24eea25739f5000af6c684b8c225c6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24eea25739f5000af6c684b8c225c6be">&#9670;&nbsp;</a></span>BytePtrSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BytePtrSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00481">481</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a935acdd6640d177065caca6ddbab2ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935acdd6640d177065caca6ddbab2ef2">&#9670;&nbsp;</a></span>BytePtrSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BytePtrSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sec_byte_block.html">SecByteBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="class_sec_byte_block.html" title="SecBlock&lt;byte&gt; typedef.">SecByteBlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of a string </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

</div>
</div>
<a id="a5f6fcbaaf6f72fe46a6d911b033dfea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6fcbaaf6f72fe46a6d911b033dfea0">&#9670;&nbsp;</a></span>memcpy_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds checking replacement for memcpy() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the destination memory block </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>size of the destination memory block, in bytes </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">count</td><td>the number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ISO/IEC TR-24772 provides bounds checking interfaces for potentially unsafe functions like memcpy(), strcpy() and memmove(). However, not all standard libraries provides them, like Glibc. The library's <a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> is a near-drop in replacement. Its only a near-replacement because the library's version throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a> on a bounds violation.</p>
<p><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> are guarded by __STDC_WANT_SECURE_LIB__. If __STDC_WANT_SECURE_LIB__ is not defined or defined to 0, then the library makes <a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> available. The library will also optionally make the symbols available if <code>CRYPTOPP_WANT_SECURE_LIB</code> is defined. <code>CRYPTOPP_WANT_SECURE_LIB</code> is in <a class="el" href="config_8h.html" title="Library configuration file.">config.h</a>, but it is disabled by default.</p>
<p><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> will assert the pointers src and dest are not NULL in debug builds. Passing NULL for either pointer is undefined behavior. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00527">527</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="adb296eab4ca31ab5c0cf4a932488a8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb296eab4ca31ab5c0cf4a932488a8de">&#9670;&nbsp;</a></span>memmove_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memmove_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds checking replacement for memmove() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the destination memory block </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>size of the destination memory block, in bytes </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">count</td><td>the number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ISO/IEC TR-24772 provides bounds checking interfaces for potentially unsafe functions like memcpy(), strcpy() and memmove(). However, not all standard libraries provides them, like Glibc. The library's <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> is a near-drop in replacement. Its only a near-replacement because the library's version throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a> on a bounds violation.</p>
<p><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> are guarded by __STDC_WANT_SECURE_LIB__. If __STDC_WANT_SECURE_LIB__ is not defined or defined to 0, then the library makes <a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy()">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> available. The library will also optionally make the symbols available if <code>CRYPTOPP_WANT_SECURE_LIB</code> is defined. <code>CRYPTOPP_WANT_SECURE_LIB</code> is in <a class="el" href="config_8h.html" title="Library configuration file.">config.h</a>, but it is disabled by default.</p>
<p><a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove()">memmove_s()</a> will assert the pointers src and dest are not NULL in debug builds. Passing NULL for either pointer is undefined behavior. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00573">573</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a810542d642def73fd278c08092417e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810542d642def73fd278c08092417e11">&#9670;&nbsp;</a></span>vec_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vec_swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two variables which are arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value</td></tr>
  </table>
  </dd>
</dl>
<p>C++03 does not provide support for <code>std::swap(__m128i a, __m128i b)</code> because <code>__m128i</code> is an <code>unsigned long long[2]</code>. Most compilers support it out of the box, but Sun Studio C++ compilers 12.2 and 12.3 do not. </p><dl class="section see"><dt>See also</dt><dd><a href="http://stackoverflow.com/q/38417413">How to swap two __m128i variables in C++03 given its an opaque type and an array?</a> on Stack Overflow. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00618">618</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a0a62d4efc301af9025df8c98fa8edebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a62d4efc301af9025df8c98fa8edebf">&#9670;&nbsp;</a></span>memset_z()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* memset_z </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory block initializer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the memory block being written </td></tr>
    <tr><td class="paramname">val</td><td>the integer value to write for each byte </td></tr>
    <tr><td class="paramname">num</td><td>the size of the source memory block, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Internally the function calls memset with the value <code>val</code>. memset_z can be used to initialize a freshly allocated memory block. To zeroize a memory block on destruction use <code>SecureWipeBuffer</code>. </p><dl class="section return"><dt>Returns</dt><dd>the pointer to the memory block </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a656f38b8d0440981f5f013ada782018c" title="Sets each element of an array to 0.">SecureWipeBuffer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00640">640</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="abe412b0409249cb54899e97bc7d86424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe412b0409249cb54899e97bc7d86424">&#9670;&nbsp;</a></span>STDMIN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; STDMIN </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement function for std::min. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison of <code>b &lt; a</code> using <code>operator&lt;</code></dd></dl>
<p>STDMIN was provided because the library could not easily use std::min or std::max in Windows or Cygwin 1.1.0 </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00657">657</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="af1490597cb11989e78d5ba5b5f21266b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1490597cb11989e78d5ba5b5f21266b">&#9670;&nbsp;</a></span>STDMAX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; STDMAX </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement function for std::max. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison of <code>a &lt; b</code> using <code>operator&lt;</code></dd></dl>
<p>STDMAX was provided because the library could not easily use std::min or std::max in Windows or Cygwin 1.1.0 </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00668">668</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ac8391e7d9d613a6c401787d2cdab1f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8391e7d9d613a6c401787d2cdab1f51">&#9670;&nbsp;</a></span>UnsignedMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T1 UnsignedMin </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe comparison of values that could be negative and incorrectly promoted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison a and b using <code>operator&lt;</code>.</dd></dl>
<p>The comparison <code>b &lt; a</code> is performed and the value returned is type T1. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00695">695</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a8a2ce94589bb74164d809f4675bd23dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2ce94589bb74164d809f4675bd23dd">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section note"><dt>Note</dt><dd>for integral conversions, a template specialization should be provided. The specialization will perform more efficiently, and avoid warnings for truncation and sign compares. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00718">718</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aef9c6fb182e29b6f83218f0277b814ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9c6fb182e29b6f83218f0277b814ce">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00741">741</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a7808d89c7ac5c2c77360944dc7369678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7808d89c7ac5c2c77360944dc7369678">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00757">757</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a0052b1609559f5e113905d54d429711a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0052b1609559f5e113905d54d429711a">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00771">771</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a9b7e594dd086ec2ae625cbcf7fe71b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7e594dd086ec2ae625cbcf7fe71b5f">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00787">787</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a3d868daec4a6485ea8393ed87202db2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d868daec4a6485ea8393ed87202db2e">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00803">803</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ad0a9752786a04193c6219f18b02050bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a9752786a04193c6219f18b02050bb">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00817">817</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ac7c1d152be686ca1f2e017d226915468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c1d152be686ca1f2e017d226915468">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00831">831</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a9dbe71bd3d318f5b7be175b3f2997208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbe71bd3d318f5b7be175b3f2997208">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00847">847</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a051380375fe085115451a06b84d68c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051380375fe085115451a06b84d68c3d">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00865">865</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="adb7c3d4c147bee46750037a346059815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7c3d4c147bee46750037a346059815">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00881">881</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a66c8abb585a36d6117ce1c29c54aeab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c8abb585a36d6117ce1c29c54aeab2">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0261714db7e6903ad1484d11a3900236">sword64</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00897">897</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a45edf61e9d5dae4e1062d29d9059297b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45edf61e9d5dae4e1062d29d9059297b">&#9670;&nbsp;</a></span>SafeConvert() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a3304866b527056436d1a444813cd5f6d">sword32</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a conversion from <code>from</code> to <code>to</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from <code>from</code> to <code>to</code>, false otherwise.</dd></dl>
<p>if the function returns true, then it is safe to use <code>to</code>. If the function returns false, then <code>to</code> is undefined and should not be used. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00915">915</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a6cd7decd035cc4e144cd3d395e834106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd7decd035cc4e144cd3d395e834106">&#9670;&nbsp;</a></span>IntToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string IntToString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a value to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l00929">929</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aad4f4608b867f01a4cad90c5b222f89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4f4608b867f01a4cad90c5b222f89b">&#9670;&nbsp;</a></span>IntToString&lt; word64 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL std::string <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a>&lt; <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an unsigned value to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base.</dd></dl>
<p>this template function specialization was added to suppress Coverity findings on <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string.">IntToString()</a> with unsigned types. </p>

</div>
</div>
<a id="a1b67e971e2ab82125e3cf2a08a24a103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b67e971e2ab82125e3cf2a08a24a103">&#9670;&nbsp;</a></span>IntToString&lt; Integer &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL std::string <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a>&lt; <a class="el" href="class_integer.html">Integer</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_integer.html">Integer</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base.</dd></dl>
<p>This is a template specialization of <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string.">IntToString()</a>. Use it like <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string.">IntToString()</a>: </p><pre>
 // Print integer in base 10
 <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> n...
 std::string s = IntToString(n, 10);
</pre><p>The string is presented with lowercase letters by default. A hack is available to switch to uppercase letters without modifying the function signature. </p><pre>
 // Print integer in base 16, uppercase letters
 <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations.">Integer</a> n...
 const unsigned int UPPER = (1 &lt;&lt; 31);
 std::string s = IntToString(n, (UPPER | 16));</pre> 
</div>
</div>
<a id="a6c63a5683602db0ff8975746a414797f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c63a5683602db0ff8975746a414797f">&#9670;&nbsp;</a></span>Parity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Parity </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parity of a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to provide the parity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the number 1-bits in the value is odd, 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01012">1012</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a3e22fbd4b8f95aa01bde93ea32e44e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e22fbd4b8f95aa01bde93ea32e44e82">&#9670;&nbsp;</a></span>BytePrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BytePrecision </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of 8-bit bytes or octets required for a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of 8-bit bytes or octets required to represent a value </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01024">1024</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a3c5964768bc94670ad2bc3f218d9367f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5964768bc94670ad2bc3f218d9367f">&#9670;&nbsp;</a></span>BitPrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BitPrecision </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bits required for a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum number of bits required to represent a value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01047">1047</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a495acbd6f3cdabbb4dd863c09b378df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495acbd6f3cdabbb4dd863c09b378df4">&#9670;&nbsp;</a></span>TrailingZeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TrailingZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of trailing 0-bits in a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the 32-bit value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing 0-bits in v, starting at the least significant bit position</dd></dl>
<p>TrailingZeros returns the number of trailing 0-bits in v, starting at the least significant bit position. The return value is undefined if there are no 1-bits set in the value v. </p><dl class="section note"><dt>Note</dt><dd>The function does not return 0 if no 1-bits are set because 0 collides with a 1-bit at the 0-th position. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01072">1072</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="addb4df9b2f1e119d89a1573338c4eda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb4df9b2f1e119d89a1573338c4eda6">&#9670;&nbsp;</a></span>TrailingZeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TrailingZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of trailing 0-bits in a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the 64-bit value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing 0-bits in v, starting at the least significant bit position</dd></dl>
<p>TrailingZeros returns the number of trailing 0-bits in v, starting at the least significant bit position. The return value is undefined if there are no 1-bits set in the value v. </p><dl class="section note"><dt>Note</dt><dd>The function does not return 0 if no 1-bits are set because 0 collides with a 1-bit at the 0-th position. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01103">1103</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a616a7f0365c4947b0c8a44606c525a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616a7f0365c4947b0c8a44606c525a62">&#9670;&nbsp;</a></span>Crop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Crop </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncates the value to the specified number of bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to truncate or mask </td></tr>
    <tr><td class="paramname">bits</td><td>the number of bits to truncate or mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value truncated to the specified number of bits, starting at the least significant bit position</dd></dl>
<p>This function masks the low-order bits of value and returns the result. The mask is created with <code>(1 &lt;&lt; bits) - 1</code>. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01131">1131</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a7c5d30b17c9d4869fdc3458dd05c500d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5d30b17c9d4869fdc3458dd05c500d">&#9670;&nbsp;</a></span>BitsToBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 8-bit bytes or octets required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of 8-bit bytes or octets required by bitCount</dd></dl>
<p>BitsToBytes is effectively a ceiling function based on 8-bit bytes. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01143">1143</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a886cc7ce76578c6df939f564f676e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886cc7ce76578c6df939f564f676e71a">&#9670;&nbsp;</a></span>BytesToWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BytesToWords </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words required for the specified number of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteCount</td><td>the number of bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of words required by byteCount</dd></dl>
<p>BytesToWords is effectively a ceiling function based on <code>WORD_SIZE</code>. <code>WORD_SIZE</code> is defined in <a class="el" href="config_8h.html" title="Library configuration file.">config.h</a> </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01153">1153</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a45c56601a8c94b6a37a21657929fe928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c56601a8c94b6a37a21657929fe928">&#9670;&nbsp;</a></span>BitsToWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToWords </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of words required by bitCount</dd></dl>
<p>BitsToWords is effectively a ceiling function based on <code>WORD_BITS</code>. <code>WORD_BITS</code> is defined in <a class="el" href="config_8h.html" title="Library configuration file.">config.h</a> </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01163">1163</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a778d13f3d45915e1bc5c0ab1801ea6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778d13f3d45915e1bc5c0ab1801ea6ad">&#9670;&nbsp;</a></span>BitsToDwords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToDwords </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of double words required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of double words required by bitCount</dd></dl>
<p>BitsToDwords is effectively a ceiling function based on <code>2*WORD_BITS</code>. <code>WORD_BITS</code> is defined in <a class="el" href="config_8h.html" title="Library configuration file.">config.h</a> </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01173">1173</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="afe5daf6ca2cdd0e0dfdaac5662450db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5daf6ca2cdd0e0dfdaac5662450db9">&#9670;&nbsp;</a></span>xorbuf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void xorbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an XOR of a buffer with a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to XOR with the mask </td></tr>
    <tr><td class="paramname">mask</td><td>the mask to XOR with the buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function effectively visits each element in the buffers and performs <code>buf[i] ^= mask[i]</code>. buf and mask must be of equal size. </p>

</div>
</div>
<a id="aa144ba0eaeff3caf15d1ed11732c5da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa144ba0eaeff3caf15d1ed11732c5da0">&#9670;&nbsp;</a></span>xorbuf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void xorbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an XOR of an input buffer with a mask and stores the result in an output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">input</td><td>the source buffer to XOR with the mask </td></tr>
    <tr><td class="paramname">mask</td><td>the mask buffer to XOR with the input buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function effectively visits each element in the buffers and performs <code>output[i] = input[i] ^ mask[i]</code>. output, input and mask must be of equal size. </p>

</div>
</div>
<a id="afa9a2f81aa1ca6560a910f31cab02ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9a2f81aa1ca6560a910f31cab02ac9">&#9670;&nbsp;</a></span>VerifyBufsEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL bool VerifyBufsEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a near constant-time comparison of two equally sized buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf1</td><td>the first buffer </td></tr>
    <tr><td class="paramname">buf2</td><td>the second buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>VerifyBufsEqual performs an XOR of the elements in two equally sized buffers and returns a result based on the XOR operation. A count of 0 returns true because two empty buffers are considered equal.</p>
<p>The function is near constant-time because CPU micro-code timings could affect the "constant-ness". Calling code is responsible for mitigating timing attacks if the buffers are not equally sized. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a621695f6346d6a745e340513d917b31a" title="Reduces a value to a power of 2.">ModPowerOf2</a> </dd></dl>

</div>
</div>
<a id="a65531618a7eca8803fa9e9287c43aafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65531618a7eca8803fa9e9287c43aafc">&#9670;&nbsp;</a></span>IsPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a value is a power of 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is a power of 2, false otherwise</dd></dl>
<p>The function creates a mask of <code>value - 1</code> and returns the result of an AND operation compared to 0. If value is 0 or less than 0, then the function returns false. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01215">1215</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a67b8be26ba8900662fa86dcea6d831f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b8be26ba8900662fa86dcea6d831f9">&#9670;&nbsp;</a></span>NumericLimitsMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T NumericLimitsMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the minimum value for a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value of the type or class</dd></dl>
<p><a class="el" href="misc_8h.html#a67b8be26ba8900662fa86dcea6d831f9" title="Provide the minimum value for a type.">NumericLimitsMin()</a> was introduced for Clang at <a href="http://github.com/weidai11/cryptopp/issues/364">Issue 364, Apple Clang 6.0 and numeric_limits&lt;word128&gt;::max() returns 0</a>.</p>
<p><a class="el" href="misc_8h.html#a67b8be26ba8900662fa86dcea6d831f9" title="Provide the minimum value for a type.">NumericLimitsMin()</a> requires a specialization for <code>T</code>, meaning <code>std::numeric_limits&lt;T&gt;::is_specialized</code> must return <code>true</code>. In the case of <code>word128</code> Clang did not specialize <code>numeric_limits</code> for the type. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01248">1248</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="af39f468338a6ad6a22fa0e9c16819fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39f468338a6ad6a22fa0e9c16819fa7">&#9670;&nbsp;</a></span>NumericLimitsMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T NumericLimitsMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the maximum value for a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum value of the type or class</dd></dl>
<p><a class="el" href="misc_8h.html#af39f468338a6ad6a22fa0e9c16819fa7" title="Provide the maximum value for a type.">NumericLimitsMax()</a> was introduced for Clang at <a href="http://github.com/weidai11/cryptopp/issues/364">Issue 364, Apple Clang 6.0 and numeric_limits&lt;word128&gt;::max() returns 0</a>.</p>
<p><a class="el" href="misc_8h.html#af39f468338a6ad6a22fa0e9c16819fa7" title="Provide the maximum value for a type.">NumericLimitsMax()</a> requires a specialization for <code>T</code>, meaning <code>std::numeric_limits&lt;T&gt;::is_specialized</code> must return <code>true</code>. In the case of <code>word128</code> Clang did not specialize <code>numeric_limits</code> for the type. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01266">1266</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a30712a90999ad9d9152975f2e92d46b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30712a90999ad9d9152975f2e92d46b8">&#9670;&nbsp;</a></span>SaturatingSubtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 SaturatingSubtract </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a saturating subtract clamped at 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the minuend </td></tr>
    <tr><td class="paramname">b</td><td>the subtrahend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference produced by the saturating subtract</dd></dl>
<p>Saturating arithmetic restricts results to a fixed range. Results that are less than 0 are clamped at 0.</p>
<p>Use of saturating arithmetic in places can be advantageous because it can avoid a branch by using an instruction like a conditional move (<code>CMOVE</code>). </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01302">1302</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="afd39d67faef904dbb474981762b7ebe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39d67faef904dbb474981762b7ebe1">&#9670;&nbsp;</a></span>SaturatingSubtract1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 SaturatingSubtract1 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a saturating subtract clamped at 1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the minuend </td></tr>
    <tr><td class="paramname">b</td><td>the subtrahend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference produced by the saturating subtract</dd></dl>
<p>Saturating arithmetic restricts results to a fixed range. Results that are less than 1 are clamped at 1.</p>
<p>Use of saturating arithmetic in places can be advantageous because it can avoid a branch by using an instruction like a conditional move (<code>CMOVE</code>). </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01319">1319</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a621695f6346d6a745e340513d917b31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621695f6346d6a745e340513d917b31a">&#9670;&nbsp;</a></span>ModPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 ModPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces a value to a power of 2. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="misc_8h.html#a621695f6346d6a745e340513d917b31a" title="Reduces a value to a power of 2.">ModPowerOf2()</a> returns <code>a &amp; (b-1)</code>. <code>b</code> must be a power of 2. Use <a class="el" href="misc_8h.html#a65531618a7eca8803fa9e9287c43aafc" title="Tests whether a value is a power of 2.">IsPowerOf2()</a> to determine if <code>b</code> is a suitable candidate. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a65531618a7eca8803fa9e9287c43aafc" title="Tests whether a value is a power of 2.">IsPowerOf2</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01334">1334</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aa2ac57210cb6796eced074e6d2e294fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ac57210cb6796eced074e6d2e294fb">&#9670;&nbsp;</a></span>RoundDownToMultipleOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 RoundDownToMultipleOf </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a value down to a multiple of a second value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to reduce </td></tr>
    <tr><td class="paramname">m</td><td>the value to reduce <code>n</code> to a multiple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the possibly unmodified value <br  />
</dd></dl>
<p>RoundDownToMultipleOf is effectively a floor function based on m. The function returns the value <code>n - n%m</code>. If n is a multiple of m, then the original value is returned. </p><dl class="section note"><dt>Note</dt><dd><code>T1</code> and <code>T2</code> should be unsigned arithmetic types. If <code>T1</code> or <code>T2</code> is signed, then the value should be non-negative. The library asserts in debug builds when practical, but allows you to perform the operation in release builds. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01354">1354</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a57a219d44f45272a1f3b3f17a656000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a219d44f45272a1f3b3f17a656000a">&#9670;&nbsp;</a></span>RoundUpToMultipleOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 RoundUpToMultipleOf </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a value up to a multiple of a second value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to reduce </td></tr>
    <tr><td class="paramname">m</td><td>the value to reduce <code>n</code> to a multiple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the possibly unmodified value <br  />
</dd></dl>
<p>RoundUpToMultipleOf is effectively a ceiling function based on m. The function returns the value <code>n + n%m</code>. If n is a multiple of m, then the original value is returned. If the value n would overflow, then an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument</a> exception is thrown. </p><dl class="section note"><dt>Note</dt><dd><code>T1</code> and <code>T2</code> should be unsigned arithmetic types. If <code>T1</code> or <code>T2</code> is signed, then the value should be non-negative. The library asserts in debug builds when practical, but allows you to perform the operation in release builds. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01384">1384</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ab4e438054095c88f0c4d9eda7efc584d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e438054095c88f0c4d9eda7efc584d">&#9670;&nbsp;</a></span>GetAlignmentOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetAlignmentOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum alignment requirements of a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum alignment requirements of <code>T</code>, in bytes</dd></dl>
<p>Internally the function calls C++11's <code>alignof</code> if available. If not available, then the function uses compiler specific extensions such as <code>__alignof</code> and <code>_alignof_</code>. If an extension is not available, then the function uses <code>sizeof(T)</code>. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01409">1409</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a726c3b76265182681f5d5fd173ab5676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726c3b76265182681f5d5fd173ab5676">&#9670;&nbsp;</a></span>IsAlignedOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAlignedOn </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether ptr is aligned to a minimum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer being checked for alignment </td></tr>
    <tr><td class="paramname">alignment</td><td>the alignment value to test the pointer against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>ptr</code> is aligned on at least <code>alignment</code> boundary, false otherwise</dd></dl>
<p>Internally the function tests whether alignment is 1. If so, the function returns true. If not, then the function effectively performs a modular reduction and returns true if the residue is 0. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01436">1436</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a8b2c95659d16a971941622625c9102ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2c95659d16a971941622625c9102ae">&#9670;&nbsp;</a></span>IsAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether ptr is minimally aligned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to check for alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>ptr</code> is aligned to at least <code>T</code> boundary, false otherwise</dd></dl>
<p>Internally the function calls IsAlignedOn with a second parameter of GetAlignmentOf&lt;T&gt;. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01450">1450</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aed8336b0d98f2469441837be6cbbebf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8336b0d98f2469441837be6cbbebf9">&#9670;&nbsp;</a></span>GetNativeByteOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> GetNativeByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns NativeByteOrder as an enumerated ByteOrder value. </p>
<dl class="section return"><dt>Returns</dt><dd>LittleEndian if the native byte order is little-endian, and BigEndian if the native byte order is big-endian</dd></dl>
<p>NativeByteOrder is a typedef depending on the platform. If CRYPTOPP_LITTLE_ENDIAN is set in <a class="el" href="config_8h.html" title="Library configuration file.">config.h</a>, then GetNativeByteOrder returns LittleEndian. If CRYPTOPP_BIG_ENDIAN is set, then GetNativeByteOrder returns BigEndian. </p><dl class="section note"><dt>Note</dt><dd>There are other byte orders besides little- and big-endian, and they include bi-endian and PDP-endian. If a system is neither little-endian nor big-endian, then a compile time error occurs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01473">1473</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a6c2da0dd866619761e63c3b5da58c477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2da0dd866619761e63c3b5da58c477">&#9670;&nbsp;</a></span>NativeByteOrderIs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeByteOrderIs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether order follows native byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ordering being tested against native byte ordering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if order follows native byte ordering, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01481">1481</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ade22f7ed542b3db2912c917f8e3d6067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade22f7ed542b3db2912c917f8e3d6067">&#9670;&nbsp;</a></span>GetCipherDir()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cryptlib_8h.html#a353ccabf5ddc119a6a33e92f7b9961c7">CipherDir</a> GetCipherDir </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the direction the cipher is being operated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the cipher object being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ENCRYPTION if the cipher obj is being operated in its forward direction, DECRYPTION otherwise</dd></dl>
<p>A cipher can be operated in a "forward" direction (encryption) or a "reverse" direction (decryption). The operations do not have to be symmetric, meaning a second application of the transformation does not necessarily return the original message. That is, <code>E(D(m))</code> may not equal <code>E(E(m))</code>; and <code>D(E(m))</code> may not equal <code>D(D(m))</code>. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01497">1497</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a44fad9d8c25e8aca3a7ee29345516f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fad9d8c25e8aca3a7ee29345516f0a">&#9670;&nbsp;</a></span>IncrementCounterByOne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IncrementCounterByOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition with carry on a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inout</td><td>the byte block </td></tr>
    <tr><td class="paramname">size</td><td>the size of the block, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Performs an addition with carry by adding 1 on a block of bytes starting at the least significant byte. Once carry is 0, the function terminates and returns to the caller. </p><dl class="section note"><dt>Note</dt><dd>The function is not constant time because it stops processing when the carry is 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01508">1508</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a2f852960b51e106a849781341cb2055c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f852960b51e106a849781341cb2055c">&#9670;&nbsp;</a></span>IncrementCounterByOne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IncrementCounterByOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition with carry on a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the destination block of bytes </td></tr>
    <tr><td class="paramname">input</td><td>the source block of bytes </td></tr>
    <tr><td class="paramname">size</td><td>the size of the block</td></tr>
  </table>
  </dd>
</dl>
<p>Performs an addition with carry on a block of bytes starting at the least significant byte. Once carry is 0, the remaining bytes from input are copied to output using memcpy.</p>
<p>The function is close to near-constant time because it operates on all the bytes in the blocks. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01528">1528</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ae71e5659910553da22f9b1e877cddc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71e5659910553da22f9b1e877cddc07">&#9670;&nbsp;</a></span>ConditionalSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalSwap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a branch-less swap of values a and b if condition c is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the condition to perform the swap </td></tr>
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01554">1554</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a513e4522b268f9ee2e188606c2101d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513e4522b268f9ee2e188606c2101d5a">&#9670;&nbsp;</a></span>ConditionalSwapPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalSwapPointers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a branch-less swap of pointers a and b if condition c is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the condition to perform the swap </td></tr>
    <tr><td class="paramname">a</td><td>the first pointer </td></tr>
    <tr><td class="paramname">b</td><td>the second pointer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01567">1567</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a656f38b8d0440981f5f013ada782018c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f38b8d0440981f5f013ada782018c">&#9670;&nbsp;</a></span>SecureWipeBuffer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeBuffer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets each element of an array to 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of elements </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01584">1584</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a1300c13f20ed72b4562e491a5fb56091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1300c13f20ed72b4562e491a5fb56091">&#9670;&nbsp;</a></span>SecureWipeBuffer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each byte of an array to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of bytes </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01602">1602</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aea79270fd6a206aee58511fb27dba855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea79270fd6a206aee58511fb27dba855">&#9670;&nbsp;</a></span>SecureWipeBuffer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each 16-bit element of an array to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of 16-bit words </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01617">1617</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aee79afe16b5c406876601977ced0d5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee79afe16b5c406876601977ced0d5e2">&#9670;&nbsp;</a></span>SecureWipeBuffer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each 32-bit element of an array to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of 32-bit words </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01632">1632</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="af31349ed51eb9be430453214a3ba8422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31349ed51eb9be430453214a3ba8422">&#9670;&nbsp;</a></span>SecureWipeBuffer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each 64-bit element of an array to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of 64-bit words </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01647">1647</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a4994f3480634e5f1435fd71f9b652c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4994f3480634e5f1435fd71f9b652c38">&#9670;&nbsp;</a></span>SecureWipeArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each element of an array to 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of elements </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01700">1700</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aba2ed56f8a15d6dabbef74390eda4352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2ed56f8a15d6dabbef74390eda4352">&#9670;&nbsp;</a></span>StringNarrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string StringNarrow </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwOnError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a wide character C-string to a multibyte string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string consisting of wide characters </td></tr>
    <tr><td class="paramname">throwOnError</td><td>flag indicating the function should throw on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str converted to a multibyte string or an empty string.</dd></dl>
<p><a class="el" href="misc_8h.html#aba2ed56f8a15d6dabbef74390eda4352" title="Converts a wide character C-string to a multibyte string.">StringNarrow()</a> converts a wide string to a narrow string using C++ std::wcstombs() under the executing thread's locale. A locale must be set before using this function, and it can be set with std::setlocale() if needed. Upon success, the converted string is returned.</p>
<p>Upon failure with throwOnError as false, the function returns an empty string. If throwOnError as true, the function throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </p><dl class="section note"><dt>Note</dt><dd>If you try to convert, say, the Chinese character for "bone" from UTF-16 (0x9AA8) to UTF-8 (0xE9 0xAA 0xA8), then you must ensure the locale is available. If the locale is not available, then a 0x21 error is returned on Windows which eventually results in an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </dd></dl>

</div>
</div>
<a id="ac95ff706a83782e3d18a3d14817db932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95ff706a83782e3d18a3d14817db932">&#9670;&nbsp;</a></span>StringWiden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring StringWiden </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwOnError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a multibyte C-string to a wide character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string consisting of wide characters </td></tr>
    <tr><td class="paramname">throwOnError</td><td>flag indicating the function should throw on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str converted to a multibyte string or an empty string.</dd></dl>
<p><a class="el" href="misc_8h.html#ac95ff706a83782e3d18a3d14817db932" title="Converts a multibyte C-string to a wide character string.">StringWiden()</a> converts a narrow string to a wide string using C++ std::mbstowcs() under the executing thread's locale. A locale must be set before using this function, and it can be set with std::setlocale() if needed. Upon success, the converted string is returned.</p>
<p>Upon failure with throwOnError as false, the function returns an empty string. If throwOnError as true, the function throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </p><dl class="section note"><dt>Note</dt><dd>If you try to convert, say, the Chinese character for "bone" from UTF-8 (0xE9 0xAA 0xA8) to UTF-16 (0x9AA8), then you must ensure the locale is available. If the locale is not available, then a 0x21 error is returned on Windows which eventually results in an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected.">InvalidArgument()</a> exception. </dd></dl>

</div>
</div>
<a id="a0ab6928faa40f6e56e7f4817d5d65a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab6928faa40f6e56e7f4817d5d65a38">&#9670;&nbsp;</a></span>rotlConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int R, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlConstant </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the number of bit positions to rotate the value </td></tr>
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>R must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount R is outside the range.</p>
<p>Use rotlConstant when the rotate amount is constant. The template function was added because Clang did not propagate the constant when passed as a function parameter. Clang's need for a constexpr meant rotlFixed failed to compile on occasion. </p><dl class="section note"><dt>Note</dt><dd>rotlConstant attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01757">1757</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a7d777068849add4c7ab87f7b0683ef65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d777068849add4c7ab87f7b0683ef65">&#9670;&nbsp;</a></span>rotrConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int R, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrConstant </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the number of bit positions to rotate the value </td></tr>
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>R must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount R is outside the range.</p>
<p>Use rotrConstant when the rotate amount is constant. The template function was added because Clang did not propagate the constant when passed as a function parameter. Clang's need for a constexpr meant rotrFixed failed to compile on occasion. </p><dl class="section note"><dt>Note</dt><dd>rotrConstant attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01783">1783</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aaf7b80a08d25ab9d62693c9e4798ef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7b80a08d25ab9d62693c9e4798ef98">&#9670;&nbsp;</a></span>rotlFixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlFixed </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotlFixed attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. New code should use <code>rotlConstant</code>, which accepts the rotate amount as a template parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01808">1808</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="abf88e95400925b89c94641916535b6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf88e95400925b89c94641916535b6da">&#9670;&nbsp;</a></span>rotrFixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrFixed </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotrFixed attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. New code should use <code>rotrConstant</code>, which accepts the rotate amount as a template parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01833">1833</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a0de05253683b27a221e6465b3a7453b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de05253683b27a221e6465b3a7453b2">&#9670;&nbsp;</a></span>rotlVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlVariable </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotlVariable attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01857">1857</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="abd053d245fe902fe55bfd8a335634110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd053d245fe902fe55bfd8a335634110">&#9670;&nbsp;</a></span>rotrVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrVariable </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01877">1877</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ad31fe5d559d014085c6a49594b817196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31fe5d559d014085c6a49594b817196">&#9670;&nbsp;</a></span>rotlMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlMod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y is reduced to the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable will use either <code>rotate IMM</code> or <code>rotate REG</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01894">1894</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ae8fc34eb834dd2424407d5e4d729594e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fc34eb834dd2424407d5e4d729594e">&#9670;&nbsp;</a></span>rotrMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrMod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y is reduced to the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable will use either <code>rotate IMM</code> or <code>rotate REG</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a0ab6928faa40f6e56e7f4817d5d65a38" title="Performs a left rotate.">rotlConstant</a>, <a class="el" href="misc_8h.html#a7d777068849add4c7ab87f7b0683ef65" title="Performs a right rotate.">rotrConstant</a>, <a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98" title="Performs a left rotate.">rotlFixed</a>, <a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da" title="Performs a right rotate.">rotrFixed</a>, <a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2" title="Performs a left rotate.">rotlVariable</a>, <a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110" title="Performs a right rotate.">rotrVariable</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l01910">1910</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a9a2ceb73851e757cb436cdbaa0242219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ceb73851e757cb436cdbaa0242219">&#9670;&nbsp;</a></span>GetByte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a byte from a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the value </td></tr>
    <tr><td class="paramname">value</td><td>the value to retrieve the byte </td></tr>
    <tr><td class="paramname">index</td><td>the location of the byte to retrieve </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02219">2219</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a1d8d5adca8384ebedc699760ce217b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8d5adca8384ebedc699760ce217b08">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 8-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to reverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ByteReverse returns the value passed to it since there is nothing to reverse. </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02231">2231</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aa179e009cf5c74bb431b3c112d7ee444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa179e009cf5c74bb431b3c112d7ee444">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 16-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function performs a 8-bit rotate on the word16. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02240">2240</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="acf65f4a9edb6224d01e900aa7205a4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf65f4a9edb6224d01e900aa7205a4f4">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 32-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function uses a combination of rotates on the word32. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02255">2255</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a47686f3b4957541a58a3b280d1a89d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47686f3b4957541a58a3b280d1a89d4c">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 64-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 64-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function uses a combination of rotates on the word64. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02284">2284</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="afd5688cbe51450ce2090636cdd9090ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5688cbe51450ce2090636cdd9090ca">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a> ByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 128-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 128-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function uses a combination of rotates on the word128. </p><dl class="section note"><dt>Note</dt><dd>word128 is available on some 64-bit platforms when the compiler supports it. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02309">2309</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a1746e70bf831f0cbf8ad73d8c15bc921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1746e70bf831f0cbf8ad73d8c15bc921">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> BitReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 8-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the byte. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02319">2319</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a699c24d7013f20ee03076576984c875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699c24d7013f20ee03076576984c875e">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> BitReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 16-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the word16. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02329">2329</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aad87ebeafa7de2c11c19453f3b3cfea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad87ebeafa7de2c11c19453f3b3cfea7">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> BitReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 32-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the word32. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02348">2348</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a336c0289dcd2670e6b4079fa98018d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336c0289dcd2670e6b4079fa98018d7a">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> BitReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 64-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 64-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the word64. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02367">2367</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a641ecc1d620ac8c04bc43661a2bbba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641ecc1d620ac8c04bc43661a2bbba71">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T BitReverse </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>The template overload of BitReverse operates on signed and unsigned values. Internally the size of T is checked, and then value is cast to a byte, word16, word32 or word64. After the cast, the appropriate BitReverse overload is called. </p><dl class="section note"><dt>Note</dt><dd>word128 is available on some 64-bit platforms when the compiler supports it. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0, word128 since Crypto++ 8.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02388">2388</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a8e499ded4f2e7e7705c3cfd39cdf137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e499ded4f2e7e7705c3cfd39cdf137f">&#9670;&nbsp;</a></span>ConditionalByteReverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T ConditionalByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a value depending upon endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">value</td><td>the value to conditionally reverse</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, the ConditionalByteReverse calls NativeByteOrderIs. If order matches native byte order, then the original value is returned. If not, then ByteReverse is called on the value before returning to the caller. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02417">2417</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ab95e030e0abd33ea360d75cd9c4c8bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95e030e0abd33ea360d75cd9c4c8bbe">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ByteReverse </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses bytes in an element from an array of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">byteCount</td><td>the total number of bytes in the array</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, ByteReverse visits each element in the in array calls ByteReverse on it, and writes the result to out.</p>
<p>ByteReverse does not process tail byes, or bytes that are not part of a full element. If T is int (and int is 4 bytes), then <code>byteCount = 10</code> means only the first 2 elements or 8 bytes are reversed.</p>
<p>The following program should help illustrate the behavior. </p><pre>vector&lt;word32&gt; v1, v2;

v1.push_back(1);
v1.push_back(2);
v1.push_back(3);
v1.push_back(4);

v2.resize(v1.size());
ByteReverse&lt;word32&gt;(&amp;v2[0], &amp;v1[0], 16);

cout &lt;&lt; "V1: ";
for(unsigned int i = 0; i &lt; v1.size(); i++)
  cout &lt;&lt; std::hex &lt;&lt; v1[i] &lt;&lt; " ";
cout &lt;&lt; endl;

cout &lt;&lt; "V2: ";
for(unsigned int i = 0; i &lt; v2.size(); i++)
  cout &lt;&lt; std::hex &lt;&lt; v2[i] &lt;&lt; " ";
cout &lt;&lt; endl;</pre><p> The program above results in the following output. </p><pre>V1: 00000001 00000002 00000003 00000004
V2: 01000000 02000000 03000000 04000000</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a8e499ded4f2e7e7705c3cfd39cdf137f" title="Reverses bytes in a value depending upon endianness.">ConditionalByteReverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02458">2458</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aae0de65c1758668440f71a8ff6534ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0de65c1758668440f71a8ff6534ad9">&#9670;&nbsp;</a></span>ConditionalByteReverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally reverses bytes in an element from an array of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">byteCount</td><td>the byte count of the arrays</td></tr>
  </table>
  </dd>
</dl>
<p>ConditionalByteReverse visits each element in the in array calls ByteReverse on it depending on the desired endianness, and writes the result to out.</p>
<p>ByteReverse does not process tail byes, or bytes that are not part of a full element. If T is int (and int is 4 bytes), then <code>byteCount = 10</code> means only the first 2 elements or 8 bytes are reversed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a1d8d5adca8384ebedc699760ce217b08" title="Reverses bytes in a 8-bit value.">ByteReverse</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02484">2484</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a929e347e6efedee4099dac8b3956350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929e347e6efedee4099dac8b3956350e">&#9670;&nbsp;</a></span>GetUserKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetUserKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bytes in a buffer to an array of elements in big-endian order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">outlen</td><td>the byte count of the array </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">inlen</td><td>the byte count of the array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02500">2500</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ab4ded795b6a29f00d160d123480d279d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ded795b6a29f00d160d123480d279d">&#9670;&nbsp;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a byte from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a byte value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02516">2516</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aa30f251bbb592f2d1621d8c37dffcf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30f251bbb592f2d1621d8c37dffcf8a">&#9670;&nbsp;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a> *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a word16 from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a word16 value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02529">2529</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ad7c7e2905abe7b50b0c49f78ea7fcb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c7e2905abe7b50b0c49f78ea7fcb71">&#9670;&nbsp;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a word32 from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a word32 value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02544">2544</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a8d6f65b550c7f363ba6d36ab1f5323c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6f65b550c7f363ba6d36ab1f5323c5">&#9670;&nbsp;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a word64 from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a word64 value. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02559">2559</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aeebca16db3f44f16bf6c21b12ad0b641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebca16db3f44f16bf6c21b12ad0b641">&#9670;&nbsp;</a></span>UnalignedGetWordNonTemplate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a> UnalignedGetWordNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a> *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a word128 from an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned buffer </td></tr>
    <tr><td class="paramname">unused</td><td>dummy parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte value</dd></dl>
<p>UnalignedGetWordNonTemplate accesses an unaligned buffer and returns a word128 value. </p><dl class="section note"><dt>Note</dt><dd>word128 is available on some 64-bit platforms when the compiler supports it. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02592">2592</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a8184a77f9a4c8ffbda9622b1cee7a148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8184a77f9a4c8ffbda9622b1cee7a148">&#9670;&nbsp;</a></span>UnalignedbyteNonTemplate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>xorBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a byte to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td>byte value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a byte value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02640">2640</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ac26b43699857ac54a8f4624c89bb6ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26b43699857ac54a8f4624c89bb6ab9">&#9670;&nbsp;</a></span>UnalignedbyteNonTemplate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ac32ea9831f54b53dfce00081c0d02681">word16</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>xorBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a word16 to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td>word16 value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a word16 value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02653">2653</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aef9d0bbf3f776108244b5c36ff5041d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9d0bbf3f776108244b5c36ff5041d5">&#9670;&nbsp;</a></span>UnalignedbyteNonTemplate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>xorBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a word32 to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td>word32 value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a word32 value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02690">2690</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a36bf3fa1752839aa454537cd2d3ca935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bf3fa1752839aa454537cd2d3ca935">&#9670;&nbsp;</a></span>UnalignedbyteNonTemplate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>xorBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a word64 to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td>word64 value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a word64 value to an unaligned buffer. </p><dl class="section since"><dt>Since</dt><dd>Crypto++ 1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02735">2735</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a4d99806846ea2985b58a80497d8bfb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d99806846ea2985b58a80497d8bfb73">&#9670;&nbsp;</a></span>UnalignedbyteNonTemplate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnalignedbyteNonTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a6be079666bfaf77d4626038a7f2ae218">word128</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>xorBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a word128 to an unaligned buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>an unaligned output buffer </td></tr>
    <tr><td class="paramname">value</td><td>word128 value </td></tr>
    <tr><td class="paramname">xorBlock</td><td>optional unaligned xor buffer</td></tr>
  </table>
  </dd>
</dl>
<p>UnalignedbyteNonTemplate writes a word128 value to an unaligned buffer. </p><dl class="section note"><dt>Note</dt><dd>word128 is available on some 64-bit platforms when the compiler supports it. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02798">2798</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a240e8e97f964626508362b59b78532d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240e8e97f964626508362b59b78532d3">&#9670;&nbsp;</a></span>GetWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T GetWord </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumeAligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>the byte buffer to be processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the word in the specified byte order</dd></dl>
<p><a class="el" href="misc_8h.html#a240e8e97f964626508362b59b78532d3" title="Access a block of memory.">GetWord()</a> provides alternate read access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration ByteOrder is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER.</p>
<p>An example of reading two word32 values from a block of memory is shown below. <code>w</code> will be <code>0x03020100</code>. </p><pre>
  word32 w;
  byte buffer[4] = {0,1,2,3};
  w = GetWord&lt;word32&gt;(false, LITTLE_ENDIAN_ORDER, buffer);
</pre> 
<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02906">2906</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a4546cdeeecddedd3a0f784ea6b80c8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4546cdeeecddedd3a0f784ea6b80c8bd">&#9670;&nbsp;</a></span>GetWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetWord </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumeAligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">result</td><td>the word in the specified byte order </td></tr>
    <tr><td class="paramname">block</td><td>the byte buffer to be processed</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="misc_8h.html#a240e8e97f964626508362b59b78532d3" title="Access a block of memory.">GetWord()</a> provides alternate read access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration ByteOrder is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER.</p>
<p>An example of reading two word32 values from a block of memory is shown below. <code>w</code> will be <code>0x03020100</code>. </p><pre>
  word32 w;
  byte buffer[4] = {0,1,2,3};
  w = GetWord&lt;word32&gt;(false, LITTLE_ENDIAN_ORDER, buffer);
</pre> 
<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02932">2932</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="aef6a8d35198f71ff68811bacd599c664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6a8d35198f71ff68811bacd599c664">&#9670;&nbsp;</a></span>PutWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PutWord </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumeAligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>xorBlock</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>the destination byte buffer </td></tr>
    <tr><td class="paramname">value</td><td>the word in the specified byte order </td></tr>
    <tr><td class="paramname">xorBlock</td><td>an optional byte buffer to xor</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="misc_8h.html#aef6a8d35198f71ff68811bacd599c664" title="Access a block of memory.">PutWord()</a> provides alternate write access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration ByteOrder is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l02948">2948</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a18a35b59a1f2e23b94ed2f74f0594613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a35b59a1f2e23b94ed2f74f0594613">&#9670;&nbsp;</a></span>WordToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string WordToString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a word to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the word to convert </td></tr>
    <tr><td class="paramname">order</td><td>byte order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representing the value of the word </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l03065">3065</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a23234e96107b28512db9467c33f67590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23234e96107b28512db9467c33f67590">&#9670;&nbsp;</a></span>StringToWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T StringToWord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a word. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert </td></tr>
    <tr><td class="paramname">order</td><td>byte order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a word representing the value of the string </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l03079">3079</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="abda5071e4c754b612b6a4c42be421312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda5071e4c754b612b6a4c42be421312">&#9670;&nbsp;</a></span>SafeRightShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int bits, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SafeRightShift </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely right shift values when undefined behavior could occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bits</td><td>the number of bit positions to shift the value </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to right shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted value or 0</dd></dl>
<p>SafeRightShift safely shifts the value to the right when undefined behavior could occur under C/C++ rules. SafeRightShift will return the shifted value or 0 if undefined behavior would occur. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l03163">3163</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="a45e2662974095094e345b2bc2b30ee4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e2662974095094e345b2bc2b30ee4c">&#9670;&nbsp;</a></span>SafeLeftShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int bits, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SafeLeftShift </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely left shift values when undefined behavior could occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bits</td><td>the number of bit positions to shift the value </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to left shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted value or 0</dd></dl>
<p>SafeLeftShift safely shifts the value to the left when undefined behavior could occur under C/C++ rules. SafeLeftShift will return the shifted value or 0 if undefined behavior would occur. </p>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l03177">3177</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
<a id="ab29e4cf4553b1ff9f884df223a2abd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29e4cf4553b1ff9f884df223a2abd6a">&#9670;&nbsp;</a></span>FindIfNot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InputIt FindIfNot </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds first element not in a range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>Input iterator type </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to first element </td></tr>
    <tr><td class="paramname">last</td><td>iterator to last element </td></tr>
    <tr><td class="paramname">value</td><td>the value used as a predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element in the range that is not value </dd></dl>

<p class="definition">Definition at line <a class="el" href="misc_8h_source.html#l03190">3190</a> of file <a class="el" href="misc_8h_source.html">misc.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 26 2023 03:35:20 for Crypto++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
