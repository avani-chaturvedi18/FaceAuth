<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crypto++: ppc_simd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crypto++
   &#160;<span id="projectnumber">8.8</span>
   </div>
   <div id="projectbrief">Free&nbsp;C&#43;&#43;&nbsp;class&nbsp;library&nbsp;of&nbsp;cryptographic&nbsp;schemes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ppc_simd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support functions for PowerPC and vector operations.  
<a href="#details">More...</a></p>

<p><a href="ppc__simd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a97548e11947e4bd00686ec197a666072"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a97548e11947e4bd00686ec197a666072">CONST_V8_CAST</a>(x)&#160;&#160;&#160;((unsigned char*)(x))</td></tr>
<tr class="memdesc:a97548e11947e4bd00686ec197a666072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast array to vector pointer.  <a href="ppc__simd_8h.html#a97548e11947e4bd00686ec197a666072">More...</a><br /></td></tr>
<tr class="separator:a97548e11947e4bd00686ec197a666072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eaf9d07a972de6b857542f7061014f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ad2eaf9d07a972de6b857542f7061014f">CONST_V32_CAST</a>(x)&#160;&#160;&#160;((unsigned int*)(x))</td></tr>
<tr class="memdesc:ad2eaf9d07a972de6b857542f7061014f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast array to vector pointer.  <a href="ppc__simd_8h.html#ad2eaf9d07a972de6b857542f7061014f">More...</a><br /></td></tr>
<tr class="separator:ad2eaf9d07a972de6b857542f7061014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1e224c1b09c09c3e303d702aadd5b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#afc1e224c1b09c09c3e303d702aadd5b9">CONST_V64_CAST</a>(x)&#160;&#160;&#160;((unsigned long long*)(x))</td></tr>
<tr class="memdesc:afc1e224c1b09c09c3e303d702aadd5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast array to vector pointer.  <a href="ppc__simd_8h.html#afc1e224c1b09c09c3e303d702aadd5b9">More...</a><br /></td></tr>
<tr class="separator:afc1e224c1b09c09c3e303d702aadd5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace92283b301341abfa7d9f3654adb9f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ace92283b301341abfa7d9f3654adb9f1">NCONST_V8_CAST</a>(x)&#160;&#160;&#160;((unsigned char*)(x))</td></tr>
<tr class="memdesc:ace92283b301341abfa7d9f3654adb9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast array to vector pointer.  <a href="ppc__simd_8h.html#ace92283b301341abfa7d9f3654adb9f1">More...</a><br /></td></tr>
<tr class="separator:ace92283b301341abfa7d9f3654adb9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae67c0978cdac0cdc08cc99c20612b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a7ae67c0978cdac0cdc08cc99c20612b0">NCONST_V32_CAST</a>(x)&#160;&#160;&#160;((unsigned int*)(x))</td></tr>
<tr class="memdesc:a7ae67c0978cdac0cdc08cc99c20612b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast array to vector pointer.  <a href="ppc__simd_8h.html#a7ae67c0978cdac0cdc08cc99c20612b0">More...</a><br /></td></tr>
<tr class="separator:a7ae67c0978cdac0cdc08cc99c20612b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5702e2d0b6356860abea390e39b502"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#abe5702e2d0b6356860abea390e39b502">NCONST_V64_CAST</a>(x)&#160;&#160;&#160;((unsigned long long*)(x))</td></tr>
<tr class="memdesc:abe5702e2d0b6356860abea390e39b502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast array to vector pointer.  <a href="ppc__simd_8h.html#abe5702e2d0b6356860abea390e39b502">More...</a><br /></td></tr>
<tr class="separator:abe5702e2d0b6356860abea390e39b502"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6be79e9f5820422953c7a2a3df6c8879"><td class="memItemLeft" align="right" valign="top">typedef __vector unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a6be79e9f5820422953c7a2a3df6c8879">uint8x16_p</a></td></tr>
<tr class="memdesc:a6be79e9f5820422953c7a2a3df6c8879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of 8-bit elements.  <a href="ppc__simd_8h.html#a6be79e9f5820422953c7a2a3df6c8879">More...</a><br /></td></tr>
<tr class="separator:a6be79e9f5820422953c7a2a3df6c8879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74b7f16ff4b3e18dcbf2aeddccbf584"><td class="memItemLeft" align="right" valign="top">typedef __vector unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ae74b7f16ff4b3e18dcbf2aeddccbf584">uint16x8_p</a></td></tr>
<tr class="memdesc:ae74b7f16ff4b3e18dcbf2aeddccbf584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of 16-bit elements.  <a href="ppc__simd_8h.html#ae74b7f16ff4b3e18dcbf2aeddccbf584">More...</a><br /></td></tr>
<tr class="separator:ae74b7f16ff4b3e18dcbf2aeddccbf584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e56fac8b9dc01ebf52262069a3c94b5"><td class="memItemLeft" align="right" valign="top">typedef __vector unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a></td></tr>
<tr class="memdesc:a3e56fac8b9dc01ebf52262069a3c94b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of 32-bit elements.  <a href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">More...</a><br /></td></tr>
<tr class="separator:a3e56fac8b9dc01ebf52262069a3c94b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7876e27953f12ff20b5a51fc071b806f"><td class="memItemLeft" align="right" valign="top">typedef __vector unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a></td></tr>
<tr class="memdesc:a7876e27953f12ff20b5a51fc071b806f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of 64-bit elements.  <a href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">More...</a><br /></td></tr>
<tr class="separator:a7876e27953f12ff20b5a51fc071b806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a027d7006532e07217464e88608ec8c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a027d7006532e07217464e88608ec8c72">VecZero</a> ()</td></tr>
<tr class="memdesc:a027d7006532e07217464e88608ec8c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 0 vector.  <a href="ppc__simd_8h.html#a027d7006532e07217464e88608ec8c72">More...</a><br /></td></tr>
<tr class="separator:a027d7006532e07217464e88608ec8c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7128919d5191e68880f310892f7329c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ad7128919d5191e68880f310892f7329c">VecOne</a> ()</td></tr>
<tr class="memdesc:ad7128919d5191e68880f310892f7329c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 1 vector.  <a href="ppc__simd_8h.html#ad7128919d5191e68880f310892f7329c">More...</a><br /></td></tr>
<tr class="separator:ad7128919d5191e68880f310892f7329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d8d49aa8462c878fd011c2dfbac869"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad0d8d49aa8462c878fd011c2dfbac869"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ad0d8d49aa8462c878fd011c2dfbac869">VecReverse</a> (const T data)</td></tr>
<tr class="memdesc:ad0d8d49aa8462c878fd011c2dfbac869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse bytes in a vector.  <a href="ppc__simd_8h.html#ad0d8d49aa8462c878fd011c2dfbac869">More...</a><br /></td></tr>
<tr class="separator:ad0d8d49aa8462c878fd011c2dfbac869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfcde3b193a8fcdb1f4529140370ec5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5bfcde3b193a8fcdb1f4529140370ec5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a5bfcde3b193a8fcdb1f4529140370ec5">VecReverseLE</a> (const T data)</td></tr>
<tr class="memdesc:a5bfcde3b193a8fcdb1f4529140370ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse bytes in a vector.  <a href="ppc__simd_8h.html#a5bfcde3b193a8fcdb1f4529140370ec5">More...</a><br /></td></tr>
<tr class="separator:a5bfcde3b193a8fcdb1f4529140370ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89626d9392b07d0a1fd72e91acc4898"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad89626d9392b07d0a1fd72e91acc4898"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ad89626d9392b07d0a1fd72e91acc4898">VecReverseBE</a> (const T data)</td></tr>
<tr class="memdesc:ad89626d9392b07d0a1fd72e91acc4898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse bytes in a vector.  <a href="ppc__simd_8h.html#ad89626d9392b07d0a1fd72e91acc4898">More...</a><br /></td></tr>
<tr class="separator:ad89626d9392b07d0a1fd72e91acc4898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LOAD OPERATIONS</div></td></tr>
<tr class="memitem:a51cb0d533261142b52e065978d68233a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a">VecLoad_ALTIVEC</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:a51cb0d533261142b52e065978d68233a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a byte array.  <a href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a">More...</a><br /></td></tr>
<tr class="separator:a51cb0d533261142b52e065978d68233a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05902e3951fab32e1d9e2714801ac6cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a05902e3951fab32e1d9e2714801ac6cc">VecLoad_ALTIVEC</a> (int off, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:a05902e3951fab32e1d9e2714801ac6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a byte array.  <a href="ppc__simd_8h.html#a05902e3951fab32e1d9e2714801ac6cc">More...</a><br /></td></tr>
<tr class="separator:a05902e3951fab32e1d9e2714801ac6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e3b0006e46e86eb616d3ed9fdb694a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a">VecLoad</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:ae8e3b0006e46e86eb616d3ed9fdb694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a byte array.  <a href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a">More...</a><br /></td></tr>
<tr class="separator:ae8e3b0006e46e86eb616d3ed9fdb694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4648a88d47f71b3d0978c1df6af366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ada4648a88d47f71b3d0978c1df6af366">VecLoad</a> (int off, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:ada4648a88d47f71b3d0978c1df6af366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a byte array.  <a href="ppc__simd_8h.html#ada4648a88d47f71b3d0978c1df6af366">More...</a><br /></td></tr>
<tr class="separator:ada4648a88d47f71b3d0978c1df6af366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fe0a021524e332cd5b7ef807f63a7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a37fe0a021524e332cd5b7ef807f63a7f">VecLoad</a> (const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> src[4])</td></tr>
<tr class="memdesc:a37fe0a021524e332cd5b7ef807f63a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a word array.  <a href="ppc__simd_8h.html#a37fe0a021524e332cd5b7ef807f63a7f">More...</a><br /></td></tr>
<tr class="separator:a37fe0a021524e332cd5b7ef807f63a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3489f75b01ec6c3b7309196007e6c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a7a3489f75b01ec6c3b7309196007e6c8">VecLoad</a> (int off, const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> src[4])</td></tr>
<tr class="memdesc:a7a3489f75b01ec6c3b7309196007e6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a word array.  <a href="ppc__simd_8h.html#a7a3489f75b01ec6c3b7309196007e6c8">More...</a><br /></td></tr>
<tr class="separator:a7a3489f75b01ec6c3b7309196007e6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66864bda50cb08e12fd896c5422df353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a66864bda50cb08e12fd896c5422df353">VecLoad</a> (const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> src[2])</td></tr>
<tr class="memdesc:a66864bda50cb08e12fd896c5422df353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a double word array.  <a href="ppc__simd_8h.html#a66864bda50cb08e12fd896c5422df353">More...</a><br /></td></tr>
<tr class="separator:a66864bda50cb08e12fd896c5422df353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4122401a01366b69daf489b120c67cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aa4122401a01366b69daf489b120c67cd">VecLoad</a> (int off, const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> src[2])</td></tr>
<tr class="memdesc:aa4122401a01366b69daf489b120c67cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a double word array.  <a href="ppc__simd_8h.html#aa4122401a01366b69daf489b120c67cd">More...</a><br /></td></tr>
<tr class="separator:aa4122401a01366b69daf489b120c67cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184ecd6bcaf2def8525c7491bcc7f271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271">VecLoadAligned</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:a184ecd6bcaf2def8525c7491bcc7f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from an aligned byte array.  <a href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271">More...</a><br /></td></tr>
<tr class="separator:a184ecd6bcaf2def8525c7491bcc7f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1864f2d026c23b44b674114b4e26a0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a1864f2d026c23b44b674114b4e26a0d8">VecLoadAligned</a> (int off, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:a1864f2d026c23b44b674114b4e26a0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from an aligned byte array.  <a href="ppc__simd_8h.html#a1864f2d026c23b44b674114b4e26a0d8">More...</a><br /></td></tr>
<tr class="separator:a1864f2d026c23b44b674114b4e26a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bfa37f662dbfe6676323431bd3b485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#af4bfa37f662dbfe6676323431bd3b485">VecLoadAligned</a> (const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> src[4])</td></tr>
<tr class="memdesc:af4bfa37f662dbfe6676323431bd3b485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from an aligned word array.  <a href="ppc__simd_8h.html#af4bfa37f662dbfe6676323431bd3b485">More...</a><br /></td></tr>
<tr class="separator:af4bfa37f662dbfe6676323431bd3b485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8895bf28800a0e445524e6564a77865b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a8895bf28800a0e445524e6564a77865b">VecLoadAligned</a> (int off, const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> src[4])</td></tr>
<tr class="memdesc:a8895bf28800a0e445524e6564a77865b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from an aligned word array.  <a href="ppc__simd_8h.html#a8895bf28800a0e445524e6564a77865b">More...</a><br /></td></tr>
<tr class="separator:a8895bf28800a0e445524e6564a77865b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0405f7b31158b0bb9be5515812498590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a0405f7b31158b0bb9be5515812498590">VecLoadAligned</a> (const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> src[4])</td></tr>
<tr class="memdesc:a0405f7b31158b0bb9be5515812498590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from an aligned double word array.  <a href="ppc__simd_8h.html#a0405f7b31158b0bb9be5515812498590">More...</a><br /></td></tr>
<tr class="separator:a0405f7b31158b0bb9be5515812498590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af510c2c972bd5b9aa03d74bc409d5435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#af510c2c972bd5b9aa03d74bc409d5435">VecLoadAligned</a> (int off, const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> src[4])</td></tr>
<tr class="memdesc:af510c2c972bd5b9aa03d74bc409d5435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from an aligned double word array.  <a href="ppc__simd_8h.html#af510c2c972bd5b9aa03d74bc409d5435">More...</a><br /></td></tr>
<tr class="separator:af510c2c972bd5b9aa03d74bc409d5435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fef6722e8ea75a23f3beb203e0727f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a11fef6722e8ea75a23f3beb203e0727f">VecLoadBE</a> (const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:a11fef6722e8ea75a23f3beb203e0727f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a byte array.  <a href="ppc__simd_8h.html#a11fef6722e8ea75a23f3beb203e0727f">More...</a><br /></td></tr>
<tr class="separator:a11fef6722e8ea75a23f3beb203e0727f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bca1185babd6f401c65ed101d57ed69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a3bca1185babd6f401c65ed101d57ed69">VecLoadBE</a> (int off, const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> src[16])</td></tr>
<tr class="memdesc:a3bca1185babd6f401c65ed101d57ed69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector from a byte array.  <a href="ppc__simd_8h.html#a3bca1185babd6f401c65ed101d57ed69">More...</a><br /></td></tr>
<tr class="separator:a3bca1185babd6f401c65ed101d57ed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">STORE OPERATIONS</div></td></tr>
<tr class="memitem:a13aa322f4c2e69303e28262cdd8675d1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a13aa322f4c2e69303e28262cdd8675d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1">VecStore_ALTIVEC</a> (const T data, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:a13aa322f4c2e69303e28262cdd8675d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1">More...</a><br /></td></tr>
<tr class="separator:a13aa322f4c2e69303e28262cdd8675d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0c0c990eb17e5cb65de97fc178834"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac0e0c0c990eb17e5cb65de97fc178834"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ac0e0c0c990eb17e5cb65de97fc178834">VecStore_ALTIVEC</a> (const T data, int off, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:ac0e0c0c990eb17e5cb65de97fc178834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#ac0e0c0c990eb17e5cb65de97fc178834">More...</a><br /></td></tr>
<tr class="separator:ac0e0c0c990eb17e5cb65de97fc178834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf359f5ff034095346825ac55e8bc03c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acf359f5ff034095346825ac55e8bc03c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c">VecStore</a> (const T data, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:acf359f5ff034095346825ac55e8bc03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c">More...</a><br /></td></tr>
<tr class="separator:acf359f5ff034095346825ac55e8bc03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67780e671eb9433426054af5a4dbfc21"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a67780e671eb9433426054af5a4dbfc21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a67780e671eb9433426054af5a4dbfc21">VecStore</a> (const T data, int off, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:a67780e671eb9433426054af5a4dbfc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#a67780e671eb9433426054af5a4dbfc21">More...</a><br /></td></tr>
<tr class="separator:a67780e671eb9433426054af5a4dbfc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2144982832b9eb200bab0c3d55e783"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2c2144982832b9eb200bab0c3d55e783"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a2c2144982832b9eb200bab0c3d55e783">VecStore</a> (const T data, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> dest[4])</td></tr>
<tr class="memdesc:a2c2144982832b9eb200bab0c3d55e783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#a2c2144982832b9eb200bab0c3d55e783">More...</a><br /></td></tr>
<tr class="separator:a2c2144982832b9eb200bab0c3d55e783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4af7702cb870596c5474c9657e69a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8a4af7702cb870596c5474c9657e69a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a8a4af7702cb870596c5474c9657e69a0">VecStore</a> (const T data, int off, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> dest[4])</td></tr>
<tr class="memdesc:a8a4af7702cb870596c5474c9657e69a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#a8a4af7702cb870596c5474c9657e69a0">More...</a><br /></td></tr>
<tr class="separator:a8a4af7702cb870596c5474c9657e69a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a05734fb91fb72c818be5c1258a55"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a615a05734fb91fb72c818be5c1258a55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a615a05734fb91fb72c818be5c1258a55">VecStore</a> (const T data, <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> dest[2])</td></tr>
<tr class="memdesc:a615a05734fb91fb72c818be5c1258a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#a615a05734fb91fb72c818be5c1258a55">More...</a><br /></td></tr>
<tr class="separator:a615a05734fb91fb72c818be5c1258a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0816fafd4937fadede4c0161e261d415"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0816fafd4937fadede4c0161e261d415"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a0816fafd4937fadede4c0161e261d415">VecStore</a> (const T data, int off, <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> dest[2])</td></tr>
<tr class="memdesc:a0816fafd4937fadede4c0161e261d415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#a0816fafd4937fadede4c0161e261d415">More...</a><br /></td></tr>
<tr class="separator:a0816fafd4937fadede4c0161e261d415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a71bdae510d63e87bdf1524512f04db"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7a71bdae510d63e87bdf1524512f04db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db">VecStoreAligned</a> (const T data, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:a7a71bdae510d63e87bdf1524512f04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db">More...</a><br /></td></tr>
<tr class="separator:a7a71bdae510d63e87bdf1524512f04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf334500b225fd2f4f76e1123251787"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8bf334500b225fd2f4f76e1123251787"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a8bf334500b225fd2f4f76e1123251787">VecStoreAligned</a> (const T data, int off, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:a8bf334500b225fd2f4f76e1123251787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#a8bf334500b225fd2f4f76e1123251787">More...</a><br /></td></tr>
<tr class="separator:a8bf334500b225fd2f4f76e1123251787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec651f226a41d227ede694c192eb1dd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afec651f226a41d227ede694c192eb1dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#afec651f226a41d227ede694c192eb1dd">VecStoreAligned</a> (const T data, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> dest[4])</td></tr>
<tr class="memdesc:afec651f226a41d227ede694c192eb1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#afec651f226a41d227ede694c192eb1dd">More...</a><br /></td></tr>
<tr class="separator:afec651f226a41d227ede694c192eb1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ad754906f7edacd0f088ef50a3143d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a68ad754906f7edacd0f088ef50a3143d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a68ad754906f7edacd0f088ef50a3143d">VecStoreAligned</a> (const T data, int off, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> dest[4])</td></tr>
<tr class="memdesc:a68ad754906f7edacd0f088ef50a3143d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#a68ad754906f7edacd0f088ef50a3143d">More...</a><br /></td></tr>
<tr class="separator:a68ad754906f7edacd0f088ef50a3143d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ce12e2a56d8858a05f19f0481238a2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a44ce12e2a56d8858a05f19f0481238a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2">VecStoreBE</a> (const T data, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:a44ce12e2a56d8858a05f19f0481238a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2">More...</a><br /></td></tr>
<tr class="separator:a44ce12e2a56d8858a05f19f0481238a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacff6b8db3a9a2be2bf28f068ba9a0f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adacff6b8db3a9a2be2bf28f068ba9a0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#adacff6b8db3a9a2be2bf28f068ba9a0f">VecStoreBE</a> (const T data, int off, <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dest[16])</td></tr>
<tr class="memdesc:adacff6b8db3a9a2be2bf28f068ba9a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a byte array.  <a href="ppc__simd_8h.html#adacff6b8db3a9a2be2bf28f068ba9a0f">More...</a><br /></td></tr>
<tr class="separator:adacff6b8db3a9a2be2bf28f068ba9a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268f8efc395bb27ccc142095baa4f776"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a268f8efc395bb27ccc142095baa4f776"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a268f8efc395bb27ccc142095baa4f776">VecStoreBE</a> (const T data, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> dest[4])</td></tr>
<tr class="memdesc:a268f8efc395bb27ccc142095baa4f776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#a268f8efc395bb27ccc142095baa4f776">More...</a><br /></td></tr>
<tr class="separator:a268f8efc395bb27ccc142095baa4f776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5994615461a77e14b513ade7e85e5cbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5994615461a77e14b513ade7e85e5cbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a5994615461a77e14b513ade7e85e5cbc">VecStoreBE</a> (const T data, int off, <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> dest[4])</td></tr>
<tr class="memdesc:a5994615461a77e14b513ade7e85e5cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a vector to a word array.  <a href="ppc__simd_8h.html#a5994615461a77e14b513ade7e85e5cbc">More...</a><br /></td></tr>
<tr class="separator:a5994615461a77e14b513ade7e85e5cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LOGICAL OPERATIONS</div></td></tr>
<tr class="memitem:abf26bb56e3d6282e5c5b66a4b84bf560"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:abf26bb56e3d6282e5c5b66a4b84bf560"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#abf26bb56e3d6282e5c5b66a4b84bf560">VecAnd</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:abf26bb56e3d6282e5c5b66a4b84bf560"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND two vectors.  <a href="ppc__simd_8h.html#abf26bb56e3d6282e5c5b66a4b84bf560">More...</a><br /></td></tr>
<tr class="separator:abf26bb56e3d6282e5c5b66a4b84bf560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07efaef961b78aa09784e70ac4d17390"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a07efaef961b78aa09784e70ac4d17390"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a07efaef961b78aa09784e70ac4d17390">VecOr</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:a07efaef961b78aa09784e70ac4d17390"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR two vectors.  <a href="ppc__simd_8h.html#a07efaef961b78aa09784e70ac4d17390">More...</a><br /></td></tr>
<tr class="separator:a07efaef961b78aa09784e70ac4d17390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7362c0e6f4db03045b4494f95cb40703"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a7362c0e6f4db03045b4494f95cb40703"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a7362c0e6f4db03045b4494f95cb40703">VecXor</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:a7362c0e6f4db03045b4494f95cb40703"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR two vectors.  <a href="ppc__simd_8h.html#a7362c0e6f4db03045b4494f95cb40703">More...</a><br /></td></tr>
<tr class="separator:a7362c0e6f4db03045b4494f95cb40703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ARITHMETIC OPERATIONS</div></td></tr>
<tr class="memitem:aae6c1e5e6a88c823a32007a0c3c0a9e1"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aae6c1e5e6a88c823a32007a0c3c0a9e1"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aae6c1e5e6a88c823a32007a0c3c0a9e1">VecAdd</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:aae6c1e5e6a88c823a32007a0c3c0a9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two vectors.  <a href="ppc__simd_8h.html#aae6c1e5e6a88c823a32007a0c3c0a9e1">More...</a><br /></td></tr>
<tr class="separator:aae6c1e5e6a88c823a32007a0c3c0a9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7896c9252403ed7ba3e075a1014269c9"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a7896c9252403ed7ba3e075a1014269c9"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a7896c9252403ed7ba3e075a1014269c9">VecSub</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:a7896c9252403ed7ba3e075a1014269c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors.  <a href="ppc__simd_8h.html#a7896c9252403ed7ba3e075a1014269c9">More...</a><br /></td></tr>
<tr class="separator:a7896c9252403ed7ba3e075a1014269c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PERMUTE OPERATIONS</div></td></tr>
<tr class="memitem:a56df7ee710906a4f93354363c9ca8de5"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a56df7ee710906a4f93354363c9ca8de5"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a56df7ee710906a4f93354363c9ca8de5">VecPermute</a> (const T1 vec, const T2 mask)</td></tr>
<tr class="memdesc:a56df7ee710906a4f93354363c9ca8de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes a vector.  <a href="ppc__simd_8h.html#a56df7ee710906a4f93354363c9ca8de5">More...</a><br /></td></tr>
<tr class="separator:a56df7ee710906a4f93354363c9ca8de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ad87962002239b443f56b894e695ed"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a32ad87962002239b443f56b894e695ed"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a32ad87962002239b443f56b894e695ed">VecPermute</a> (const T1 vec1, const T1 vec2, const T2 mask)</td></tr>
<tr class="memdesc:a32ad87962002239b443f56b894e695ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes two vectors.  <a href="ppc__simd_8h.html#a32ad87962002239b443f56b894e695ed">More...</a><br /></td></tr>
<tr class="separator:a32ad87962002239b443f56b894e695ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SHIFT AND ROTATE OPERATIONS</div></td></tr>
<tr class="memitem:a469cfebbcd8c8f214f4fc747f784f94b"><td class="memTemplParams" colspan="2">template&lt;unsigned int C, class T &gt; </td></tr>
<tr class="memitem:a469cfebbcd8c8f214f4fc747f784f94b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a469cfebbcd8c8f214f4fc747f784f94b">VecShiftLeftOctet</a> (const T vec)</td></tr>
<tr class="memdesc:a469cfebbcd8c8f214f4fc747f784f94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a vector left.  <a href="ppc__simd_8h.html#a469cfebbcd8c8f214f4fc747f784f94b">More...</a><br /></td></tr>
<tr class="separator:a469cfebbcd8c8f214f4fc747f784f94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661ff89afa1f0e9cc0855e10e407798"><td class="memTemplParams" colspan="2">template&lt;unsigned int C, class T &gt; </td></tr>
<tr class="memitem:a3661ff89afa1f0e9cc0855e10e407798"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a3661ff89afa1f0e9cc0855e10e407798">VecShiftRightOctet</a> (const T vec)</td></tr>
<tr class="memdesc:a3661ff89afa1f0e9cc0855e10e407798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a vector right.  <a href="ppc__simd_8h.html#a3661ff89afa1f0e9cc0855e10e407798">More...</a><br /></td></tr>
<tr class="separator:a3661ff89afa1f0e9cc0855e10e407798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab048d9b974c5ee4ad1ccaafb938981eb"><td class="memTemplParams" colspan="2">template&lt;unsigned int C, class T &gt; </td></tr>
<tr class="memitem:ab048d9b974c5ee4ad1ccaafb938981eb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ab048d9b974c5ee4ad1ccaafb938981eb">VecRotateLeftOctet</a> (const T vec)</td></tr>
<tr class="memdesc:ab048d9b974c5ee4ad1ccaafb938981eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector left.  <a href="ppc__simd_8h.html#ab048d9b974c5ee4ad1ccaafb938981eb">More...</a><br /></td></tr>
<tr class="separator:ab048d9b974c5ee4ad1ccaafb938981eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ddf02b2b8dabdbc0e2aba8df5a643"><td class="memTemplParams" colspan="2">template&lt;unsigned int C, class T &gt; </td></tr>
<tr class="memitem:a1b2ddf02b2b8dabdbc0e2aba8df5a643"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a1b2ddf02b2b8dabdbc0e2aba8df5a643">VecRotateRightOctet</a> (const T vec)</td></tr>
<tr class="memdesc:a1b2ddf02b2b8dabdbc0e2aba8df5a643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector right.  <a href="ppc__simd_8h.html#a1b2ddf02b2b8dabdbc0e2aba8df5a643">More...</a><br /></td></tr>
<tr class="separator:a1b2ddf02b2b8dabdbc0e2aba8df5a643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8592222d59b4fad19ce9d3794a7391"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:aaf8592222d59b4fad19ce9d3794a7391"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aaf8592222d59b4fad19ce9d3794a7391">VecRotateLeft</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:aaf8592222d59b4fad19ce9d3794a7391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector left.  <a href="ppc__simd_8h.html#aaf8592222d59b4fad19ce9d3794a7391">More...</a><br /></td></tr>
<tr class="separator:aaf8592222d59b4fad19ce9d3794a7391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ce5bef0bc70e2e0eaeaa7c48bfabdd"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:a05ce5bef0bc70e2e0eaeaa7c48bfabdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a05ce5bef0bc70e2e0eaeaa7c48bfabdd">VecRotateRight</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:a05ce5bef0bc70e2e0eaeaa7c48bfabdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector right.  <a href="ppc__simd_8h.html#a05ce5bef0bc70e2e0eaeaa7c48bfabdd">More...</a><br /></td></tr>
<tr class="separator:a05ce5bef0bc70e2e0eaeaa7c48bfabdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2250720fa9fad419822563334701572"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:ad2250720fa9fad419822563334701572"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ad2250720fa9fad419822563334701572">VecShiftLeft</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:ad2250720fa9fad419822563334701572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a vector left.  <a href="ppc__simd_8h.html#ad2250720fa9fad419822563334701572">More...</a><br /></td></tr>
<tr class="separator:ad2250720fa9fad419822563334701572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac057d935ba15243deb16d14f61b27eb2"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:ac057d935ba15243deb16d14f61b27eb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ac057d935ba15243deb16d14f61b27eb2">VecShiftRight</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:ac057d935ba15243deb16d14f61b27eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a vector right.  <a href="ppc__simd_8h.html#ac057d935ba15243deb16d14f61b27eb2">More...</a><br /></td></tr>
<tr class="separator:ac057d935ba15243deb16d14f61b27eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e8bc087867053f20bb8d963e869557"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:ac2e8bc087867053f20bb8d963e869557"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ac2e8bc087867053f20bb8d963e869557">VecRotateLeft</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> vec)</td></tr>
<tr class="memdesc:ac2e8bc087867053f20bb8d963e869557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector left.  <a href="ppc__simd_8h.html#ac2e8bc087867053f20bb8d963e869557">More...</a><br /></td></tr>
<tr class="separator:ac2e8bc087867053f20bb8d963e869557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964daf4c5415d4acc4c7c43eb6d1f323"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:a964daf4c5415d4acc4c7c43eb6d1f323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a964daf4c5415d4acc4c7c43eb6d1f323">VecShiftLeft</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> vec)</td></tr>
<tr class="memdesc:a964daf4c5415d4acc4c7c43eb6d1f323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a vector left.  <a href="ppc__simd_8h.html#a964daf4c5415d4acc4c7c43eb6d1f323">More...</a><br /></td></tr>
<tr class="separator:a964daf4c5415d4acc4c7c43eb6d1f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027e58c6c5caee099812379d6c26d4b0"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:a027e58c6c5caee099812379d6c26d4b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a027e58c6c5caee099812379d6c26d4b0">VecRotateRight</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> vec)</td></tr>
<tr class="memdesc:a027e58c6c5caee099812379d6c26d4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector right.  <a href="ppc__simd_8h.html#a027e58c6c5caee099812379d6c26d4b0">More...</a><br /></td></tr>
<tr class="separator:a027e58c6c5caee099812379d6c26d4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c659aa307c8eccbe1073e36edb2463a"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:a5c659aa307c8eccbe1073e36edb2463a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a5c659aa307c8eccbe1073e36edb2463a">VecShiftRight</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> vec)</td></tr>
<tr class="memdesc:a5c659aa307c8eccbe1073e36edb2463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a vector right.  <a href="ppc__simd_8h.html#a5c659aa307c8eccbe1073e36edb2463a">More...</a><br /></td></tr>
<tr class="separator:a5c659aa307c8eccbe1073e36edb2463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">OTHER OPERATIONS</div></td></tr>
<tr class="memitem:a8c9b7e7aec57f821e658f871b2553ba3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8c9b7e7aec57f821e658f871b2553ba3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a8c9b7e7aec57f821e658f871b2553ba3">VecMergeLow</a> (const T vec1, const T vec2)</td></tr>
<tr class="memdesc:a8c9b7e7aec57f821e658f871b2553ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two vectors.  <a href="ppc__simd_8h.html#a8c9b7e7aec57f821e658f871b2553ba3">More...</a><br /></td></tr>
<tr class="separator:a8c9b7e7aec57f821e658f871b2553ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce8f92de942669891c4189f1213e84b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ce8f92de942669891c4189f1213e84b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a5ce8f92de942669891c4189f1213e84b">VecMergeHigh</a> (const T vec1, const T vec2)</td></tr>
<tr class="memdesc:a5ce8f92de942669891c4189f1213e84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two vectors.  <a href="ppc__simd_8h.html#a5ce8f92de942669891c4189f1213e84b">More...</a><br /></td></tr>
<tr class="separator:a5ce8f92de942669891c4189f1213e84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4081a2ff8dac47ec38056d38fcec8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ad4081a2ff8dac47ec38056d38fcec8a7">VecSplatWord</a> (<a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a> val)</td></tr>
<tr class="memdesc:ad4081a2ff8dac47ec38056d38fcec8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast 32-bit word to a vector.  <a href="ppc__simd_8h.html#ad4081a2ff8dac47ec38056d38fcec8a7">More...</a><br /></td></tr>
<tr class="separator:ad4081a2ff8dac47ec38056d38fcec8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677f48a5fe5ea5e6e646d93ed22107a4"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a677f48a5fe5ea5e6e646d93ed22107a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a677f48a5fe5ea5e6e646d93ed22107a4">VecSplatElement</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> val)</td></tr>
<tr class="memdesc:a677f48a5fe5ea5e6e646d93ed22107a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast 32-bit element to a vector.  <a href="ppc__simd_8h.html#a677f48a5fe5ea5e6e646d93ed22107a4">More...</a><br /></td></tr>
<tr class="separator:a677f48a5fe5ea5e6e646d93ed22107a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca290c21b235c0b7debbc4362821be29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aca290c21b235c0b7debbc4362821be29">VecSplatWord</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> val)</td></tr>
<tr class="memdesc:aca290c21b235c0b7debbc4362821be29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast 64-bit double word to a vector.  <a href="ppc__simd_8h.html#aca290c21b235c0b7debbc4362821be29">More...</a><br /></td></tr>
<tr class="separator:aca290c21b235c0b7debbc4362821be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce79cce8ad3c2e58150f656a231cb2f"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a6ce79cce8ad3c2e58150f656a231cb2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a6ce79cce8ad3c2e58150f656a231cb2f">VecSplatElement</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> val)</td></tr>
<tr class="memdesc:a6ce79cce8ad3c2e58150f656a231cb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast 64-bit element to a vector.  <a href="ppc__simd_8h.html#a6ce79cce8ad3c2e58150f656a231cb2f">More...</a><br /></td></tr>
<tr class="separator:a6ce79cce8ad3c2e58150f656a231cb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbba4043401fd967d05ad5a6e55cef2d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbba4043401fd967d05ad5a6e55cef2d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#adbba4043401fd967d05ad5a6e55cef2d">VecGetLow</a> (const T val)</td></tr>
<tr class="memdesc:adbba4043401fd967d05ad5a6e55cef2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a dword from a vector.  <a href="ppc__simd_8h.html#adbba4043401fd967d05ad5a6e55cef2d">More...</a><br /></td></tr>
<tr class="separator:adbba4043401fd967d05ad5a6e55cef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2436f7f3ccc994751d7920407db08b9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac2436f7f3ccc994751d7920407db08b9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ac2436f7f3ccc994751d7920407db08b9">VecGetHigh</a> (const T val)</td></tr>
<tr class="memdesc:ac2436f7f3ccc994751d7920407db08b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a dword from a vector.  <a href="ppc__simd_8h.html#ac2436f7f3ccc994751d7920407db08b9">More...</a><br /></td></tr>
<tr class="separator:ac2436f7f3ccc994751d7920407db08b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf36aabc9cb455ad6624116ccb53d0d6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adf36aabc9cb455ad6624116ccb53d0d6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#adf36aabc9cb455ad6624116ccb53d0d6">VecSwapWords</a> (const T vec)</td></tr>
<tr class="memdesc:adf36aabc9cb455ad6624116ccb53d0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange high and low double words.  <a href="ppc__simd_8h.html#adf36aabc9cb455ad6624116ccb53d0d6">More...</a><br /></td></tr>
<tr class="separator:adf36aabc9cb455ad6624116ccb53d0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">COMPARISON</div></td></tr>
<tr class="memitem:a864d97431e3db3ec27b6ad21efc55462"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a864d97431e3db3ec27b6ad21efc55462"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a864d97431e3db3ec27b6ad21efc55462">VecEqual</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:a864d97431e3db3ec27b6ad21efc55462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors.  <a href="ppc__simd_8h.html#a864d97431e3db3ec27b6ad21efc55462">More...</a><br /></td></tr>
<tr class="separator:a864d97431e3db3ec27b6ad21efc55462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e74d1938c7332842f9063991e79f943"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a6e74d1938c7332842f9063991e79f943"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a6e74d1938c7332842f9063991e79f943">VecNotEqual</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:a6e74d1938c7332842f9063991e79f943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors.  <a href="ppc__simd_8h.html#a6e74d1938c7332842f9063991e79f943">More...</a><br /></td></tr>
<tr class="separator:a6e74d1938c7332842f9063991e79f943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">32-BIT ALTIVEC</div></td></tr>
<tr class="memitem:adcd5971860bdc65c231e829273a0d5a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9">VecAdd64</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;vec1, const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;vec2)</td></tr>
<tr class="memdesc:adcd5971860bdc65c231e829273a0d5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two vectors as if uint64x2_p.  <a href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9">More...</a><br /></td></tr>
<tr class="separator:adcd5971860bdc65c231e829273a0d5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcba635b7b2f17245df087155a84fc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a4bcba635b7b2f17245df087155a84fc6">VecAdd64</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;vec1, const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;vec2)</td></tr>
<tr class="memdesc:a4bcba635b7b2f17245df087155a84fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two vectors as if uint64x2_p.  <a href="ppc__simd_8h.html#a4bcba635b7b2f17245df087155a84fc6">More...</a><br /></td></tr>
<tr class="separator:a4bcba635b7b2f17245df087155a84fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7afbcd6b0048e844e428183b93de45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45">VecSub64</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;vec1, const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;vec2)</td></tr>
<tr class="memdesc:a4d7afbcd6b0048e844e428183b93de45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors as if uint64x2_p.  <a href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45">More...</a><br /></td></tr>
<tr class="separator:a4d7afbcd6b0048e844e428183b93de45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade597df1125ccc71578d88bcf6e2e7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ade597df1125ccc71578d88bcf6e2e7e6">VecSub64</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;vec1, const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;vec2)</td></tr>
<tr class="memdesc:ade597df1125ccc71578d88bcf6e2e7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors as if uint64x2_p.  <a href="ppc__simd_8h.html#ade597df1125ccc71578d88bcf6e2e7e6">More...</a><br /></td></tr>
<tr class="separator:ade597df1125ccc71578d88bcf6e2e7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba7edd170438cdede9dcf621c923fd0"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:aeba7edd170438cdede9dcf621c923fd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aeba7edd170438cdede9dcf621c923fd0">VecRotateLeft64</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:aeba7edd170438cdede9dcf621c923fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector left as if uint64x2_p.  <a href="ppc__simd_8h.html#aeba7edd170438cdede9dcf621c923fd0">More...</a><br /></td></tr>
<tr class="separator:aeba7edd170438cdede9dcf621c923fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26b992d6223631cf3caddfa83337966"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af26b992d6223631cf3caddfa83337966"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#af26b992d6223631cf3caddfa83337966">VecRotateLeft64&lt; 8 &gt;</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:af26b992d6223631cf3caddfa83337966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector left as if uint64x2_p.  <a href="ppc__simd_8h.html#af26b992d6223631cf3caddfa83337966">More...</a><br /></td></tr>
<tr class="separator:af26b992d6223631cf3caddfa83337966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf638bab6918779a91b0e642abe6760"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:a6cf638bab6918779a91b0e642abe6760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a6cf638bab6918779a91b0e642abe6760">VecRotateLeft64</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> vec)</td></tr>
<tr class="memdesc:a6cf638bab6918779a91b0e642abe6760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector left as if uint64x2_p.  <a href="ppc__simd_8h.html#a6cf638bab6918779a91b0e642abe6760">More...</a><br /></td></tr>
<tr class="separator:a6cf638bab6918779a91b0e642abe6760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8452d7e1ae60f71a47d3d9108e5ef3"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:aad8452d7e1ae60f71a47d3d9108e5ef3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aad8452d7e1ae60f71a47d3d9108e5ef3">VecRotateRight64</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:aad8452d7e1ae60f71a47d3d9108e5ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector right as if uint64x2_p.  <a href="ppc__simd_8h.html#aad8452d7e1ae60f71a47d3d9108e5ef3">More...</a><br /></td></tr>
<tr class="separator:aad8452d7e1ae60f71a47d3d9108e5ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac318238ea84b4c264c76843fff85b1a0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac318238ea84b4c264c76843fff85b1a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ac318238ea84b4c264c76843fff85b1a0">VecRotateRight64&lt; 8 &gt;</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> vec)</td></tr>
<tr class="memdesc:ac318238ea84b4c264c76843fff85b1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector right as if uint64x2_p.  <a href="ppc__simd_8h.html#ac318238ea84b4c264c76843fff85b1a0">More...</a><br /></td></tr>
<tr class="separator:ac318238ea84b4c264c76843fff85b1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba94b554b6ee4d46a401e6f12557aed"><td class="memTemplParams" colspan="2">template&lt;unsigned int C&gt; </td></tr>
<tr class="memitem:a6ba94b554b6ee4d46a401e6f12557aed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a6ba94b554b6ee4d46a401e6f12557aed">VecRotateRight64</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> vec)</td></tr>
<tr class="memdesc:a6ba94b554b6ee4d46a401e6f12557aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector right as if uint64x2_p.  <a href="ppc__simd_8h.html#a6ba94b554b6ee4d46a401e6f12557aed">More...</a><br /></td></tr>
<tr class="separator:a6ba94b554b6ee4d46a401e6f12557aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc6eab6ce4db027ba00fc72ebe87c3"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afbcc6eab6ce4db027ba00fc72ebe87c3"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#afbcc6eab6ce4db027ba00fc72ebe87c3">VecAnd64</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:afbcc6eab6ce4db027ba00fc72ebe87c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND two vectors as if uint64x2_p.  <a href="ppc__simd_8h.html#afbcc6eab6ce4db027ba00fc72ebe87c3">More...</a><br /></td></tr>
<tr class="separator:afbcc6eab6ce4db027ba00fc72ebe87c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f2e61d731d679a5d9d526a007c17fd"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a15f2e61d731d679a5d9d526a007c17fd"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a15f2e61d731d679a5d9d526a007c17fd">VecOr64</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:a15f2e61d731d679a5d9d526a007c17fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR two vectors as if uint64x2_p.  <a href="ppc__simd_8h.html#a15f2e61d731d679a5d9d526a007c17fd">More...</a><br /></td></tr>
<tr class="separator:a15f2e61d731d679a5d9d526a007c17fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac4e5e7af3ea6f274f4b46f0f48a5d0"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a9ac4e5e7af3ea6f274f4b46f0f48a5d0"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a9ac4e5e7af3ea6f274f4b46f0f48a5d0">VecXor64</a> (const T1 vec1, const T2 vec2)</td></tr>
<tr class="memdesc:a9ac4e5e7af3ea6f274f4b46f0f48a5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR two vectors as if uint64x2_p.  <a href="ppc__simd_8h.html#a9ac4e5e7af3ea6f274f4b46f0f48a5d0">More...</a><br /></td></tr>
<tr class="separator:a9ac4e5e7af3ea6f274f4b46f0f48a5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba778788d5d08592aa7473da8a022656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aba778788d5d08592aa7473da8a022656">VecSplatWord64</a> (<a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a> val)</td></tr>
<tr class="memdesc:aba778788d5d08592aa7473da8a022656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast 64-bit double word to a vector.  <a href="ppc__simd_8h.html#aba778788d5d08592aa7473da8a022656">More...</a><br /></td></tr>
<tr class="separator:aba778788d5d08592aa7473da8a022656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1fa7abbfda042f0c5e3d030686772c"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8c1fa7abbfda042f0c5e3d030686772c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a8c1fa7abbfda042f0c5e3d030686772c">VecSplatElement64</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> val)</td></tr>
<tr class="memdesc:a8c1fa7abbfda042f0c5e3d030686772c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast 64-bit element to a vector as if uint64x2_p.  <a href="ppc__simd_8h.html#a8c1fa7abbfda042f0c5e3d030686772c">More...</a><br /></td></tr>
<tr class="separator:a8c1fa7abbfda042f0c5e3d030686772c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae433f2f8182668e016d3f75fc94e597e"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae433f2f8182668e016d3f75fc94e597e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ae433f2f8182668e016d3f75fc94e597e">VecSplatElement64</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> val)</td></tr>
<tr class="memdesc:ae433f2f8182668e016d3f75fc94e597e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast 64-bit element to a vector.  <a href="ppc__simd_8h.html#ae433f2f8182668e016d3f75fc94e597e">More...</a><br /></td></tr>
<tr class="separator:ae433f2f8182668e016d3f75fc94e597e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">POLYNOMIAL MULTIPLICATION</div></td></tr>
<tr class="memitem:aa1b420043a17199bdf544a7d4ffc4f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aa1b420043a17199bdf544a7d4ffc4f02">VecPolyMultiply</a> (const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;a, const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;b)</td></tr>
<tr class="memdesc:aa1b420043a17199bdf544a7d4ffc4f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial multiplication.  <a href="ppc__simd_8h.html#aa1b420043a17199bdf544a7d4ffc4f02">More...</a><br /></td></tr>
<tr class="separator:aa1b420043a17199bdf544a7d4ffc4f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa887a8e880e10ba42668ead47adb6d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aa887a8e880e10ba42668ead47adb6d50">VecPolyMultiply</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;a, const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;b)</td></tr>
<tr class="memdesc:aa887a8e880e10ba42668ead47adb6d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial multiplication.  <a href="ppc__simd_8h.html#aa887a8e880e10ba42668ead47adb6d50">More...</a><br /></td></tr>
<tr class="separator:aa887a8e880e10ba42668ead47adb6d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590c82896ba5e7136ba487849f68be75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a590c82896ba5e7136ba487849f68be75">VecIntelMultiply00</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;a, const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;b)</td></tr>
<tr class="memdesc:a590c82896ba5e7136ba487849f68be75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial multiplication.  <a href="ppc__simd_8h.html#a590c82896ba5e7136ba487849f68be75">More...</a><br /></td></tr>
<tr class="separator:a590c82896ba5e7136ba487849f68be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad553d4e74a0b97c311fdd867ff9d167b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ad553d4e74a0b97c311fdd867ff9d167b">VecIntelMultiply01</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;a, const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;b)</td></tr>
<tr class="memdesc:ad553d4e74a0b97c311fdd867ff9d167b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial multiplication.  <a href="ppc__simd_8h.html#ad553d4e74a0b97c311fdd867ff9d167b">More...</a><br /></td></tr>
<tr class="separator:ad553d4e74a0b97c311fdd867ff9d167b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1de89001d67af434e518410eb7f327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aef1de89001d67af434e518410eb7f327">VecIntelMultiply10</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;a, const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;b)</td></tr>
<tr class="memdesc:aef1de89001d67af434e518410eb7f327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial multiplication.  <a href="ppc__simd_8h.html#aef1de89001d67af434e518410eb7f327">More...</a><br /></td></tr>
<tr class="separator:aef1de89001d67af434e518410eb7f327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2604575828d21db939e48e3094a96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#abd2604575828d21db939e48e3094a96e">VecIntelMultiply11</a> (const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;a, const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;b)</td></tr>
<tr class="memdesc:abd2604575828d21db939e48e3094a96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial multiplication.  <a href="ppc__simd_8h.html#abd2604575828d21db939e48e3094a96e">More...</a><br /></td></tr>
<tr class="separator:abd2604575828d21db939e48e3094a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AES ENCRYPTION</div></td></tr>
<tr class="memitem:a9cf39f0fa5e645b5fc10006edad213ce"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a9cf39f0fa5e645b5fc10006edad213ce"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a9cf39f0fa5e645b5fc10006edad213ce">VecEncrypt</a> (const T1 state, const T2 key)</td></tr>
<tr class="memdesc:a9cf39f0fa5e645b5fc10006edad213ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">One round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> encryption.  <a href="ppc__simd_8h.html#a9cf39f0fa5e645b5fc10006edad213ce">More...</a><br /></td></tr>
<tr class="separator:a9cf39f0fa5e645b5fc10006edad213ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886160a705218fa1ae729455beaa7d5c"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a886160a705218fa1ae729455beaa7d5c"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a886160a705218fa1ae729455beaa7d5c">VecEncryptLast</a> (const T1 state, const T2 key)</td></tr>
<tr class="memdesc:a886160a705218fa1ae729455beaa7d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> encryption.  <a href="ppc__simd_8h.html#a886160a705218fa1ae729455beaa7d5c">More...</a><br /></td></tr>
<tr class="separator:a886160a705218fa1ae729455beaa7d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70e069364abc93f0670aa73a3d25dea"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ac70e069364abc93f0670aa73a3d25dea"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#ac70e069364abc93f0670aa73a3d25dea">VecDecrypt</a> (const T1 state, const T2 key)</td></tr>
<tr class="memdesc:ac70e069364abc93f0670aa73a3d25dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">One round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> decryption.  <a href="ppc__simd_8h.html#ac70e069364abc93f0670aa73a3d25dea">More...</a><br /></td></tr>
<tr class="separator:ac70e069364abc93f0670aa73a3d25dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19f8349a89c7383b15bfa06907e8460"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aa19f8349a89c7383b15bfa06907e8460"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#aa19f8349a89c7383b15bfa06907e8460">VecDecryptLast</a> (const T1 state, const T2 key)</td></tr>
<tr class="memdesc:aa19f8349a89c7383b15bfa06907e8460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> decryption.  <a href="ppc__simd_8h.html#aa19f8349a89c7383b15bfa06907e8460">More...</a><br /></td></tr>
<tr class="separator:aa19f8349a89c7383b15bfa06907e8460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SHA DIGESTS</div></td></tr>
<tr class="memitem:a4ca38aee965b3402835797962603b074"><td class="memTemplParams" colspan="2">template&lt;int func, int fmask, class T &gt; </td></tr>
<tr class="memitem:a4ca38aee965b3402835797962603b074"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a4ca38aee965b3402835797962603b074">VecSHA256</a> (const T data)</td></tr>
<tr class="memdesc:a4ca38aee965b3402835797962603b074"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_s_h_a256.html" title="SHA-256 message digest.">SHA256</a> Sigma functions.  <a href="ppc__simd_8h.html#a4ca38aee965b3402835797962603b074">More...</a><br /></td></tr>
<tr class="separator:a4ca38aee965b3402835797962603b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1050a43b985396890d2ac68f2c1a54"><td class="memTemplParams" colspan="2">template&lt;int func, int fmask, class T &gt; </td></tr>
<tr class="memitem:a0f1050a43b985396890d2ac68f2c1a54"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ppc__simd_8h.html#a0f1050a43b985396890d2ac68f2c1a54">VecSHA512</a> (const T data)</td></tr>
<tr class="memdesc:a0f1050a43b985396890d2ac68f2c1a54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_s_h_a512.html" title="SHA-512 message digest.">SHA512</a> Sigma functions.  <a href="ppc__simd_8h.html#a0f1050a43b985396890d2ac68f2c1a54">More...</a><br /></td></tr>
<tr class="separator:a0f1050a43b985396890d2ac68f2c1a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support functions for PowerPC and vector operations. </p>
<p>This header provides an agnostic interface into Clang, GCC and IBM XL C/C++ compilers modulo their different built-in functions for accessing vector instructions.</p>
<p>The abstractions are necessary to support back to GCC 4.8 and XLC 11 and 12. GCC 4.8 and 4.9 are still popular, and they are the default compiler for GCC112, GCC119 and others on the compile farm. Older IBM XL C/C++ compilers also have the need due to lack of <code>vec_xl</code> and <code>vec_xst</code> support on some platforms. Modern compilers provide best support and don't need many of the hacks below.</p>
<p>The library is tested with the following PowerPC machines and compilers. GCC110, GCC111, GCC112, GCC119 and GCC135 are provided by the <a href="https://cfarm.tetaneutral.net/">GCC Compile Farm</a></p><ul>
<li>PowerMac G5, OSX 10.5, POWER4, Apple GCC 4.0</li>
<li>PowerMac G5, OSX 10.5, POWER4, Macports GCC 5.0</li>
<li>GCC110, Linux, POWER7, GCC 4.8.5</li>
<li>GCC110, Linux, POWER7, XLC 12.01</li>
<li>GCC111, AIX, POWER7, GCC 4.8.1</li>
<li>GCC111, AIX, POWER7, XLC 12.01</li>
<li>GCC112, Linux, POWER8, GCC 4.8.5</li>
<li>GCC112, Linux, POWER8, XLC 13.01</li>
<li>GCC112, Linux, POWER8, Clang 7.0</li>
<li>GCC119, AIX, POWER8, GCC 7.2.0</li>
<li>GCC119, AIX, POWER8, XLC 13.01</li>
<li><p class="startli">GCC135, Linux, POWER9, GCC 7.0</p>
<p class="startli">12 machines are used for testing because the three compilers form five or six profiles. The profiles are listed below.</p>
</li>
<li>GCC (Linux GCC, Macports GCC, etc. Consistent across machines)</li>
<li>XLC 13.0 and earlier (all IBM components)</li>
<li>XLC 13.1 and later on Linux (LLVM front-end, no compatibility macros)</li>
<li>XLC 13.1 and later on Linux (LLVM front-end, -qxlcompatmacros option)</li>
<li>early LLVM Clang (traditional Clang compiler)</li>
<li><p class="startli">late LLVM Clang (traditional Clang compiler)</p>
<p class="startli">The LLVM front-end makes it tricky to write portable code because LLVM pretends to be other compilers but cannot consume other compiler's builtins. When using XLC with -qxlcompatmacros the compiler pretends to be GCC, Clang and XLC all at once but it can only consume it's variety of builtins.</p>
<p class="startli">At Crypto++ 8.0 the various <code>Vector{FuncName}</code> were renamed to <code>Vec{FuncName}</code>. For example, <code>VectorAnd</code> was changed to <code>VecAnd</code>. The name change helped consolidate two slightly different implementations.</p>
<p class="startli">At Crypto++ 8.3 the library added select 64-bit functions for 32-bit Altivec. For example, <code>VecAdd64</code> and <code>VecSub64</code> take 32-bit vectors and adds or subtracts them as if there were vectors with two 64-bit elements. The functions dramtically improve performance for some algorithms on some platforms, like <a class="el" href="class_s_i_m_o_n128.html" title="SIMON 128-bit block cipher.">SIMON128</a> and <a class="el" href="class_s_p_e_c_k128.html" title="SPECK 128-bit block cipher.">SPECK128</a> on Power6 and earlier. For example, <a class="el" href="class_s_p_e_c_k128.html" title="SPECK 128-bit block cipher.">SPECK128</a> improved from 70 cpb to 10 cpb on an old PowerMac. Use the functions like shown below. </p><pre>
   #if defined(_ARCH_PWR8)
   #  define speck128_t uint64x2_p
   #else
   #  define speck128_t uint32x4_p
   #endif

   speck128_t rk, x1, x2, y1, y2;
   rk = (speck128_t)VecLoadAligned(ptr);
   x1 = VecRotateRight64&lt;8&gt;(x1);
   x1 = VecAdd64(x1, y1);
   ...</pre> <dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0, LLVM Clang compiler support since Crypto++ 8.0 </dd></dl>
</li>
</ul>

<p class="definition">Definition in file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a97548e11947e4bd00686ec197a666072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97548e11947e4bd00686ec197a666072">&#9670;&nbsp;</a></span>CONST_V8_CAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONST_V8_CAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned char*)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast array to vector pointer. </p>
<p>CONST_V8_CAST casts a const array to a vector pointer for a byte array. The Power ABI says source arrays are non-const, so this define removes the const. XLC++ will fail the compile if the source array is const. </p>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00145">145</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ad2eaf9d07a972de6b857542f7061014f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eaf9d07a972de6b857542f7061014f">&#9670;&nbsp;</a></span>CONST_V32_CAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONST_V32_CAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned int*)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast array to vector pointer. </p>
<p>CONST_V32_CAST casts a const array to a vector pointer for a word array. The Power ABI says source arrays are non-const, so this define removes the const. XLC++ will fail the compile if the source array is const. </p>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00151">151</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="afc1e224c1b09c09c3e303d702aadd5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1e224c1b09c09c3e303d702aadd5b9">&#9670;&nbsp;</a></span>CONST_V64_CAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONST_V64_CAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned long long*)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast array to vector pointer. </p>
<p>CONST_V64_CAST casts a const array to a vector pointer for a double word array. The Power ABI says source arrays are non-const, so this define removes the const. XLC++ will fail the compile if the source array is const. </p>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00157">157</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ace92283b301341abfa7d9f3654adb9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace92283b301341abfa7d9f3654adb9f1">&#9670;&nbsp;</a></span>NCONST_V8_CAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NCONST_V8_CAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned char*)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast array to vector pointer. </p>
<p>NCONST_V8_CAST casts an array to a vector pointer for a byte array. The Power ABI says source arrays are non-const, so this define removes the const. XLC++ will fail the compile if the source array is const. </p>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00163">163</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a7ae67c0978cdac0cdc08cc99c20612b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae67c0978cdac0cdc08cc99c20612b0">&#9670;&nbsp;</a></span>NCONST_V32_CAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NCONST_V32_CAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned int*)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast array to vector pointer. </p>
<p>NCONST_V32_CAST casts an array to a vector pointer for a word array. The Power ABI says source arrays are non-const, so this define removes the const. XLC++ will fail the compile if the source array is const. </p>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00169">169</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="abe5702e2d0b6356860abea390e39b502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5702e2d0b6356860abea390e39b502">&#9670;&nbsp;</a></span>NCONST_V64_CAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NCONST_V64_CAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned long long*)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast array to vector pointer. </p>
<p>NCONST_V64_CAST casts an array to a vector pointer for a double word array. The Power ABI says source arrays are non-const, so this define removes the const. XLC++ will fail the compile if the source array is const. </p>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00175">175</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6be79e9f5820422953c7a2a3df6c8879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be79e9f5820422953c7a2a3df6c8879">&#9670;&nbsp;</a></span>uint8x16_p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __vector unsigned char <a class="el" href="ppc__simd_8h.html#a6be79e9f5820422953c7a2a3df6c8879">uint8x16_p</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of 8-bit elements. </p>
<dl class="section user"><dt>Wraps</dt><dd>__vector unsigned char </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00192">192</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ae74b7f16ff4b3e18dcbf2aeddccbf584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74b7f16ff4b3e18dcbf2aeddccbf584">&#9670;&nbsp;</a></span>uint16x8_p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __vector unsigned short <a class="el" href="ppc__simd_8h.html#ae74b7f16ff4b3e18dcbf2aeddccbf584">uint16x8_p</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of 16-bit elements. </p>
<dl class="section user"><dt>Wraps</dt><dd>__vector unsigned short </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00197">197</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a3e56fac8b9dc01ebf52262069a3c94b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e56fac8b9dc01ebf52262069a3c94b5">&#9670;&nbsp;</a></span>uint32x4_p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __vector unsigned int <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of 32-bit elements. </p>
<dl class="section user"><dt>Wraps</dt><dd>__vector unsigned int </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00202">202</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a7876e27953f12ff20b5a51fc071b806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7876e27953f12ff20b5a51fc071b806f">&#9670;&nbsp;</a></span>uint64x2_p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __vector unsigned long long <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of 64-bit elements. </p>
<p>uint64x2_p is available on POWER7 with VSX and above. Most supporting functions, like 64-bit <code>vec_add</code> (<code>vaddudm</code>) and <code>vec_sub</code> (<code>vsubudm</code>), did not arrive until POWER8. </p><dl class="section user"><dt>Wraps</dt><dd>__vector unsigned long long </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00212">212</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a027d7006532e07217464e88608ec8c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027d7006532e07217464e88608ec8c72">&#9670;&nbsp;</a></span>VecZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The 0 vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a 32-bit vector of 0's </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00218">218</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ad7128919d5191e68880f310892f7329c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7128919d5191e68880f310892f7329c">&#9670;&nbsp;</a></span>VecOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The 1 vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a 32-bit vector of 1's </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00227">227</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ad0d8d49aa8462c878fd011c2dfbac869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d8d49aa8462c878fd011c2dfbac869">&#9670;&nbsp;</a></span>VecReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecReverse </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse bytes in a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ad0d8d49aa8462c878fd011c2dfbac869" title="Reverse bytes in a vector.">VecReverse()</a> reverses the bytes in a vector </p><dl class="section user"><dt>Wraps</dt><dd>vec_perm </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00242">242</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a5bfcde3b193a8fcdb1f4529140370ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfcde3b193a8fcdb1f4529140370ec5">&#9670;&nbsp;</a></span>VecReverseLE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecReverseLE </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse bytes in a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a5bfcde3b193a8fcdb1f4529140370ec5" title="Reverse bytes in a vector.">VecReverseLE()</a> reverses the bytes in a vector on little-endian systems. </p><dl class="section user"><dt>Wraps</dt><dd>vec_perm </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00263">263</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ad89626d9392b07d0a1fd72e91acc4898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89626d9392b07d0a1fd72e91acc4898">&#9670;&nbsp;</a></span>VecReverseBE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecReverseBE </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse bytes in a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ad89626d9392b07d0a1fd72e91acc4898" title="Reverse bytes in a vector.">VecReverseBE()</a> reverses the bytes in a vector on big-endian systems. </p><dl class="section user"><dt>Wraps</dt><dd>vec_perm </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00283">283</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a51cb0d533261142b52e065978d68233a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cb0d533261142b52e065978d68233a">&#9670;&nbsp;</a></span>VecLoad_ALTIVEC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoad_ALTIVEC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p>Loads a vector in native endian format from a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> uses <code>vec_ld</code> if the effective address of <code>src</code> is aligned. If unaligned it uses <code>vec_lvsl</code>, <code>vec_ld</code>, <code>vec_perm</code> and <code>src</code>. The fixups using <code>vec_lvsl</code> and <code>vec_perm</code> are relatively expensive so you should provide aligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_ld, vec_lvsl, vec_perm </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00308">308</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a05902e3951fab32e1d9e2714801ac6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05902e3951fab32e1d9e2714801ac6cc">&#9670;&nbsp;</a></span>VecLoad_ALTIVEC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoad_ALTIVEC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the src byte array</td></tr>
  </table>
  </dd>
</dl>
<p>Loads a vector in native endian format from a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> uses <code>vec_ld</code> if the effective address of <code>src</code> is aligned. If unaligned it uses <code>vec_lvsl</code>, <code>vec_ld</code>, <code>vec_perm</code> and <code>src</code>.</p>
<p>The fixups using <code>vec_lvsl</code> and <code>vec_perm</code> are relatively expensive so you should provide aligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_ld, vec_lvsl, vec_perm </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00339">339</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ae8e3b0006e46e86eb616d3ed9fdb694a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e3b0006e46e86eb616d3ed9fdb694a">&#9670;&nbsp;</a></span>VecLoad() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> loads a vector from a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> uses POWER9's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER9 is not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on POWER9 and above, Altivec load on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00369">369</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ada4648a88d47f71b3d0978c1df6af366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4648a88d47f71b3d0978c1df6af366">&#9670;&nbsp;</a></span>VecLoad() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the src byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> loads a vector from a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> uses POWER9's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER9 is not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on POWER9 and above, Altivec load on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00399">399</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a37fe0a021524e332cd5b7ef807f63a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fe0a021524e332cd5b7ef807f63a7f">&#9670;&nbsp;</a></span>VecLoad() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>src</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> loads a vector from a word array.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER7 is not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, Altivec load on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00428">428</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a7a3489f75b01ec6c3b7309196007e6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3489f75b01ec6c3b7309196007e6c8">&#9670;&nbsp;</a></span>VecLoad() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>src</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the word array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> loads a vector from a word array.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER7 is not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, Altivec load on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00460">460</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a66864bda50cb08e12fd896c5422df353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66864bda50cb08e12fd896c5422df353">&#9670;&nbsp;</a></span>VecLoad() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>src</em>[2]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a double word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the double word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> loads a vector from a double word array.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER7 and VSX are not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> with 64-bit elements is available on POWER7 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, Altivec load on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00494">494</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aa4122401a01366b69daf489b120c67cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4122401a01366b69daf489b120c67cd">&#9670;&nbsp;</a></span>VecLoad() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecLoad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>src</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a double word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the double word array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the double word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> loads a vector from a double word array.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER7 and VSX are not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses.</p>
<p><a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad()</a> with 64-bit elements is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, Altivec load on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00528">528</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a184ecd6bcaf2def8525c7491bcc7f271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184ecd6bcaf2def8525c7491bcc7f271">&#9670;&nbsp;</a></span>VecLoadAligned() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoadAligned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from an aligned byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> loads a vector from an aligned byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> uses POWER9's <code>vec_xl</code> if available. <code>vec_ld</code> is used if POWER9 is not available. The effective address of <code>src</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on POWER9, vec_ld on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00560">560</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a1864f2d026c23b44b674114b4e26a0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1864f2d026c23b44b674114b4e26a0d8">&#9670;&nbsp;</a></span>VecLoadAligned() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoadAligned </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from an aligned byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the src byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> loads a vector from an aligned byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> uses POWER9's <code>vec_xl</code> if available. <code>vec_ld</code> is used if POWER9 is not available. The effective address of <code>src</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on POWER9, vec_ld on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00588">588</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="af4bfa37f662dbfe6676323431bd3b485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bfa37f662dbfe6676323431bd3b485">&#9670;&nbsp;</a></span>VecLoadAligned() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoadAligned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>src</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from an aligned word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> loads a vector from an aligned word array.</p>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. <code>vec_ld</code> is used if POWER7 or VSX are not available. The effective address of <code>src</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, vec_ld on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00615">615</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a8895bf28800a0e445524e6564a77865b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8895bf28800a0e445524e6564a77865b">&#9670;&nbsp;</a></span>VecLoadAligned() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoadAligned </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>src</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from an aligned word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the word array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the src word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> loads a vector from an aligned word array.</p>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. <code>vec_ld</code> is used if POWER7 or VSX are not available. The effective address of <code>src</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, vec_ld on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00645">645</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a0405f7b31158b0bb9be5515812498590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0405f7b31158b0bb9be5515812498590">&#9670;&nbsp;</a></span>VecLoadAligned() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecLoadAligned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>src</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from an aligned double word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the double word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> loads a vector from an aligned double word array.</p>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. <code>vec_ld</code> is used if POWER7 or VSX are not available. The effective address of <code>src</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, vec_ld on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00676">676</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="af510c2c972bd5b9aa03d74bc409d5435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af510c2c972bd5b9aa03d74bc409d5435">&#9670;&nbsp;</a></span>VecLoadAligned() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecLoadAligned </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>src</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from an aligned double word array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the double word array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the src double word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> loads a vector from an aligned double word array.</p>
<p><a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. <code>vec_ld</code> is used if POWER7 or VSX are not available. The effective address of <code>src</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on VSX or POWER8 and above, vec_ld on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00707">707</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a11fef6722e8ea75a23f3beb203e0727f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fef6722e8ea75a23f3beb203e0727f">&#9670;&nbsp;</a></span>VecLoadBE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoadBE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a11fef6722e8ea75a23f3beb203e0727f" title="Loads a vector from a byte array.">VecLoadBE()</a> loads a vector from a byte array. VecLoadBE will reverse all bytes in the array on a little endian system.</p>
<p><a class="el" href="ppc__simd_8h.html#a11fef6722e8ea75a23f3beb203e0727f" title="Loads a vector from a byte array.">VecLoadBE()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER7 or VSX are not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on POWER8, Altivec load on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00742">742</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a3bca1185babd6f401c65ed101d57ed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bca1185babd6f401c65ed101d57ed69">&#9670;&nbsp;</a></span>VecLoadBE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecLoadBE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>src</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a vector from a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the byte array </td></tr>
    <tr><td class="paramname">off</td><td>offset into the src byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a11fef6722e8ea75a23f3beb203e0727f" title="Loads a vector from a byte array.">VecLoadBE()</a> loads a vector from a byte array. VecLoadBE will reverse all bytes in the array on a little endian system.</p>
<p><a class="el" href="ppc__simd_8h.html#a11fef6722e8ea75a23f3beb203e0727f" title="Loads a vector from a byte array.">VecLoadBE()</a> uses POWER7's and VSX's <code>vec_xl</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> is used if POWER7 is not available. <a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xl on POWER8, Altivec load on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a51cb0d533261142b52e065978d68233a" title="Loads a vector from a byte array.">VecLoad_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#ae8e3b0006e46e86eb616d3ed9fdb694a" title="Loads a vector from a byte array.">VecLoad</a>, <a class="el" href="ppc__simd_8h.html#a184ecd6bcaf2def8525c7491bcc7f271" title="Loads a vector from an aligned byte array.">VecLoadAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00776">776</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a13aa322f4c2e69303e28262cdd8675d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13aa322f4c2e69303e28262cdd8675d1">&#9670;&nbsp;</a></span>VecStore_ALTIVEC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore_ALTIVEC </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> stores a vector to a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> uses <code>vec_st</code> if the effective address of <code>dest</code> is aligned, and uses <code>vec_ste</code> otherwise. <code>vec_ste</code> is relatively expensive so you should provide aligned memory addresses.</p>
<p><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used when POWER7 or above and unaligned loads is not available. </p><dl class="section user"><dt>Wraps</dt><dd>vec_st, vec_ste, vec_lvsr, vec_perm </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00817">817</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ac0e0c0c990eb17e5cb65de97fc178834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e0c0c990eb17e5cb65de97fc178834">&#9670;&nbsp;</a></span>VecStore_ALTIVEC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore_ALTIVEC </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest byte array </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> stores a vector to a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> uses <code>vec_st</code> if the effective address of <code>dest</code> is aligned, and uses <code>vec_ste</code> otherwise. <code>vec_ste</code> is relatively expensive so you should provide aligned memory addresses.</p>
<p><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used when POWER7 or above and unaligned loads is not available. </p><dl class="section user"><dt>Wraps</dt><dd>vec_st, vec_ste, vec_lvsr, vec_perm </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00857">857</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="acf359f5ff034095346825ac55e8bc03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf359f5ff034095346825ac55e8bc03c">&#9670;&nbsp;</a></span>VecStore() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> stores a vector to a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> uses POWER9's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER9 is not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on POWER9 and above, Altivec store on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00895">895</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a67780e671eb9433426054af5a4dbfc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67780e671eb9433426054af5a4dbfc21">&#9670;&nbsp;</a></span>VecStore() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest byte array </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> stores a vector to a byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> uses POWER9's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER9 is not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on POWER9 and above, Altivec store on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00928">928</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a2c2144982832b9eb200bab0c3d55e783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2144982832b9eb200bab0c3d55e783">&#9670;&nbsp;</a></span>VecStore() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>dest</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> stores a vector to a word array.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 or VSX are not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, Altivec store on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00960">960</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a8a4af7702cb870596c5474c9657e69a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4af7702cb870596c5474c9657e69a0">&#9670;&nbsp;</a></span>VecStore() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>dest</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest word array </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> stores a vector to a word array.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 or VSX are not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, Altivec store on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l00995">995</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a615a05734fb91fb72c818be5c1258a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a05734fb91fb72c818be5c1258a55">&#9670;&nbsp;</a></span>VecStore() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>dest</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> stores a vector to a word array.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 or VSX are not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> with 64-bit elements is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, Altivec store on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01030">1030</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a0816fafd4937fadede4c0161e261d415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0816fafd4937fadede4c0161e261d415">&#9670;&nbsp;</a></span>VecStore() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStore </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>dest</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest word array </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> stores a vector to a word array.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 or VSX are not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses.</p>
<p><a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore()</a> with 64-bit elements is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, Altivec store on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01067">1067</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a7a71bdae510d63e87bdf1524512f04db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a71bdae510d63e87bdf1524512f04db">&#9670;&nbsp;</a></span>VecStoreAligned() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreAligned </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> stores a vector from an aligned byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> uses POWER9's <code>vec_xl</code> if available. <code>vec_st</code> is used if POWER9 is not available. The effective address of <code>dest</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on POWER9 or above, vec_st on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01100">1100</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a8bf334500b225fd2f4f76e1123251787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf334500b225fd2f4f76e1123251787">&#9670;&nbsp;</a></span>VecStoreAligned() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreAligned </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest byte array </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> stores a vector from an aligned byte array.</p>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> uses POWER9's <code>vec_xl</code> if available. <code>vec_st</code> is used if POWER9 is not available. The effective address of <code>dest</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on POWER9 or above, vec_st on POWER8 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01131">1131</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="afec651f226a41d227ede694c192eb1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec651f226a41d227ede694c192eb1dd">&#9670;&nbsp;</a></span>VecStoreAligned() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreAligned </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>dest</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> stores a vector from an aligned word array.</p>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> uses POWER9's <code>vec_xl</code> if available. POWER7 <code>vec_xst</code> is used if POWER9 is not available. <code>vec_st</code> is used if POWER7 is not available. The effective address of <code>dest</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, vec_st on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01162">1162</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a68ad754906f7edacd0f088ef50a3143d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ad754906f7edacd0f088ef50a3143d">&#9670;&nbsp;</a></span>VecStoreAligned() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreAligned </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>dest</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest word array </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> stores a vector from an aligned word array.</p>
<p><a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned()</a> uses POWER9's <code>vec_xl</code> if available. POWER7 <code>vec_xst</code> is used if POWER9 is not available. <code>vec_st</code> is used if POWER7 is not available. The effective address of <code>dest</code> must be 16-byte aligned for Altivec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, vec_st on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#acf359f5ff034095346825ac55e8bc03c" title="Stores a vector to a byte array.">VecStore</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01196">1196</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a44ce12e2a56d8858a05f19f0481238a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ce12e2a56d8858a05f19f0481238a2">&#9670;&nbsp;</a></span>VecStoreBE() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreBE </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> stores a vector to a byte array. VecStoreBE will reverse all bytes in the array on a little endian system.</p>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 is not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, vec_st on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01231">1231</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="adacff6b8db3a9a2be2bf28f068ba9a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacff6b8db3a9a2be2bf28f068ba9a0f">&#9670;&nbsp;</a></span>VecStoreBE() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreBE </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>dest</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a byte array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest byte array </td></tr>
    <tr><td class="paramname">dest</td><td>the byte array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> stores a vector to a byte array. VecStoreBE will reverse all bytes in the array on a little endian system.</p>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 is not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, vec_st on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01267">1267</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a268f8efc395bb27ccc142095baa4f776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268f8efc395bb27ccc142095baa4f776">&#9670;&nbsp;</a></span>VecStoreBE() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreBE </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>dest</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> stores a vector to a word array. VecStoreBE will reverse all bytes in the array on a little endian system.</p>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 is not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, vec_st on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01302">1302</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a5994615461a77e14b513ade7e85e5cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5994615461a77e14b513ade7e85e5cbc">&#9670;&nbsp;</a></span>VecStoreBE() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VecStoreBE </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>dest</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a vector to a word array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the vector </td></tr>
    <tr><td class="paramname">off</td><td>offset into the dest word array </td></tr>
    <tr><td class="paramname">dest</td><td>the word array</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> stores a vector to a word array. VecStoreBE will reverse all words in the array on a little endian system.</p>
<p><a class="el" href="ppc__simd_8h.html#a44ce12e2a56d8858a05f19f0481238a2" title="Stores a vector to a byte array.">VecStoreBE()</a> uses POWER7's and VSX's <code>vec_xst</code> if available. The instruction does not require aligned effective memory addresses. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> is used if POWER7 is not available. <a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC()</a> can be relatively expensive if extra instructions are required to fix up unaligned memory addresses. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xst on VSX or POWER8 and above, vec_st on POWER7 and below </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a13aa322f4c2e69303e28262cdd8675d1" title="Stores a vector to a byte array.">VecStore_ALTIVEC</a>, <a class="el" href="ppc__simd_8h.html#a7a71bdae510d63e87bdf1524512f04db" title="Stores a vector to a byte array.">VecStoreAligned</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01338">1338</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="abf26bb56e3d6282e5c5b66a4b84bf560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf26bb56e3d6282e5c5b66a4b84bf560">&#9670;&nbsp;</a></span>VecAnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecAnd </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AND two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#abf26bb56e3d6282e5c5b66a4b84bf560" title="AND two vectors.">VecAnd()</a> performs <code>vec1 &amp; vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1. </p><dl class="section user"><dt>Wraps</dt><dd>vec_and </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#afbcc6eab6ce4db027ba00fc72ebe87c3" title="AND two vectors as if uint64x2_p.">VecAnd64</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01376">1376</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a07efaef961b78aa09784e70ac4d17390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07efaef961b78aa09784e70ac4d17390">&#9670;&nbsp;</a></span>VecOr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecOr </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OR two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a07efaef961b78aa09784e70ac4d17390" title="OR two vectors.">VecOr()</a> performs <code>vec1 | vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1. </p><dl class="section user"><dt>Wraps</dt><dd>vec_or </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a15f2e61d731d679a5d9d526a007c17fd" title="OR two vectors as if uint64x2_p.">VecOr64</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01395">1395</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a7362c0e6f4db03045b4494f95cb40703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7362c0e6f4db03045b4494f95cb40703">&#9670;&nbsp;</a></span>VecXor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecXor </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XOR two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a7362c0e6f4db03045b4494f95cb40703" title="XOR two vectors.">VecXor()</a> performs <code>vec1 ^ vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xor </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a9ac4e5e7af3ea6f274f4b46f0f48a5d0" title="XOR two vectors as if uint64x2_p.">VecXor64</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01414">1414</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aae6c1e5e6a88c823a32007a0c3c0a9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6c1e5e6a88c823a32007a0c3c0a9e1">&#9670;&nbsp;</a></span>VecAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecAdd </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aae6c1e5e6a88c823a32007a0c3c0a9e1" title="Add two vectors.">VecAdd()</a> performs <code>vec1 + vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1. </p><dl class="section user"><dt>Wraps</dt><dd>vec_add </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9" title="Add two vectors as if uint64x2_p.">VecAdd64</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01438">1438</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a7896c9252403ed7ba3e075a1014269c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7896c9252403ed7ba3e075a1014269c9">&#9670;&nbsp;</a></span>VecSub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecSub </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a7896c9252403ed7ba3e075a1014269c9" title="Subtract two vectors.">VecSub()</a> performs <code>vec1 - vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sub </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45" title="Subtract two vectors as if uint64x2_p.">VecSub64</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01456">1456</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a56df7ee710906a4f93354363c9ca8de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56df7ee710906a4f93354363c9ca8de5">&#9670;&nbsp;</a></span>VecPermute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecPermute </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
    <tr><td class="paramname">mask</td><td>vector mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a56df7ee710906a4f93354363c9ca8de5" title="Permutes a vector.">VecPermute()</a> creates a new vector from vec according to mask. mask is an uint8x16_p vector. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_perm </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01478">1478</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a32ad87962002239b443f56b894e695ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ad87962002239b443f56b894e695ed">&#9670;&nbsp;</a></span>VecPermute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecPermute </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
    <tr><td class="paramname">mask</td><td>vector mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a56df7ee710906a4f93354363c9ca8de5" title="Permutes a vector.">VecPermute()</a> creates a new vector from vec1 and vec2 according to mask. mask is an uint8x16_p vector. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_perm </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01496">1496</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a469cfebbcd8c8f214f4fc747f784f94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469cfebbcd8c8f214f4fc747f784f94b">&#9670;&nbsp;</a></span>VecShiftLeftOctet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecShiftLeftOctet </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a vector left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift byte count </td></tr>
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a469cfebbcd8c8f214f4fc747f784f94b" title="Shift a vector left.">VecShiftLeftOctet()</a> returns a new vector after shifting the concatenation of the zero vector and the source vector by the specified number of bytes. The return vector is the same type as vec.</p>
<p>On big endian machines <a class="el" href="ppc__simd_8h.html#a469cfebbcd8c8f214f4fc747f784f94b" title="Shift a vector left.">VecShiftLeftOctet()</a> is <code>vec_sld(a, z, c)</code>. On little endian machines <a class="el" href="ppc__simd_8h.html#a469cfebbcd8c8f214f4fc747f784f94b" title="Shift a vector left.">VecShiftLeftOctet()</a> is translated to <code>vec_sld(z, a, 16-c)</code>. You should always call the function as if on a big endian machine as shown below. </p><pre>
  uint8x16_p x = VecLoad(ptr);
  uint8x16_p y = VecShiftLeftOctet&lt;12&gt;(x);
</pre> <dl class="section user"><dt>Wraps</dt><dd>vec_sld </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/q/46341923/608639">Is vec_sld endian sensitive?</a> on Stack Overflow </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01528">1528</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a3661ff89afa1f0e9cc0855e10e407798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3661ff89afa1f0e9cc0855e10e407798">&#9670;&nbsp;</a></span>VecShiftRightOctet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecShiftRightOctet </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a vector right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift byte count </td></tr>
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a3661ff89afa1f0e9cc0855e10e407798" title="Shift a vector right.">VecShiftRightOctet()</a> returns a new vector after shifting the concatenation of the zero vector and the source vector by the specified number of bytes. The return vector is the same type as vec.</p>
<p>On big endian machines <a class="el" href="ppc__simd_8h.html#a3661ff89afa1f0e9cc0855e10e407798" title="Shift a vector right.">VecShiftRightOctet()</a> is <code>vec_sld(a, z, c)</code>. On little endian machines <a class="el" href="ppc__simd_8h.html#a3661ff89afa1f0e9cc0855e10e407798" title="Shift a vector right.">VecShiftRightOctet()</a> is translated to <code>vec_sld(z, a, 16-c)</code>. You should always call the function as if on a big endian machine as shown below. </p><pre>
  uint8x16_p x = VecLoad(ptr);
  uint8x16_p y = VecShiftRightOctet&lt;12&gt;(y);
</pre> <dl class="section user"><dt>Wraps</dt><dd>vec_sld </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/q/46341923/608639">Is vec_sld endian sensitive?</a> on Stack Overflow </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01575">1575</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ab048d9b974c5ee4ad1ccaafb938981eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab048d9b974c5ee4ad1ccaafb938981eb">&#9670;&nbsp;</a></span>VecRotateLeftOctet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecRotateLeftOctet </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift byte count </td></tr>
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ab048d9b974c5ee4ad1ccaafb938981eb" title="Rotate a vector left.">VecRotateLeftOctet()</a> returns a new vector after rotating the concatenation of the source vector with itself by the specified number of bytes. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sld </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/q/46341923/608639">Is vec_sld endian sensitive?</a> on Stack Overflow </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01614">1614</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a1b2ddf02b2b8dabdbc0e2aba8df5a643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2ddf02b2b8dabdbc0e2aba8df5a643">&#9670;&nbsp;</a></span>VecRotateRightOctet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecRotateRightOctet </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift byte count </td></tr>
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a1b2ddf02b2b8dabdbc0e2aba8df5a643" title="Rotate a vector right.">VecRotateRightOctet()</a> returns a new vector after rotating the concatenation of the source vector with itself by the specified number of bytes. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sld </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/q/46341923/608639">Is vec_sld endian sensitive?</a> on Stack Overflow </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01639">1639</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aaf8592222d59b4fad19ce9d3794a7391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8592222d59b4fad19ce9d3794a7391">&#9670;&nbsp;</a></span>VecRotateLeft() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecRotateLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aaf8592222d59b4fad19ce9d3794a7391" title="Rotate a vector left.">VecRotateLeft()</a> rotates each element in a vector by bit count. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 7.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01660">1660</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a05ce5bef0bc70e2e0eaeaa7c48bfabdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ce5bef0bc70e2e0eaeaa7c48bfabdd">&#9670;&nbsp;</a></span>VecRotateRight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecRotateRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a05ce5bef0bc70e2e0eaeaa7c48bfabdd" title="Rotate a vector right.">VecRotateRight()</a> rotates each element in a vector by bit count. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 7.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01676">1676</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ad2250720fa9fad419822563334701572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2250720fa9fad419822563334701572">&#9670;&nbsp;</a></span>VecShiftLeft() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecShiftLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a vector left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ad2250720fa9fad419822563334701572" title="Shift a vector left.">VecShiftLeft()</a> rotates each element in a vector by bit count. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01692">1692</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ac057d935ba15243deb16d14f61b27eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac057d935ba15243deb16d14f61b27eb2">&#9670;&nbsp;</a></span>VecShiftRight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecShiftRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a vector right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ac057d935ba15243deb16d14f61b27eb2" title="Shift a vector right.">VecShiftRight()</a> rotates each element in a vector by bit count. The return vector is the same type as vec. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01708">1708</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ac2e8bc087867053f20bb8d963e869557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e8bc087867053f20bb8d963e869557">&#9670;&nbsp;</a></span>VecRotateLeft() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecRotateLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aaf8592222d59b4fad19ce9d3794a7391" title="Rotate a vector left.">VecRotateLeft()</a> rotates each element in a vector by bit count. The return vector is the same type as vec.</p>
<p><a class="el" href="ppc__simd_8h.html#aaf8592222d59b4fad19ce9d3794a7391" title="Rotate a vector left.">VecRotateLeft()</a> with 64-bit elements is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01729">1729</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a964daf4c5415d4acc4c7c43eb6d1f323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964daf4c5415d4acc4c7c43eb6d1f323">&#9670;&nbsp;</a></span>VecShiftLeft() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecShiftLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a vector left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ad2250720fa9fad419822563334701572" title="Shift a vector left.">VecShiftLeft()</a> rotates each element in a vector by bit count. The return vector is the same type as vec.</p>
<p><a class="el" href="ppc__simd_8h.html#ad2250720fa9fad419822563334701572" title="Shift a vector left.">VecShiftLeft()</a> with 64-bit elements is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01747">1747</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a027e58c6c5caee099812379d6c26d4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027e58c6c5caee099812379d6c26d4b0">&#9670;&nbsp;</a></span>VecRotateRight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecRotateRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a05ce5bef0bc70e2e0eaeaa7c48bfabdd" title="Rotate a vector right.">VecRotateRight()</a> rotates each element in a vector by bit count. The return vector is the same type as vec.</p>
<p><a class="el" href="ppc__simd_8h.html#a05ce5bef0bc70e2e0eaeaa7c48bfabdd" title="Rotate a vector right.">VecRotateRight()</a> with 64-bit elements is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01765">1765</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a5c659aa307c8eccbe1073e36edb2463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c659aa307c8eccbe1073e36edb2463a">&#9670;&nbsp;</a></span>VecShiftRight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecShiftRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a vector right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>shift bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ac057d935ba15243deb16d14f61b27eb2" title="Shift a vector right.">VecShiftRight()</a> rotates each element in a vector by bit count. The return vector is the same type as vec.</p>
<p><a class="el" href="ppc__simd_8h.html#ac057d935ba15243deb16d14f61b27eb2" title="Shift a vector right.">VecShiftRight()</a> with 64-bit elements is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sr </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01783">1783</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a8c9b7e7aec57f821e658f871b2553ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b7e7aec57f821e658f871b2553ba3">&#9670;&nbsp;</a></span>VecMergeLow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecMergeLow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_mergel </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01805">1805</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a5ce8f92de942669891c4189f1213e84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce8f92de942669891c4189f1213e84b">&#9670;&nbsp;</a></span>VecMergeHigh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecMergeHigh </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_mergeh </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01819">1819</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ad4081a2ff8dac47ec38056d38fcec8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4081a2ff8dac47ec38056d38fcec8a7">&#9670;&nbsp;</a></span>VecSplatWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecSplatWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#a866a177fb33ece8b6d66154dc820e99d">word32</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast 32-bit word to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the 32-bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_splats </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01830">1830</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a677f48a5fe5ea5e6e646d93ed22107a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677f48a5fe5ea5e6e646d93ed22107a4">&#9670;&nbsp;</a></span>VecSplatElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecSplatElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast 32-bit element to a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>element number </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the 32-bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_splat </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01855">1855</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aca290c21b235c0b7debbc4362821be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca290c21b235c0b7debbc4362821be29">&#9670;&nbsp;</a></span>VecSplatWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecSplatWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast 64-bit double word to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the 64-bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_splats </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01867">1867</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a6ce79cce8ad3c2e58150f656a231cb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce79cce8ad3c2e58150f656a231cb2f">&#9670;&nbsp;</a></span>VecSplatElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecSplatElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast 64-bit element to a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>element number </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the 64-bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_splat </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01881">1881</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="adbba4043401fd967d05ad5a6e55cef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbba4043401fd967d05ad5a6e55cef2d">&#9670;&nbsp;</a></span>VecGetLow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecGetLow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a dword from a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector created from low dword</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#adbba4043401fd967d05ad5a6e55cef2d" title="Extract a dword from a vector.">VecGetLow()</a> extracts the low dword from a vector. The low dword is composed of the least significant bits and occupies bytes 8 through 15 when viewed as a big endian array. The return vector is the same type as the original vector and padded with 0's in the most significant bit positions. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sld </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 7.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01913">1913</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ac2436f7f3ccc994751d7920407db08b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2436f7f3ccc994751d7920407db08b9">&#9670;&nbsp;</a></span>VecGetHigh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecGetHigh </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a dword from a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector created from high dword</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ac2436f7f3ccc994751d7920407db08b9" title="Extract a dword from a vector.">VecGetHigh()</a> extracts the high dword from a vector. The high dword is composed of the most significant bits and occupies bytes 0 through 7 when viewed as a big endian array. The return vector is the same type as the original vector and padded with 0's in the most significant bit positions. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sld </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 7.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01935">1935</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="adf36aabc9cb455ad6624116ccb53d0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf36aabc9cb455ad6624116ccb53d0d6">&#9670;&nbsp;</a></span>VecSwapWords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecSwapWords </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange high and low double words. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_sld </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 7.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01953">1953</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a864d97431e3db3ec27b6ad21efc55462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864d97431e3db3ec27b6ad21efc55462">&#9670;&nbsp;</a></span>VecEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VecEqual </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if vec1 equals vec2, false otherwise</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a864d97431e3db3ec27b6ad21efc55462" title="Compare two vectors.">VecEqual()</a> performs a bitwise compare. The vector element types do not matter. </p><dl class="section user"><dt>Wraps</dt><dd>vec_all_eq </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01975">1975</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a6e74d1938c7332842f9063991e79f943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e74d1938c7332842f9063991e79f943">&#9670;&nbsp;</a></span>VecNotEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VecNotEqual </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if vec1 does not equal vec2, false otherwise</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a6e74d1938c7332842f9063991e79f943" title="Compare two vectors.">VecNotEqual()</a> performs a bitwise compare. The vector element types do not matter. </p><dl class="section user"><dt>Wraps</dt><dd>vec_all_eq </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l01992">1992</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="adcd5971860bdc65c231e829273a0d5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd5971860bdc65c231e829273a0d5a9">&#9670;&nbsp;</a></span>VecAdd64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecAdd64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two vectors as if uint64x2_p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9" title="Add two vectors as if uint64x2_p.">VecAdd64()</a> performs <code>vec1 + vec2</code>. <a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9" title="Add two vectors as if uint64x2_p.">VecAdd64()</a> performs as if adding two uint64x2_p vectors. On POWER7 and below <a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9" title="Add two vectors as if uint64x2_p.">VecAdd64()</a> manages the carries from the elements. </p><dl class="section user"><dt>Wraps</dt><dd>vec_add for POWER8, vec_addc, vec_perm, vec_add for Altivec </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02014">2014</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a4bcba635b7b2f17245df087155a84fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcba635b7b2f17245df087155a84fc6">&#9670;&nbsp;</a></span>VecAdd64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecAdd64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two vectors as if uint64x2_p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9" title="Add two vectors as if uint64x2_p.">VecAdd64()</a> performs <code>vec1 + vec2</code>. <a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9" title="Add two vectors as if uint64x2_p.">VecAdd64()</a> performs as if adding two uint64x2_p vectors. On POWER7 and below <a class="el" href="ppc__simd_8h.html#adcd5971860bdc65c231e829273a0d5a9" title="Add two vectors as if uint64x2_p.">VecAdd64()</a> manages the carries from the elements. </p><dl class="section user"><dt>Wraps</dt><dd>vec_add for POWER8 </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02050">2050</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a4d7afbcd6b0048e844e428183b93de45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7afbcd6b0048e844e428183b93de45">&#9670;&nbsp;</a></span>VecSub64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecSub64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors as if uint64x2_p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45" title="Subtract two vectors as if uint64x2_p.">VecSub64()</a> performs <code>vec1 - vec2</code>. <a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45" title="Subtract two vectors as if uint64x2_p.">VecSub64()</a> performs as if subtracting two uint64x2_p vectors. On POWER7 and below <a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45" title="Subtract two vectors as if uint64x2_p.">VecSub64()</a> manages the borrows from the elements. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sub for POWER8, vec_subc, vec_andc, vec_perm, vec_sub for Altivec </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02077">2077</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ade597df1125ccc71578d88bcf6e2e7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade597df1125ccc71578d88bcf6e2e7e6">&#9670;&nbsp;</a></span>VecSub64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecSub64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors as if uint64x2_p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45" title="Subtract two vectors as if uint64x2_p.">VecSub64()</a> performs <code>vec1 - vec2</code>. <a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45" title="Subtract two vectors as if uint64x2_p.">VecSub64()</a> performs as if subtracting two uint64x2_p vectors. On POWER7 and below <a class="el" href="ppc__simd_8h.html#a4d7afbcd6b0048e844e428183b93de45" title="Subtract two vectors as if uint64x2_p.">VecSub64()</a> manages the borrows from the elements. </p><dl class="section user"><dt>Wraps</dt><dd>vec_sub for POWER8 </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02114">2114</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aeba7edd170438cdede9dcf621c923fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba7edd170438cdede9dcf621c923fd0">&#9670;&nbsp;</a></span>VecRotateLeft64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecRotateLeft64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector left as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aaf8592222d59b4fad19ce9d3794a7391" title="Rotate a vector left.">VecRotateLeft()</a> rotates each element in a vector by bit count. vec is rotated as if uint64x2_p. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02142">2142</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="af26b992d6223631cf3caddfa83337966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26b992d6223631cf3caddfa83337966">&#9670;&nbsp;</a></span>VecRotateLeft64&lt; 8 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> <a class="el" href="ppc__simd_8h.html#a6cf638bab6918779a91b0e642abe6760">VecRotateLeft64</a>&lt; 8 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector left as if uint64x2_p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aaf8592222d59b4fad19ce9d3794a7391" title="Rotate a vector left.">VecRotateLeft&lt;8&gt;()</a> rotates each element in a vector by 8-bits. vec is rotated as if uint64x2_p. This specialization is used by algorithms like Speck128. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02191">2191</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a6cf638bab6918779a91b0e642abe6760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf638bab6918779a91b0e642abe6760">&#9670;&nbsp;</a></span>VecRotateLeft64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecRotateLeft64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector left as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aeba7edd170438cdede9dcf621c923fd0" title="Rotate a vector left as if uint64x2_p.">VecRotateLeft64()</a> rotates each element in a vector by bit count. vec is rotated as if uint64x2_p. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02213">2213</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aad8452d7e1ae60f71a47d3d9108e5ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8452d7e1ae60f71a47d3d9108e5ef3">&#9670;&nbsp;</a></span>VecRotateRight64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecRotateRight64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector right as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aad8452d7e1ae60f71a47d3d9108e5ef3" title="Rotate a vector right as if uint64x2_p.">VecRotateRight64()</a> rotates each element in a vector by bit count. vec is rotated as if uint64x2_p. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02240">2240</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ac318238ea84b4c264c76843fff85b1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac318238ea84b4c264c76843fff85b1a0">&#9670;&nbsp;</a></span>VecRotateRight64&lt; 8 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> <a class="el" href="ppc__simd_8h.html#a6ba94b554b6ee4d46a401e6f12557aed">VecRotateRight64</a>&lt; 8 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector right as if uint64x2_p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#ac318238ea84b4c264c76843fff85b1a0" title="Rotate a vector right as if uint64x2_p.">VecRotateRight64&lt;8&gt;()</a> rotates each element in a vector by 8-bits. vec is rotated as if uint64x2_p. This specialization is used by algorithms like Speck128.</p>
<p>vec is rotated as if uint64x2_p. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02290">2290</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a6ba94b554b6ee4d46a401e6f12557aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba94b554b6ee4d46a401e6f12557aed">&#9670;&nbsp;</a></span>VecRotateRight64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecRotateRight64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate a vector right as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>rotate bit count </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aad8452d7e1ae60f71a47d3d9108e5ef3" title="Rotate a vector right as if uint64x2_p.">VecRotateRight64()</a> rotates each element in a vector by bit count. vec is rotated as if uint64x2_p. </p><dl class="section user"><dt>Wraps</dt><dd>vec_rl </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02312">2312</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="afbcc6eab6ce4db027ba00fc72ebe87c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcc6eab6ce4db027ba00fc72ebe87c3">&#9670;&nbsp;</a></span>VecAnd64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecAnd64 </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AND two vectors as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#afbcc6eab6ce4db027ba00fc72ebe87c3" title="AND two vectors as if uint64x2_p.">VecAnd64()</a> performs <code>vec1 &amp; vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1.</p>
<p><a class="el" href="ppc__simd_8h.html#afbcc6eab6ce4db027ba00fc72ebe87c3" title="AND two vectors as if uint64x2_p.">VecAnd64()</a> is a convenience function that simply performs a <a class="el" href="ppc__simd_8h.html#abf26bb56e3d6282e5c5b66a4b84bf560" title="AND two vectors.">VecAnd()</a>. </p><dl class="section user"><dt>Wraps</dt><dd>vec_and </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02343">2343</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a15f2e61d731d679a5d9d526a007c17fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f2e61d731d679a5d9d526a007c17fd">&#9670;&nbsp;</a></span>VecOr64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecOr64 </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OR two vectors as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a15f2e61d731d679a5d9d526a007c17fd" title="OR two vectors as if uint64x2_p.">VecOr64()</a> performs <code>vec1 | vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1.</p>
<p><a class="el" href="ppc__simd_8h.html#a15f2e61d731d679a5d9d526a007c17fd" title="OR two vectors as if uint64x2_p.">VecOr64()</a> is a convenience function that simply performs a <a class="el" href="ppc__simd_8h.html#a07efaef961b78aa09784e70ac4d17390" title="OR two vectors.">VecOr()</a>. </p><dl class="section user"><dt>Wraps</dt><dd>vec_or </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02362">2362</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a9ac4e5e7af3ea6f274f4b46f0f48a5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac4e5e7af3ea6f274f4b46f0f48a5d0">&#9670;&nbsp;</a></span>VecXor64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecXor64 </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XOR two vectors as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>the first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>the second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a9ac4e5e7af3ea6f274f4b46f0f48a5d0" title="XOR two vectors as if uint64x2_p.">VecXor64()</a> performs <code>vec1 ^ vec2</code>. vec2 is cast to the same type as vec1. The return vector is the same type as vec1.</p>
<p><a class="el" href="ppc__simd_8h.html#a9ac4e5e7af3ea6f274f4b46f0f48a5d0" title="XOR two vectors as if uint64x2_p.">VecXor64()</a> is a convenience function that simply performs a <a class="el" href="ppc__simd_8h.html#a7362c0e6f4db03045b4494f95cb40703" title="XOR two vectors.">VecXor()</a>. </p><dl class="section user"><dt>Wraps</dt><dd>vec_xor </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02381">2381</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aba778788d5d08592aa7473da8a022656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba778788d5d08592aa7473da8a022656">&#9670;&nbsp;</a></span>VecSplatWord64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecSplatWord64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="config__int_8h.html#ad4deb8efeecc6bd2d1849445258335e9">word64</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast 64-bit double word to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the 64-bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_splats </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02392">2392</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a8c1fa7abbfda042f0c5e3d030686772c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1fa7abbfda042f0c5e3d030686772c">&#9670;&nbsp;</a></span>VecSplatElement64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecSplatElement64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast 64-bit element to a vector as if uint64x2_p. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>element number </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the 64-bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>vec_splat </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02411">2411</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ae433f2f8182668e016d3f75fc94e597e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae433f2f8182668e016d3f75fc94e597e">&#9670;&nbsp;</a></span>VecSplatElement64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecSplatElement64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast 64-bit element to a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>element number </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the 64-bit value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02437">2437</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aa1b420043a17199bdf544a7d4ffc4f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b420043a17199bdf544a7d4ffc4f02">&#9670;&nbsp;</a></span>VecPolyMultiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> VecPolyMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a3e56fac8b9dc01ebf52262069a3c94b5">uint32x4_p</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polynomial multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first term </td></tr>
    <tr><td class="paramname">b</td><td>the second term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector product</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aa1b420043a17199bdf544a7d4ffc4f02" title="Polynomial multiplication.">VecPolyMultiply()</a> performs polynomial multiplication. POWER8 polynomial multiplication multiplies the high and low terms, and then XOR's the high and low products. That is, the result is <code>ah*bh XOR al*bl</code>. It is different behavior than Intel polynomial multiplication. To obtain a single product without the XOR, then set one of the high or low terms to 0. For example, setting <code>ah=0</code> results in <code>0*bh XOR al*bl = al*bl</code>. </p><dl class="section user"><dt>Wraps</dt><dd>__vpmsumw, __builtin_altivec_crypto_vpmsumw and __builtin_crypto_vpmsumw. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02468">2468</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aa887a8e880e10ba42668ead47adb6d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa887a8e880e10ba42668ead47adb6d50">&#9670;&nbsp;</a></span>VecPolyMultiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecPolyMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polynomial multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first term </td></tr>
    <tr><td class="paramname">b</td><td>the second term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector product</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aa1b420043a17199bdf544a7d4ffc4f02" title="Polynomial multiplication.">VecPolyMultiply()</a> performs polynomial multiplication. POWER8 polynomial multiplication multiplies the high and low terms, and then XOR's the high and low products. That is, the result is <code>ah*bh XOR al*bl</code>. It is different behavior than Intel polynomial multiplication. To obtain a single product without the XOR, then set one of the high or low terms to 0. For example, setting <code>ah=0</code> results in <code>0*bh XOR al*bl = al*bl</code>. </p><dl class="section user"><dt>Wraps</dt><dd>__vpmsumd, __builtin_altivec_crypto_vpmsumd and __builtin_crypto_vpmsumd. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02493">2493</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a590c82896ba5e7136ba487849f68be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590c82896ba5e7136ba487849f68be75">&#9670;&nbsp;</a></span>VecIntelMultiply00()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecIntelMultiply00 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polynomial multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first term </td></tr>
    <tr><td class="paramname">b</td><td>the second term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector product</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#a590c82896ba5e7136ba487849f68be75" title="Polynomial multiplication.">VecIntelMultiply00()</a> performs polynomial multiplication and presents the result like Intel's <code>c = _mm_clmulepi64_si128(a, b, 0x00)</code>. The <code>0x00</code> indicates the low 64-bits of <code>a</code> and <code>b</code> are multiplied. </p><dl class="section note"><dt>Note</dt><dd>An Intel XMM register is composed of 128-bits. The leftmost bit is MSB and numbered 127, while the rightmost bit is LSB and numbered 0. </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>__vpmsumd, __builtin_altivec_crypto_vpmsumd and __builtin_crypto_vpmsumd. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02517">2517</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ad553d4e74a0b97c311fdd867ff9d167b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad553d4e74a0b97c311fdd867ff9d167b">&#9670;&nbsp;</a></span>VecIntelMultiply01()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecIntelMultiply01 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polynomial multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first term </td></tr>
    <tr><td class="paramname">b</td><td>the second term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector product</dd></dl>
<p>VecIntelMultiply01 performs() polynomial multiplication and presents the result like Intel's <code>c = _mm_clmulepi64_si128(a, b, 0x01)</code>. The <code>0x01</code> indicates the low 64-bits of <code>a</code> and high 64-bits of <code>b</code> are multiplied. </p><dl class="section note"><dt>Note</dt><dd>An Intel XMM register is composed of 128-bits. The leftmost bit is MSB and numbered 127, while the rightmost bit is LSB and numbered 0. </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>__vpmsumd, __builtin_altivec_crypto_vpmsumd and __builtin_crypto_vpmsumd. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02539">2539</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aef1de89001d67af434e518410eb7f327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1de89001d67af434e518410eb7f327">&#9670;&nbsp;</a></span>VecIntelMultiply10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecIntelMultiply10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polynomial multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first term </td></tr>
    <tr><td class="paramname">b</td><td>the second term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector product</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#aef1de89001d67af434e518410eb7f327" title="Polynomial multiplication.">VecIntelMultiply10()</a> performs polynomial multiplication and presents the result like Intel's <code>c = _mm_clmulepi64_si128(a, b, 0x10)</code>. The <code>0x10</code> indicates the high 64-bits of <code>a</code> and low 64-bits of <code>b</code> are multiplied. </p><dl class="section note"><dt>Note</dt><dd>An Intel XMM register is composed of 128-bits. The leftmost bit is MSB and numbered 127, while the rightmost bit is LSB and numbered 0. </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>__vpmsumd, __builtin_altivec_crypto_vpmsumd and __builtin_crypto_vpmsumd. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02561">2561</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="abd2604575828d21db939e48e3094a96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2604575828d21db939e48e3094a96e">&#9670;&nbsp;</a></span>VecIntelMultiply11()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> VecIntelMultiply11 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ppc__simd_8h.html#a7876e27953f12ff20b5a51fc071b806f">uint64x2_p</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polynomial multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first term </td></tr>
    <tr><td class="paramname">b</td><td>the second term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector product</dd></dl>
<p><a class="el" href="ppc__simd_8h.html#abd2604575828d21db939e48e3094a96e" title="Polynomial multiplication.">VecIntelMultiply11()</a> performs polynomial multiplication and presents the result like Intel's <code>c = _mm_clmulepi64_si128(a, b, 0x11)</code>. The <code>0x11</code> indicates the high 64-bits of <code>a</code> and <code>b</code> are multiplied. </p><dl class="section note"><dt>Note</dt><dd>An Intel XMM register is composed of 128-bits. The leftmost bit is MSB and numbered 127, while the rightmost bit is LSB and numbered 0. </dd></dl>
<dl class="section user"><dt>Wraps</dt><dd>__vpmsumd, __builtin_altivec_crypto_vpmsumd and __builtin_crypto_vpmsumd. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02583">2583</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a9cf39f0fa5e645b5fc10006edad213ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf39f0fa5e645b5fc10006edad213ce">&#9670;&nbsp;</a></span>VecEncrypt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecEncrypt </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> encryption. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state vector </td></tr>
    <tr><td class="paramname">key</td><td>the subkey vector</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a9cf39f0fa5e645b5fc10006edad213ce" title="One round of AES encryption.">VecEncrypt()</a> performs one round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> encryption of state using subkey key. The return vector is the same type as state.</p>
<p><a class="el" href="ppc__simd_8h.html#a9cf39f0fa5e645b5fc10006edad213ce" title="One round of AES encryption.">VecEncrypt()</a> is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>__vcipher, __builtin_altivec_crypto_vcipher, __builtin_crypto_vcipher </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GCC and XLC since Crypto++ 6.0, LLVM Clang since Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02609">2609</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a886160a705218fa1ae729455beaa7d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886160a705218fa1ae729455beaa7d5c">&#9670;&nbsp;</a></span>VecEncryptLast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecEncryptLast </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Final round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> encryption. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state vector </td></tr>
    <tr><td class="paramname">key</td><td>the subkey vector</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a886160a705218fa1ae729455beaa7d5c" title="Final round of AES encryption.">VecEncryptLast()</a> performs the final round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> encryption of state using subkey key. The return vector is the same type as state.</p>
<p><a class="el" href="ppc__simd_8h.html#a886160a705218fa1ae729455beaa7d5c" title="Final round of AES encryption.">VecEncryptLast()</a> is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>__vcipherlast, __builtin_altivec_crypto_vcipherlast, __builtin_crypto_vcipherlast </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GCC and XLC since Crypto++ 6.0, LLVM Clang since Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02634">2634</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="ac70e069364abc93f0670aa73a3d25dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70e069364abc93f0670aa73a3d25dea">&#9670;&nbsp;</a></span>VecDecrypt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecDecrypt </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> decryption. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state vector </td></tr>
    <tr><td class="paramname">key</td><td>the subkey vector</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#ac70e069364abc93f0670aa73a3d25dea" title="One round of AES decryption.">VecDecrypt()</a> performs one round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> decryption of state using subkey key. The return vector is the same type as state.</p>
<p><a class="el" href="ppc__simd_8h.html#ac70e069364abc93f0670aa73a3d25dea" title="One round of AES decryption.">VecDecrypt()</a> is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>__vncipher, __builtin_altivec_crypto_vncipher, __builtin_crypto_vncipher </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GCC and XLC since Crypto++ 6.0, LLVM Clang since Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02659">2659</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="aa19f8349a89c7383b15bfa06907e8460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19f8349a89c7383b15bfa06907e8460">&#9670;&nbsp;</a></span>VecDecryptLast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 VecDecryptLast </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Final round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> decryption. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>vector type </td></tr>
    <tr><td class="paramname">T2</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state vector </td></tr>
    <tr><td class="paramname">key</td><td>the subkey vector</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#aa19f8349a89c7383b15bfa06907e8460" title="Final round of AES decryption.">VecDecryptLast()</a> performs the final round of <a class="el" href="class_a_e_s.html" title="AES block cipher (Rijndael)">AES</a> decryption of state using subkey key. The return vector is the same type as state.</p>
<p><a class="el" href="ppc__simd_8h.html#aa19f8349a89c7383b15bfa06907e8460" title="Final round of AES decryption.">VecDecryptLast()</a> is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>__vncipherlast, __builtin_altivec_crypto_vncipherlast, __builtin_crypto_vncipherlast </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GCC and XLC since Crypto++ 6.0, LLVM Clang since Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02684">2684</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a4ca38aee965b3402835797962603b074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca38aee965b3402835797962603b074">&#9670;&nbsp;</a></span>VecSHA256()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int func, int fmask, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecSHA256 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_s_h_a256.html" title="SHA-256 message digest.">SHA256</a> Sigma functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">func</td><td>function </td></tr>
    <tr><td class="paramname">fmask</td><td>function mask </td></tr>
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the block to transform</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a4ca38aee965b3402835797962603b074" title="SHA256 Sigma functions.">VecSHA256()</a> selects sigma0, sigma1, Sigma0, Sigma1 based on func and fmask. The return vector is the same type as data.</p>
<p><a class="el" href="ppc__simd_8h.html#a4ca38aee965b3402835797962603b074" title="SHA256 Sigma functions.">VecSHA256()</a> is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>__vshasigmaw, __builtin_altivec_crypto_vshasigmaw, __builtin_crypto_vshasigmaw </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GCC and XLC since Crypto++ 6.0, LLVM Clang since Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02714">2714</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
<a id="a0f1050a43b985396890d2ac68f2c1a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1050a43b985396890d2ac68f2c1a54">&#9670;&nbsp;</a></span>VecSHA512()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int func, int fmask, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T VecSHA512 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_s_h_a512.html" title="SHA-512 message digest.">SHA512</a> Sigma functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">func</td><td>function </td></tr>
    <tr><td class="paramname">fmask</td><td>function mask </td></tr>
    <tr><td class="paramname">T</td><td>vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the block to transform</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ppc__simd_8h.html#a0f1050a43b985396890d2ac68f2c1a54" title="SHA512 Sigma functions.">VecSHA512()</a> selects sigma0, sigma1, Sigma0, Sigma1 based on func and fmask. The return vector is the same type as data.</p>
<p><a class="el" href="ppc__simd_8h.html#a0f1050a43b985396890d2ac68f2c1a54" title="SHA512 Sigma functions.">VecSHA512()</a> is available on POWER8 and above. </p><dl class="section user"><dt>Wraps</dt><dd>__vshasigmad, __builtin_altivec_crypto_vshasigmad, __builtin_crypto_vshasigmad </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GCC and XLC since Crypto++ 6.0, LLVM Clang since Crypto++ 8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ppc__simd_8h_source.html#l02739">2739</a> of file <a class="el" href="ppc__simd_8h_source.html">ppc_simd.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 26 2023 03:35:20 for Crypto++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
